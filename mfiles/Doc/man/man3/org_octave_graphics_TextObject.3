.TH "TextObject" 3 "Tue Nov 27 2012" "Version 3.2" "Octave" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TextObject \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBGraphicObject\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBTextObject\fP (\fBHandleObject\fP parent, String txt, double[] pos)"
.br
.ti -1c
.RI "void \fBvalidate\fP ()"
.br
.ti -1c
.RI "Rectangle \fBgetExtent\fP ()"
.br
.ti -1c
.RI "void \fBrender\fP (Graphics g)"
.br
.ti -1c
.RI "void \fBdrawAsImage\fP (\fBRenderer\fP renderer)"
.br
.ti -1c
.RI "void \fBdraw\fP (\fBRenderer\fP renderer)"
.br
.ti -1c
.RI "void \fBpropertyChanged\fP (\fBProperty\fP p)  throws PropertyException 	"
.br
.ti -1c
.RI "String \fBtoPostScript\fP ()"
.br
.ti -1c
.RI "\fBAxesObject\fP \fBgetAxes\fP ()"
.br
.ti -1c
.RI "void \fBset\fP (\fBProperty\fP p, Object value)  throws PropertyException 	"
.br
.ti -1c
.RI "void \fBset\fP (String name, Object value)  throws PropertyException 	"
.br
.ti -1c
.RI "boolean \fBisLegendable\fP ()"
.br
.ti -1c
.RI "double \fBgetHandle\fP ()"
.br
.ti -1c
.RI "String \fBgetType\fP ()"
.br
.ti -1c
.RI "\fBProperty\fP \fBgetDefaultProperty\fP (String name)"
.br
.ti -1c
.RI "void \fBdeleteChildren\fP ()"
.br
.ti -1c
.RI "void \fBdelete\fP ()"
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBHandleObject\fP child)"
.br
.ti -1c
.RI "void \fBremoveChild\fP (\fBHandleObject\fP child)"
.br
.ti -1c
.RI "void \fBaddProperty\fP (\fBProperty\fP p)"
.br
.ti -1c
.RI "boolean \fBisValid\fP ()"
.br
.ti -1c
.RI "void \fBsetCachedData\fP (Renderer\&.CachedData d)"
.br
.ti -1c
.RI "Renderer\&.CachedData \fBgetCachedData\fP ()"
.br
.ti -1c
.RI "java\&.awt\&.Component \fBgetComponent\fP ()"
.br
.ti -1c
.RI "\fBHandleObject\fP \fBgetAncestor\fP (String type)"
.br
.ti -1c
.RI "Object \fBget\fP (String name)  throws PropertyException 	"
.br
.ti -1c
.RI "Object \fBget\fP (\fBProperty\fP p)"
.br
.ti -1c
.RI "void \fBwaitFor\fP ()"
.br
.ti -1c
.RI "void \fBwaitFor\fP (String pname)"
.br
.ti -1c
.RI "void \fBwaitFor\fP (String pname, Object value)"
.br
.ti -1c
.RI "void \fBdoButtonDownFcn\fP (MouseEvent e)"
.br
.ti -1c
.RI "void \fBaddHandleEventSink\fP (String name, \fBHandleEventSink\fP sink)"
.br
.ti -1c
.RI "void \fBremoveHandleEventSink\fP (\fBHandleEventSink\fP sink)"
.br
.ti -1c
.RI "boolean \fBhasHandleEvent\fP (String name)"
.br
.ti -1c
.RI "void \fBeventOccured\fP (\fBHandleEvent\fP evt)  throws PropertyException 	"
.br
.ti -1c
.RI "void \fBsourceDeleted\fP (Object source)"
.br
.ti -1c
.RI "boolean \fBexecuteOnce\fP ()"
.br
.ti -1c
.RI "\fBProperty\fP \fBgetProperty\fP (String name)"
.br
.ti -1c
.RI "boolean \fBhasProperty\fP (String name)"
.br
.ti -1c
.RI "void \fBshow\fP ()"
.br
.ti -1c
.RI "String[] \fBgetNames\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static boolean \fBisHandle\fP (double \fBhandle\fP)"
.br
.ti -1c
.RI "static \fBHandleObject\fP \fBgetHandleObject\fP (double \fBhandle\fP)  throws Exception 	"
.br
.ti -1c
.RI "static void \fBremoveHandleObject\fP (double \fBhandle\fP)"
.br
.ti -1c
.RI "static void \fBaddHandleObject\fP (double \fBhandle\fP, \fBHandleObject\fP obj)"
.br
.ti -1c
.RI "static void \fBshutdown\fP ()"
.br
.ti -1c
.RI "static void \fBlistObjects\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBupdateMinMax\fP ()"
.br
.ti -1c
.RI "void \fBinitProperties\fP (\fBHandleObject\fP parent, String type)"
.br
.ti -1c
.RI "void \fBsetHandle\fP (double \fBhandle\fP)"
.br
.ti -1c
.RI "void \fBlisten\fP (\fBProperty\fP p)"
.br
.ti -1c
.RI "void \fBchildValidated\fP (\fBHandleObject\fP child)"
.br
.ti -1c
.RI "void \fBautoSet\fP (\fBProperty\fP p, Object value)"
.br
.ti -1c
.RI "boolean \fBisAutoMode\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static double \fBnewHandle\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "int \fBglID\fP"
.br
.ti -1c
.RI "int \fBautoMode\fP = 0"
.br
.ti -1c
.RI "\fBPropertySet\fP \fBdefaultSet\fP = new \fBPropertySet\fP()"
.br
.in -1c
.SS "Package Attributes"

.in +1c
.ti -1c
.RI "int \fBh\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBBackgroundColor\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBTextColor\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBEdgeColor\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBFontAngle\fP"
.br
.ti -1c
.RI "\fBStringProperty\fP \fBFontName\fP"
.br
.ti -1c
.RI "\fBDoubleProperty\fP \fBFontSize\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBFontWeight\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBFontUnits\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBHAlign\fP"
.br
.ti -1c
.RI "\fBLineStyleProperty\fP \fBLineStyle\fP"
.br
.ti -1c
.RI "\fBDoubleProperty\fP \fBLineWidth\fP"
.br
.ti -1c
.RI "\fBDoubleProperty\fP \fBMargin\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBPosition\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBPositionMode\fP"
.br
.ti -1c
.RI "\fBDoubleProperty\fP \fBRotation\fP"
.br
.ti -1c
.RI "\fBStringProperty\fP \fBTextString\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBUnits\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBVAlign\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBXLim\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBYLim\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBZLim\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBCLim\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBALim\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBXLimInclude\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBYLimInclude\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBZLimInclude\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBCLimInclude\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBALimInclude\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBLegendInclude\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBBeingDeleted\fP"
.br
.ti -1c
.RI "\fBCallbackProperty\fP \fBButtonDownFcn\fP"
.br
.ti -1c
.RI "\fBHandleObjectListProperty\fP \fBChildren\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBClipping\fP"
.br
.ti -1c
.RI "\fBCallbackProperty\fP \fBCreateFcn\fP"
.br
.ti -1c
.RI "\fBCallbackProperty\fP \fBDeleteFcn\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBHandleVisibility\fP"
.br
.ti -1c
.RI "\fBHandleObjectListProperty\fP \fBParent\fP"
.br
.ti -1c
.RI "\fBStringProperty\fP \fBTag\fP"
.br
.ti -1c
.RI "\fBStringProperty\fP \fBType\fP"
.br
.ti -1c
.RI "\fBObjectProperty\fP \fBUserData\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBVisible\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBupdateContent\fP ()"
.br
.ti -1c
.RI "void \fBupdateData\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "Font \fBfont\fP = null"
.br
.ti -1c
.RI "SimpleTextEngine\&.Content \fBcontent\fP"
.br
.ti -1c
.RI "ByteBuffer \fBdata\fP"
.br
.ti -1c
.RI "AffineTransform \fBT\fP"
.br
.ti -1c
.RI "Rectangle \fBr\fP"
.br
.ti -1c
.RI "int \fBw\fP"
.br
.ti -1c
.RI "String \fBcurrentUnits\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBTextObject\fP (\fBHandleObject\fPparent, Stringtxt, double[]pos)\fC [inline]\fP"
.PP
References TextObject\&.BackgroundColor, HandleObject\&.Clipping, TextObject\&.currentUnits, TextObject\&.EdgeColor, TextObject\&.FontAngle, TextObject\&.FontName, TextObject\&.FontSize, TextObject\&.FontUnits, TextObject\&.FontWeight, TextObject\&.HAlign, TextObject\&.LineStyle, TextObject\&.LineWidth, HandleObject\&.listen(), TextObject\&.Margin, TextObject\&.Position, TextObject\&.PositionMode, Property\&.reset(), TextObject\&.Rotation, TextObject\&.TextColor, TextObject\&.TextString, TextObject\&.Units, and TextObject\&.VAlign\&.
.PP
.nf
        {
                super(parent, 'text');

                Rotation = new DoubleProperty(this, 'Rotation', 0\&.0);
                HAlign = new RadioProperty(this, 'HorizontalAlignment', new String[] {'left', 'center', 'right'}, 'left');
                VAlign = new RadioProperty(this, 'VerticalAlignment', new String[] {'top', 'middle', 'bottom', 'baseline'}, 'middle');
                Position = new VectorProperty(this, 'Position', 3, pos);
                PositionMode = new BooleanProperty(this, 'PositionMode', true);
                Units = new RadioProperty(this, 'Units', new String[] {'pixels', 'data', 'normalized',
                        'inches', 'centimeters', 'points'}, 'data');
                currentUnits = 'data';
                TextColor = new ColorProperty(this, 'Color', Color\&.black);
                TextString = new StringProperty(this, 'String', txt);
                BackgroundColor = new ColorProperty(this, 'BackgroundColor', (Color)null);
                EdgeColor = new ColorProperty(this, 'EdgeColor', (Color)null);
                LineWidth = new DoubleProperty(this, 'LineWidth', 0\&.5);
                Margin = new DoubleProperty(this, 'Margin', 2\&.0);
                LineStyle = new LineStyleProperty(this, 'LineStyle', '-');
                FontAngle = new RadioProperty(this, 'FontAngle', new String[] {'normal', 'oblique', 'italic'}, 'normal');
                FontName = new StringProperty(this, 'FontName', 'Helvetica');
                FontSize = new DoubleProperty(this, 'FontSize', 10);
                FontWeight = new RadioProperty(this, 'FontWeight', new String[] {'light', 'normal', 'demi', 'bold'}, 'normal');
                FontUnits = new RadioProperty(this, 'FontUnits', new String[] {'points', 'normalized', 'inches',
                        'centimeters', 'pixels'}, 'points');
                Clipping\&.reset('off');

                listen(Units);
                listen(TextString);
                listen(Rotation);
                listen(TextColor);
                listen(BackgroundColor);
                listen(EdgeColor);
                listen(Margin);
                listen(LineStyle);
                listen(LineWidth);
                listen(Position);
                listen(FontAngle);
                listen(FontName);
                listen(FontSize);
                listen(FontWeight);
                listen(FontUnits);
                listen(HAlign);
        }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void \fBaddChild\fP (\fBHandleObject\fPchild)\fC [inline, inherited]\fP"
.PP
References HandleObjectListProperty\&.addElement(), and HandleObject\&.Children\&.
.PP
Referenced by HandleObject\&.initProperties()\&.
.PP
.nf
        {
                synchronized (Children)
                {
                        Children\&.addElement(child);
                }
        }
.fi
.SS "void \fBaddHandleEventSink\fP (Stringname, \fBHandleEventSink\fPsink)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSource\fP\&.
.PP
References HandleEventSourceHelper\&.addHandleEventSink(), and HandleObject\&.eventSource\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                eventSource\&.addHandleEventSink(name, sink);
        }
.fi
.SS "static void \fBaddHandleObject\fP (doublehandle, \fBHandleObject\fPobj)\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
Referenced by HandleObject\&.HandleObject(), and HandleObject\&.setHandle()\&.
.PP
.nf
        {
                handleMap\&.put(new Double(handle), new WeakReference(obj));
        }
.fi
.SS "void \fBaddProperty\fP (\fBProperty\fPp)\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
References HandleObject\&.isValid(), and Property\&.unLock()\&.
.PP
.nf
        {
                super\&.addProperty(p);
                if (isValid())
                        p\&.unLock();
        }
.fi
.SS "void \fBautoSet\fP (\fBProperty\fPp, Objectvalue)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.autoMode, and Property\&.set()\&.
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.autoAxis(), AxesObject\&.autoScaleC(), AxesObject\&.computeAutoTickLabels(), FigureObject\&.propertyChanged(), AxesObject\&.propertyChanged(), AxesObject\&.setInternalPosition(), PatchObject\&.updateCData(), PatchObject\&.updateFVCData(), PatchObject\&.updateFVData(), AxesObject\&.updateOuterPosition(), FigureObject\&.updatePosition(), AxesObject\&.updatePosition(), AxesObject\&.updateXFormMatrices(), and PatchObject\&.updateXYZData()\&.
.PP
.nf
        {
                autoMode++;
                p\&.set(value, true);
                autoMode--;
        }
.fi
.SS "void \fBchildValidated\fP (\fBHandleObject\fPchild)\fC [inline, protected, inherited]\fP"
.PP
Reimplemented in \fBAxesObject\fP, and \fBGroupObject\fP\&.
.PP
Referenced by HandleObject\&.validate()\&.
.PP
.nf
        {
        }
.fi
.SS "void \fBdelete\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
Reimplemented in \fBFigureObject\fP, \fBUIPanelObject\fP, \fBUIControlObject\fP, \fBBarseriesObject\fP, and \fBColorbarObject\fP\&.
.PP
References HandleObject\&.BeingDeleted, HandleObject\&.cachedData, HandleEventSourceHelper\&.delete(), HandleObject\&.deleteChildren(), HandleObject\&.DeleteFcn, HandleObjectListProperty\&.elementAt(), HandleObject\&.eventSource, HandleObject\&.eventSourceSet, CallbackProperty\&.execute(), HandleEventSourceHelper\&.fireEvent(), HandleObject\&.getHandle(), HandleObject\&.Parent, HandleObject\&.removeChild(), HandleObject\&.removeHandleEventSink(), HandleObject\&.removeHandleObject(), and Property\&.reset()\&.
.PP
Referenced by HandleObject\&.deleteChildren(), AxesObject\&.deleteChildren(), ColorbarObject\&.doClear(), LegendObject\&.doClear(), and AxesObject\&.makeLegend()\&.
.PP
.nf
        {
                BeingDeleted\&.reset('on');
                try { eventSource\&.fireEvent('ObjectDeleted'); }
                catch (PropertyException ex) {}
                DeleteFcn\&.execute(new Object[] {
                        new Double(getHandle()),
                        null});
                removeHandleObject(getHandle());

                super\&.delete();

                Iterator it = eventSourceSet\&.iterator();
                while (it\&.hasNext())
                        ((HandleEventSource)it\&.next())\&.removeHandleEventSink(this);
                eventSource\&.delete();

                deleteChildren();
                if (cachedData != null)
                        cachedData\&.dispose();
                Parent\&.elementAt(0)\&.removeChild(this);
        }
.fi
.SS "void \fBdeleteChildren\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBAxesObject\fP\&.
.PP
References HandleObject\&.Children, HandleObject\&.delete(), HandleObjectListProperty\&.elementAt(), HandleObjectListProperty\&.size(), StringProperty\&.toString(), and HandleObject\&.Type\&.
.PP
Referenced by HandleObject\&.delete()\&.
.PP
.nf
        {
                synchronized (Children)
                {
                        while (Children\&.size() > 0)
                        {
                                int len = Children\&.size();
                                HandleObject obj = Children\&.elementAt(0);

                                obj\&.delete();
                                if (Children\&.size() == len)
                                {
                                        System\&.out\&.println('ERROR: wrong parentship in graphic object of class `' + Type\&.toString() + '' with child of class `' + 
                                                        obj\&.Type\&.toString() + ''');
                                        break;
                                }
                        }
                }
        }
.fi
.SS "void \fBdoButtonDownFcn\fP (MouseEvente)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.ButtonDownFcn, CallbackProperty\&.execute(), HandleObject\&.getAncestor(), HandleObject\&.getHandle(), and CallbackProperty\&.unwind()\&.
.PP
Referenced by UIControlAdapter\&.mousePressed(), and AxesContainer\&.mousePressed()\&.
.PP
.nf
        {
                String selType = 'normal';

                switch (e\&.getButton())
                {
                        case MouseEvent\&.BUTTON2:
                                selType = 'extend';
                                break;
                        case MouseEvent\&.BUTTON3:
                                selType = 'alt';
                                break;
                }

                switch (e\&.getModifiers() & (MouseEvent\&.SHIFT_MASK|MouseEvent\&.CTRL_MASK))
                {
                        case MouseEvent\&.CTRL_MASK:
                                selType = 'alt';
                                break;
                        case MouseEvent\&.SHIFT_MASK:
                                selType = 'extend';
                                break;
                        case 0:
                                if (e\&.getClickCount() == 2)
                                        selType = 'open';
                                break;
                }

                ButtonDownFcn\&.unwind(((FigureObject)getAncestor('figure'))\&.SelectionType, selType);
                ButtonDownFcn\&.execute(new Object[] {
                        new Double(getHandle()),
                        null});
        }
.fi
.SS "void \fBdraw\fP (\fBRenderer\fPrenderer)\fC [inline, virtual]\fP"
.PP
Implements \fBGraphicObject\fP\&.
.PP
References Renderer\&.draw(), TextObject\&.TextString, and StringProperty\&.toString()\&.
.PP
.nf
        {
                if (TextString\&.toString() != '')
                        renderer\&.draw(this);
        }
.fi
.SS "void \fBdrawAsImage\fP (\fBRenderer\fPrenderer)\fC [inline]\fP"
.PP
References AxesObject\&.convertUnits(), TextObject\&.data, Renderer\&.draw(), VectorProperty\&.getArray(), GraphicObject\&.getAxes(), RadioProperty\&.getValue(), TextObject\&.h, TextObject\&.HAlign, RadioProperty\&.is(), TextObject\&.Position, TextObject\&.r, TextObject\&.T, TextObject\&.Units, TextObject\&.updateData(), TextObject\&.VAlign, TextObject\&.w, plt\&.x, and plt\&.y\&.
.PP
Referenced by GLRenderer\&.draw()\&.
.PP
.nf
        {
                if (data == null)
                        updateData();

                AxesObject ax = getAxes();
                double[] pos = ax\&.convertUnits(Position\&.getArray(), Units\&.getValue());
                boolean dataUnits = Units\&.is('data');

                int x = 0, y = 0, margin = -r\&.x;

                if (HAlign\&.is('center')) x = (r\&.width-2*margin)/2;
                else if (HAlign\&.is('right')) x = (r\&.width-2*margin);
                if (VAlign\&.is('bottom')) y = (r\&.height-2*margin);
                else if (VAlign\&.is('middle')) y = (r\&.height-2*margin)/2;
                else if (VAlign\&.is('baseline')) y = (r\&.height+r\&.y-margin);

                Point2D\&.Double p1 = new Point2D\&.Double(x, y), p2 = new Point2D\&.Double();
                T\&.transform(p1, p2);

                int xOffset = (int)p2\&.getX(), yOffset = h-(int)p2\&.getY();

                renderer\&.draw(data, w, h, pos, xOffset, yOffset, false, dataUnits);
        }
.fi
.SS "void \fBeventOccured\fP (\fBHandleEvent\fPevt)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSink\fP\&.
.PP
References HandleObject\&.propertyChanged()\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                if (evt\&.getName()\&.equals('PropertyChanged'))
                        propertyChanged(evt\&.getProperty());
        }
.fi
.SS "boolean \fBexecuteOnce\fP ()\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSink\fP\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                return false;
        }
.fi
.SS "Object \fBget\fP (\fBProperty\fPp)\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBFigureObject\fP, and \fBUIControlObject\fP\&.
.PP
.nf
        {
                return p\&.get();
        }
.fi
.SS "Object \fBget\fP (Stringname)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
References Property\&.get(), and HandleObject\&.getDefaultProperty()\&.
.PP
Referenced by AxesObject\&.autoScaleC(), and LegendObject\&.makeItemFromLine()\&.
.PP
.nf
        {
                if (name\&.toLowerCase()\&.startsWith('default'))
                {
                        Property p = getDefaultProperty(name);
                        if (p != null)
                                return p\&.get();
                        throw new PropertyException('invalid default property - ' + name\&.toLowerCase());
                }
                else
                        return super\&.get(name);
        }
.fi
.SS "\fBHandleObject\fP \fBgetAncestor\fP (Stringtype)\fC [inline, inherited]\fP"
.PP
References HandleObjectListProperty\&.elementAt(), HandleObject\&.Parent, HandleObjectListProperty\&.size(), StringProperty\&.toString(), and HandleObject\&.Type\&.
.PP
Referenced by AxesContainer\&.createCanvas(), HandleObject\&.doButtonDownFcn(), AxesContainer\&.getDefaultMouseOp(), AxesObject\&.getFigure(), and GraphicObject\&.set()\&.
.PP
.nf
        {
                HandleObject curr = this;

                while (true)
                {
                        if (curr\&.Type\&.toString()\&.equalsIgnoreCase(type))
                                return curr;
                        else if (curr\&.Parent\&.size() <= 0)
                                return null;
                        else
                                curr = curr\&.Parent\&.elementAt(0);
                }
        }
.fi
.SS "\fBAxesObject\fP \fBgetAxes\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObjectListProperty\&.elementAt(), and HandleObject\&.Parent\&.
.PP
Referenced by BarseriesObject\&.BarseriesObject(), BaseLineObject\&.BaseLineObject(), J2DRenderer\&.draw(), GLRenderer\&.draw(), TextObject\&.drawAsImage(), SurfaceObject\&.getAlphaData(), PatchObject\&.getAlphaData(), SurfaceObject\&.getCData(), PatchObject\&.getCData(), TextObject\&.getExtent(), ImageObject\&.ImageObject(), BaseLineObject\&.propertyChanged(), TextObject\&.propertyChanged(), SurfaceObject\&.SurfaceObject(), TextObject\&.toPostScript(), TextObject\&.updateData(), BaseLineObject\&.updateLine(), and TextObject\&.updateMinMax()\&.
.PP
.nf
        {
                HandleObject obj = Parent\&.elementAt(0);
                if (obj instanceof AxesObject)
                        return (AxesObject)obj;
                else
                        return ((GraphicObject)obj)\&.getAxes();
        }
.fi
.SS "Renderer\&.CachedData \fBgetCachedData\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObject\&.cachedData\&.
.PP
Referenced by GLRenderer\&.draw()\&.
.PP
.nf
        {
                return cachedData;
        }
.fi
.SS "java\&.awt\&.Component \fBgetComponent\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBFigureObject\fP, \fBUIPanelObject\fP, and \fBUIControlObject\fP\&.
.PP
Referenced by UIControlObject\&.getParentComponent(), and UIPanelObject\&.getParentComponent()\&.
.PP
.nf
        {
                System\&.out\&.println('Warning: no component associated with ' + getClass());
                return null;
        }
.fi
.SS "\fBProperty\fP \fBgetDefaultProperty\fP (Stringname)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.defaultSet, HandleObjectListProperty\&.elementAt(), Factory\&.getDefaultProperty(), HandleObject\&.getDefaultProperty(), PropertySet\&.getProperty(), HandleObject\&.Parent, and HandleObjectListProperty\&.size()\&.
.PP
Referenced by HandleObject\&.get(), HandleObject\&.getDefaultProperty(), Property\&.initDefault(), and HandleObject\&.set()\&.
.PP
.nf
        {
                Property p = defaultSet\&.getProperty(name);
                if (p != null)
                        return p;
                else if (Parent\&.size() > 0)
                        return Parent\&.elementAt(0)\&.getDefaultProperty(name);
                else
                        return Factory\&.getDefaultProperty(name);
        }
.fi
.SS "Rectangle \fBgetExtent\fP ()\fC [inline]\fP"
.PP
References TextObject\&.content, TextObject\&.FontAngle, TextObject\&.FontName, TextObject\&.FontSize, TextObject\&.FontUnits, TextObject\&.FontWeight, GraphicObject\&.getAxes(), AxesObject\&.getCanvas(), Utils\&.getFont(), and RenderCanvas\&.getHeight()\&.
.PP
Referenced by LegendObject\&.doLayout(), J2DRenderer\&.draw(), and TextObject\&.toPostScript()\&.
.PP
.nf
        {
                RenderCanvas comp = getAxes()\&.getCanvas();
                Font fnt = Utils\&.getFont(FontName, FontSize, FontUnits, FontAngle, FontWeight, comp\&.getHeight());
                return (Rectangle)content\&.layout(comp, fnt)\&.clone();
        }
.fi
.SS "double \fBgetHandle\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObject\&.handle\&.
.PP
Referenced by UIPanelObject\&.componentResized(), FigureObject\&.componentResized(), UIControlObject\&.controlActivated(), HandleObject\&.delete(), HandleObject\&.doButtonDownFcn(), OctaveSink\&.doInvoke(), RootObject\&.findFigure(), HandleObjectListProperty\&.getHandleArray(), HandleObject\&.HandleObject(), AxesObject\&.reset(), HandleObject\&.setHandle(), HandleObjectListProperty\&.toString(), FigureObject\&.updateHandle(), FigureObject\&.updateTitle(), HandleObject\&.validate(), and FigureObject\&.windowClosing()\&.
.PP
.nf
        {
                return handle;
        }
.fi
.SS "static \fBHandleObject\fP \fBgetHandleObject\fP (doublehandle)  throws \fBException\fP 	\fC [inline, static, inherited]\fP"
.PP
References RootObject\&.getInstance(), HandleObject\&.handle, and HandleObject\&.handleMap\&.
.PP
Referenced by TextProperty\&.convertValue(), HandleObjectListProperty\&.convertValue(), and RootObject\&.createNewFigure()\&.
.PP
.nf
        {
                WeakReference ref = (WeakReference)handleMap\&.get(new Double(handle));
                if (ref != null && ref\&.get() != null)
                {
                        return (HandleObject)ref\&.get();
                }
                if (handle == 0)
                        return RootObject\&.getInstance();
                throw new Exception('invalid handle - ' + handle);
        }
.fi
.SS "String [] \fBgetNames\fP ()\fC [inline, inherited]\fP"
.PP
References Property\&.getName(), and Property\&.isVisible()\&.
.PP
.nf
        {
                List names = new ArrayList();
                Iterator it = values()\&.iterator();
                while (it\&.hasNext())
                {
                        Property p = (Property)it\&.next();
                        if (p\&.isVisible())
                                names\&.add(p\&.getName());
                }
                return (String[])names\&.toArray(new String[names\&.size()]);
        }
.fi
.SS "\fBProperty\fP \fBgetProperty\fP (Stringname)\fC [inline, inherited]\fP"
.PP
Referenced by AxesObject\&.childValidated(), AxesObject\&.draw(), PropertySet\&.get(), AxesObject\&.getChildrenLimits(), HandleObject\&.getDefaultProperty(), OctaveSink\&.OctaveSink(), PropertySet\&.set(), and HandleObject\&.waitFor()\&.
.PP
.nf
        {
                return (Property)get((Object)name\&.toLowerCase());
        }
.fi
.SS "String \fBgetType\fP ()\fC [inline, inherited]\fP"
.PP
References StringProperty\&.toString(), and HandleObject\&.Type\&.
.PP
Referenced by Property\&.initDefault()\&.
.PP
.nf
        {
                return (Type != null ? Type\&.toString() : '');
        }
.fi
.SS "boolean \fBhasHandleEvent\fP (Stringname)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSource\fP\&.
.PP
References HandleObject\&.eventSource, and HandleEventSourceHelper\&.hasHandleEvent()\&.
.PP
Referenced by OctaveSink\&.OctaveSink()\&.
.PP
.nf
        {
                return eventSource\&.hasHandleEvent(name);
        }
.fi
.SS "boolean \fBhasProperty\fP (Stringname)\fC [inline, inherited]\fP"
.PP
Referenced by AxesObject\&.draw()\&.
.PP
.nf
        {
                return containsKey(name\&.toLowerCase());
        }
.fi
.SS "void \fBinitProperties\fP (\fBHandleObject\fPparent, Stringtype)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.addChild(), HandleObjectListProperty\&.addElement(), HandleObject\&.BeingDeleted, HandleObject\&.ButtonDownFcn, HandleObject\&.Children, HandleObject\&.Clipping, HandleObject\&.CreateFcn, HandleObject\&.DeleteFcn, HandleObject\&.HandleVisibility, HandleObject\&.Parent, HandleObject\&.Tag, HandleObject\&.Type, HandleObject\&.UserData, and HandleObject\&.Visible\&.
.PP
Referenced by HandleObject\&.HandleObject()\&.
.PP
.nf
        {
                // These properties must be created first, in order to
                // get correct behavior when looking for default values
                // of properties
                Type = new StringProperty(this, 'Type', type);
                Parent = new HandleObjectListProperty(this, 'Parent', -1);
                if (parent != null)
                        Parent\&.addElement(parent);

                // Create other properties
                BeingDeleted = new BooleanProperty(this, 'BeingDeleted', false);
                ButtonDownFcn = new CallbackProperty(this, 'ButtonDownFcn', (String)null);
                Children = new HandleObjectListProperty(this, 'Children', -1);
                Clipping = new BooleanProperty(this, 'Clipping', true);
                CreateFcn = new CallbackProperty(this, 'CreateFcn', (String)null);
                DeleteFcn = new CallbackProperty(this, 'DeleteFcn', (String)null);
                HandleVisibility = new RadioProperty(this, 'HandleVisibility', new String[] {'on', 'callback', 'off'}, 'on');
                Tag = new StringProperty(this, 'Tag', '');
                UserData = new ObjectProperty(this, 'UserData', null);
                Visible = new BooleanProperty(this, 'Visible', true);

                // TODO: move this to validate() ??
                if (parent != null)
                        parent\&.addChild(this);
        }
.fi
.SS "boolean \fBisAutoMode\fP ()\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.autoMode\&.
.PP
Referenced by ColorbarObject\&.propertyChanged(), FigureObject\&.propertyChanged(), LegendObject\&.propertyChanged(), and PatchObject\&.propertyChanged()\&.
.PP
.nf
        {
                return (autoMode > 0);
        }
.fi
.SS "static boolean \fBisHandle\fP (doublehandle)\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
Referenced by TextProperty\&.convertValue(), RootObject\&.createNewFigure(), and RootObject\&.getUnusedFigureNumber()\&.
.PP
.nf
        {
                WeakReference ref = (WeakReference)handleMap\&.get(new Double(handle));
                if (ref != null && ref\&.get() != null)
                        return true;
                return false;
        }
.fi
.SS "boolean \fBisLegendable\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBHandleObject\fP\&.
.PP
Reimplemented in \fBBaseLineObject\fP\&.
.PP
References BooleanProperty\&.isSet(), and GraphicObject\&.LegendInclude\&.
.PP
.nf
        {
                return LegendInclude\&.isSet();
        }
.fi
.SS "boolean \fBisValid\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObject\&.valid\&.
.PP
Referenced by HandleObject\&.addProperty(), AxesObject\&.childValidated(), UIControlObject\&.controlActivated(), AxesContainer\&.display(), AxesContainer\&.getObjectForPoint(), and AxesContainer\&.reshape()\&.
.PP
.nf
        {
                return valid;
        }
.fi
.SS "void \fBlisten\fP (\fBProperty\fPp)\fC [inline, protected, inherited]\fP"
.PP
References Property\&.addHandleEventSink(), HandleObject\&.eventSourceSet, and Property\&.getParent()\&.
.PP
Referenced by AxesObject\&.AxesObject(), BarseriesObject\&.BarseriesObject(), BaseLineObject\&.BaseLineObject(), GroupObject\&.childValidated(), AxesObject\&.childValidated(), ColorbarObject\&.ColorbarObject(), FigureObject\&.FigureObject(), ImageObject\&.ImageObject(), LegendObject\&.LegendObject(), LineObject\&.LineObject(), PatchObject\&.PatchObject(), RootObject\&.RootObject(), SurfaceObject\&.SurfaceObject(), TextObject\&.TextObject(), UIControlObject\&.UIControlObject(), and UIPanelObject\&.UIPanelObject()\&.
.PP
.nf
        {
                p\&.addHandleEventSink('PropertyChanged', this);
                if (p\&.getParent() != this)
                        eventSourceSet\&.add(p);
        }
.fi
.SS "static void \fBlistObjects\fP ()\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap, and HandleObject\&.HandleObject()\&.
.PP
.nf
        {
                Iterator it = handleMap\&.entrySet()\&.iterator();
                while (it\&.hasNext())
                {
                        Map\&.Entry entry = (Map\&.Entry)it\&.next();
                        HandleObject hObj = (HandleObject)((WeakReference)entry\&.getValue())\&.get();
                        System\&.out\&.println(entry\&.getKey() + ' = ' + hObj\&.getClass());
                }
        }
.fi
.SS "static double \fBnewHandle\fP ()\fC [inline, static, protected, inherited]\fP"
.PP
References HandleObject\&.handleSeed\&.
.PP
Referenced by HandleObject\&.HandleObject(), UIPanelObject\&.UIPanelObject(), and FigureObject\&.updateHandle()\&.
.PP
.nf
        {
                double h = handleSeed;
                handleSeed = Math\&.ceil(handleSeed) - 1 - Math\&.random();
                return h;
        }
.fi
.SS "void \fBpropertyChanged\fP (\fBProperty\fPp)  throws \fBPropertyException\fP 	\fC [inline]\fP"
.PP
Reimplemented from \fBHandleObject\fP\&.
.PP
References TextObject\&.BackgroundColor, TextObject\&.content, AxesObject\&.convertUnits(), TextObject\&.currentUnits, TextObject\&.data, TextObject\&.EdgeColor, TextObject\&.FontAngle, TextObject\&.FontName, TextObject\&.FontSize, TextObject\&.FontWeight, VectorProperty\&.getArray(), GraphicObject\&.getAxes(), RadioProperty\&.getValue(), TextObject\&.HAlign, RadioProperty\&.is(), TextObject\&.LineStyle, TextObject\&.LineWidth, TextObject\&.Margin, TextObject\&.Position, TextObject\&.PositionMode, Property\&.reset(), TextObject\&.Rotation, BooleanProperty\&.set(), TextObject\&.TextColor, TextObject\&.TextString, StringProperty\&.toString(), TextObject\&.Units, TextObject\&.updateContent(), and TextObject\&.updateMinMax()\&.
.PP
.nf
        {
                super\&.propertyChanged(p);

                if (p == Units)
                {
                        AxesObject ax = getAxes();
                        Position\&.reset(ax\&.convertUnits(Position\&.getArray(), currentUnits, Units\&.getValue()));
                        currentUnits = Units\&.getValue();
                }
                else if (p == TextString)
                        updateContent();
                else if (p == Rotation || p == TextColor || p == BackgroundColor || p == EdgeColor ||
                                 p == Margin || p == LineStyle || p == LineWidth || p == FontAngle ||
                                 p == FontName || p == FontSize || p == FontWeight || (p == HAlign && TextString\&.toString()\&.indexOf('\n') != -1))
                        data = null;

                if (p == HAlign)
                        content\&.align = (HAlign\&.is('left') ? 0 : (HAlign\&.is('center') ? 1 : 2));

                if (p == Units || p == Position)
                        PositionMode\&.set(new Boolean(false));

                if (p == Position)
                        updateMinMax();
        }
.fi
.SS "void \fBremoveChild\fP (\fBHandleObject\fPchild)\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBAxesObject\fP, \fBFigureObject\fP, \fBGroupObject\fP, and \fBRootObject\fP\&.
.PP
References HandleObject\&.Children, and HandleObjectListProperty\&.removeElement()\&.
.PP
Referenced by HandleObject\&.delete()\&.
.PP
.nf
        {
                synchronized (Children)
                {
                        Children\&.removeElement(child);
                }
        }
.fi
.SS "void \fBremoveHandleEventSink\fP (\fBHandleEventSink\fPsink)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSource\fP\&.
.PP
References HandleObject\&.eventSource, and HandleEventSourceHelper\&.removeHandleEventSink()\&.
.PP
Referenced by HandleObject\&.delete()\&.
.PP
.nf
        {
                eventSource\&.removeHandleEventSink(sink);
        }
.fi
.SS "static void \fBremoveHandleObject\fP (doublehandle)\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
Referenced by HandleObject\&.delete(), and HandleObject\&.setHandle()\&.
.PP
.nf
        {
                handleMap\&.remove(new Double(handle));
        }
.fi
.SS "void \fBrender\fP (Graphicsg)\fC [inline]\fP"
.PP
References TextObject\&.content\&.
.PP
Referenced by J2DRenderer\&.draw()\&.
.PP
.nf
        {
                content\&.render((Graphics2D)g);
        }
.fi
.SS "void \fBset\fP (\fBProperty\fPp, Objectvalue)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
References FigureObject\&.__Dirty__, HandleObject\&.getAncestor(), and Property\&.reset()\&.
.PP
Referenced by LegendObject\&.propertyChanged()\&.
.PP
.nf
        {
                super\&.set(p, value);

                FigureObject fig = (FigureObject)getAncestor('figure');
                fig\&.__Dirty__\&.reset('on');
        }
.fi
.SS "void \fBset\fP (Stringname, Objectvalue)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
References PropertySet\&.addProperty(), Property\&.cloneProperty(), HandleObject\&.defaultSet, HandleObject\&.getDefaultProperty(), and Property\&.set()\&.
.PP
.nf
        {
                if (name\&.toLowerCase()\&.startsWith('default'))
                {
                        Property p = getDefaultProperty(name);
                        if (p != null)
                        {
                                Property new_p = p\&.cloneProperty();
                                new_p\&.set(value);
                                defaultSet\&.addProperty(new_p);
                        }
                        else
                                throw new PropertyException('invalid default property - ' + name\&.toLowerCase());
                }
                else
                        super\&.set(name, value);
        }
.fi
.SS "void \fBsetCachedData\fP (Renderer\&.CachedDatad)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.cachedData\&.
.PP
Referenced by GLRenderer\&.draw(), and SurfaceObject\&.propertyChanged()\&.
.PP
.nf
        {
                if (cachedData != null)
                        cachedData\&.dispose();
                cachedData = d;
        }
.fi
.SS "void \fBsetHandle\fP (doublehandle)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.addHandleObject(), HandleObject\&.getHandle(), HandleObject\&.handle, and HandleObject\&.removeHandleObject()\&.
.PP
Referenced by FigureObject\&.updateHandle()\&.
.PP
.nf
        {
                removeHandleObject(getHandle());
                this\&.handle = handle;
                addHandleObject(getHandle(), this);
        }
.fi
.SS "void \fBshow\fP ()\fC [inline, inherited]\fP"
.PP
References Property\&.getName(), and Property\&.isVisible()\&.
.PP
.nf
        {
                Iterator it = values()\&.iterator();
                while (it\&.hasNext())
                {
                        Property p = (Property)it\&.next();
                        if (p\&.isVisible())
                        {
                                get(p); /* force any getter to execute */
                                System\&.out\&.println('  ' + p\&.getName() + ' = ' + p);
                        }
                }
        }
.fi
.SS "static void \fBshutdown\fP ()\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
.nf
        {
                LinkedList figList = new LinkedList();
                Iterator it = handleMap\&.values()\&.iterator();

                while (it\&.hasNext())
                {
                        WeakReference ref = (WeakReference)it\&.next();
                        if (ref != null && ref\&.get() != null && ref\&.get() instanceof FigureObject)
                                figList\&.add(ref\&.get());
                }

                it = figList\&.iterator();
                while (it\&.hasNext())
                        ((HandleObject)it\&.next())\&.delete();
        }
.fi
.SS "void \fBsourceDeleted\fP (Objectsource)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSink\fP\&.
.PP
References HandleObject\&.eventSourceSet\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                eventSourceSet\&.remove(source);
        }
.fi
.SS "String \fBtoPostScript\fP ()\fC [inline]\fP"
.PP
References TextObject\&.BackgroundColor, TextObject\&.content, ed(), TextObject\&.EdgeColor, DoubleProperty\&.floatValue(), TextObject\&.FontAngle, TextObject\&.FontName, TextObject\&.FontSize, TextObject\&.FontUnits, TextObject\&.FontWeight, GraphicObject\&.getAxes(), ColorProperty\&.getColor(), TextObject\&.getExtent(), Utils\&.getFontSize(), Utils\&.getScreenResolution(), TextObject\&.h, TextObject\&.HAlign, RadioProperty\&.is(), ColorProperty\&.isSet(), TextObject\&.LineStyle, TextObject\&.LineWidth, TextObject\&.Margin, TextObject\&.r, TextObject\&.Rotation, TextObject\&.TextColor, LineStyleProperty\&.toPostScript(), StringProperty\&.toString(), TextObject\&.VAlign, TextObject\&.w, plt\&.x, and plt\&.y\&.
.PP
Referenced by GLRenderer\&.draw()\&.
.PP
.nf
        {
                StringBuffer buf = new StringBuffer();
                SimpleTextEngine\&.PSTextRenderer r = new SimpleTextEngine\&.PSTextRenderer(buf,
                                FontName\&.toString(), Utils\&.getFontSize(FontSize, FontUnits, getAxes()\&.getCanvas()\&.getHeight()),
                                (FontAngle\&.is('normal') ? 0 : Font\&.ITALIC)|(FontWeight\&.is('normal') ? 0 : Font\&.BOLD),
                                TextColor\&.getColor());

                /* save current state */
                buf\&.append('gsave\n');
                /* text rotation */
                float angle = Rotation\&.floatValue();
                if (angle != 0\&.0f)
                        buf\&.append(angle + ' rotate\n');
                /* text box */
                float f = 72\&.0f/Utils\&.getScreenResolution();
                Rectangle re = getExtent();
                if (BackgroundColor\&.isSet() || (EdgeColor\&.isSet() && !LineStyle\&.is('none')))
                {
                        float x = 0, y = 0, margin = Margin\&.floatValue(), w, h;

                        if (HAlign\&.is('center')) x = -re\&.width/2-margin;
                        else if (HAlign\&.is('right')) x = -re\&.width-2*margin;
                        else x = -margin;
                        if (VAlign\&.is('baseline')) y = re\&.height+re\&.y+margin;
                        else if (VAlign\&.is('bottom')) y = re\&.height+margin;
                        else if (VAlign\&.is('top')) y = margin;
                        else y = re\&.height/2+margin;

                        w = re\&.width+2*margin;
                        h = re\&.height+2*margin;

                        buf\&.append('gsave\n' + (f*x) + ' ' + (f*y) + ' rmoveto SP\n');
                        if (BackgroundColor\&.isSet())
                        {
                                float[] bk = BackgroundColor\&.getColor()\&.getRGBColorComponents(null);

                                buf\&.append(bk[0] + ' ' + bk[1] + ' ' + bk[2] + ' C\n');
                                buf\&.append('newpath dup RP\n');
                                buf\&.append((f*w) + ' 0 rlineto\n');
                                buf\&.append('0 ' + (f*(-h)) + ' rlineto\n');
                                buf\&.append((f*(-w)) + ' 0 rlineto\n');
                                buf\&.append('0 ' + (f*h) + ' rlineto\nclosepath fill\n');
                        }
                        if (EdgeColor\&.isSet() && !LineStyle\&.is('none'))
                        {
                                float[] ed = EdgeColor\&.getColor()\&.getRGBColorComponents(null);

                                buf\&.append(ed[0] + ' ' + ed[1] + ' ' + ed[2] + ' C\n');
                                buf\&.append(LineWidth\&.floatValue() + ' W\n');
                                buf\&.append(LineStyle\&.toPostScript() + '\n');
                                buf\&.append('newpath dup RP\n');
                                buf\&.append((f*w) + ' 0 rlineto\n');
                                buf\&.append('0 ' + (f*(-h)) + ' rlineto\n');
                                buf\&.append((f*(-w)) + ' 0 rlineto\n');
                                buf\&.append('0 ' + (f*h) + ' rlineto\nclosepath stroke\n');
                        }
                        buf\&.append('pop grestore\n');
                }
                /* text vertical alignment */
                if (!VAlign\&.is('baseline'))
                {
                        if (VAlign\&.is('top'))
                                buf\&.append('0 -' + (f*(re\&.height+re\&.y)) + ' rmoveto\n');
                        else if (VAlign\&.is('bottom'))
                                buf\&.append('0 ' + (f*(-re\&.y)) + ' rmoveto\n');
                        else
                                buf\&.append('0 ' + (f*(-re\&.height/2-re\&.y)) + ' rmoveto\n');
                }
                /* text content */
                content\&.render(r);
                /* restore state */
                buf\&.append('grestore\n');

                return buf\&.toString();
        }
.fi
.SS "void \fBupdateContent\fP ()\fC [inline, private]\fP"
.PP
References TextObject\&.content, TextObject\&.data, TextObject\&.HAlign, RadioProperty\&.is(), TextObject\&.TextString, and StringProperty\&.toString()\&.
.PP
Referenced by TextObject\&.propertyChanged(), and TextObject\&.validate()\&.
.PP
.nf
        {
                content = new SimpleTextEngine\&.Content(TextString\&.toString());
                content\&.align = (HAlign\&.is('left') ? 0 : (HAlign\&.is('center') ? 1 : 2));
                data = null;
        }
.fi
.SS "void \fBupdateData\fP ()\fC [inline, private]\fP"
.PP
References TextObject\&.BackgroundColor, TextObject\&.content, TextObject\&.data, DoubleProperty\&.doubleValue(), TextObject\&.EdgeColor, DoubleProperty\&.floatValue(), TextObject\&.FontAngle, TextObject\&.FontName, TextObject\&.FontSize, TextObject\&.FontUnits, TextObject\&.FontWeight, GraphicObject\&.getAxes(), AxesObject\&.getCanvas(), ColorProperty\&.getColor(), Utils\&.getFont(), RenderCanvas\&.getHeight(), LineStyleProperty\&.getStroke(), TextObject\&.h, DoubleProperty\&.intValue(), RadioProperty\&.is(), ColorProperty\&.isSet(), TextObject\&.LineStyle, TextObject\&.LineWidth, TextObject\&.Margin, TextObject\&.r, TextObject\&.Rotation, TextObject\&.T, TextObject\&.TextColor, and TextObject\&.w\&.
.PP
Referenced by TextObject\&.drawAsImage()\&.
.PP
.nf
        {
                RenderCanvas comp = getAxes()\&.getCanvas();
                double angle = Rotation\&.doubleValue()*Math\&.PI/180\&.0;
                int angleD = Rotation\&.intValue();
                int margin = Margin\&.intValue();
                int offset = (LineWidth\&.intValue()+1)/2;

                if (EdgeColor\&.isSet())
                        margin += LineWidth\&.intValue();

                Font fnt = Utils\&.getFont(FontName, FontSize, FontUnits, FontAngle, FontWeight, comp\&.getHeight());

                r = (Rectangle)content\&.layout(comp, fnt)\&.clone();
                r\&.x -= margin;
                r\&.y -= margin;
                r\&.width += 2*margin;
                r\&.height += 2*margin;
                w = (int)Math\&.round(Math\&.abs(r\&.width*Math\&.cos(angle))+Math\&.abs(r\&.height*Math\&.sin(angle)));
                h = (int)Math\&.round(Math\&.abs(r\&.height*Math\&.cos(angle))+Math\&.abs(r\&.width*Math\&.sin(angle)));
                while (angleD < 0) angleD += 360;
                while (angleD > 360) angleD -= 360;

                BufferedImage img = new BufferedImage(w, h, BufferedImage\&.TYPE_4BYTE_ABGR);

                Graphics2D g = img\&.createGraphics();
                //g\&.setRenderingHint(RenderingHints\&.KEY_TEXT_ANTIALIASING, RenderingHints\&.VALUE_TEXT_ANTIALIAS_ON);
                g\&.setComposite(AlphaComposite\&.getInstance(AlphaComposite\&.CLEAR, 0\&.0f));
                g\&.fillRect(0, 0, w, h);
                g\&.setPaintMode();
                switch ((angleD/90)%4)
                {
                        case 0:
                                g\&.translate(0, r\&.width*Math\&.sin(angle));
                                break;
                        case 1:
                                g\&.translate(r\&.width*Math\&.sin(angle-Math\&.PI/2\&.0), h);
                                break;
                        case 2:
                                g\&.translate(w, h-r\&.width*Math\&.sin(angle-Math\&.PI));
                                break;
                        case 3:
                                g\&.translate(w-r\&.width*Math\&.sin(angle-3\&.0*Math\&.PI/2\&.0), 0);
                                break;
                }
                g\&.rotate(-angle);
                g\&.translate(margin, margin);
                T = g\&.getTransform();
                if (BackgroundColor\&.isSet())
                {
                        g\&.setColor(BackgroundColor\&.getColor());
                        g\&.fillRect(-margin+offset, -margin+offset, r\&.width-2*offset-1, r\&.height-2*offset-1);
                }
                if (EdgeColor\&.isSet() && !LineStyle\&.is('none'))
                {
                        Stroke oldS = g\&.getStroke();
                        g\&.setStroke(LineStyle\&.getStroke(LineWidth\&.floatValue()));
                        g\&.setColor(EdgeColor\&.getColor());
                        g\&.drawRect(-margin+offset, -margin+offset, r\&.width-2*offset-1, r\&.height-2*offset-1);
                        g\&.setStroke(oldS);
                }
                g\&.setColor(TextColor\&.getColor());
                g\&.setFont(fnt);
                content\&.render(g);
                g\&.dispose();
                com\&.sun\&.opengl\&.util\&.ImageUtil\&.flipImageVertically(img);

                data = ByteBuffer\&.wrap(((DataBufferByte)img\&.getData()\&.getDataBuffer())\&.getData());
        }
.fi
.SS "void \fBupdateMinMax\fP ()\fC [inline, protected]\fP"
.PP
References AxesObject\&.convertUnits(), VectorProperty\&.getArray(), GraphicObject\&.getAxes(), RadioProperty\&.getValue(), RadioProperty\&.is(), TextObject\&.Position, Property\&.set(), TextObject\&.Units, GraphicObject\&.XLim, GraphicObject\&.YLim, and GraphicObject\&.ZLim\&.
.PP
Referenced by TextObject\&.propertyChanged(), and TextObject\&.validate()\&.
.PP
.nf
        {
                if (Units\&.is('data'))
                {
                        double[] p = getAxes()\&.convertUnits(Position\&.getArray(), Units\&.getValue());
                        double xmin2 = (p[0] <= 0 ? Double\&.POSITIVE_INFINITY : p[0]);
                        double xmax2 = (p[0] <= 0 ? Double\&.MIN_VALUE : p[0]);
                        double ymin2 = (p[1] <= 0 ? Double\&.POSITIVE_INFINITY : p[1]);
                        double ymax2 = (p[1] <= 0 ? Double\&.MIN_VALUE : p[1]);
                        double zmin2 = (p[2] <= 0 ? Double\&.POSITIVE_INFINITY : p[2]);
                        double zmax2 = (p[2] <= 0 ? Double\&.MIN_VALUE : p[2]);

                        XLim\&.set(new double[] {p[0], p[0], xmin2, xmax2}, true);
                        YLim\&.set(new double[] {p[1], p[1], ymin2, ymax2}, true);
                        ZLim\&.set(new double[] {p[2], p[2], zmin2, zmax2}, true);
                }
                else
                {
                        double[] lims = new double[] {Double\&.POSITIVE_INFINITY, Double\&.NEGATIVE_INFINITY,
                                Double\&.POSITIVE_INFINITY, Double\&.MIN_VALUE};
                        XLim\&.set(lims, true);
                        YLim\&.set(lims, true);
                        ZLim\&.set(lims, true);
                }
        }
.fi
.SS "void \fBvalidate\fP ()\fC [inline]\fP"
.PP
Reimplemented from \fBHandleObject\fP\&.
.PP
References TextObject\&.currentUnits, RadioProperty\&.getValue(), TextObject\&.Units, TextObject\&.updateContent(), and TextObject\&.updateMinMax()\&.
.PP
Referenced by LegendObject\&.makeItemFromLine(), and AxesObject\&.makeTextObject()\&.
.PP
.nf
        {
                currentUnits = Units\&.getValue();
                updateContent();
                updateMinMax();
                super\&.validate();
        }
.fi
.SS "void \fBwaitFor\fP ()\fC [inline, inherited]\fP"
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                waitFor(null, null, false);
        }
.fi
.SS "void \fBwaitFor\fP (Stringpname)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.waitFor()\&.
.PP
.nf
        {
                waitFor(pname, null, false);
        }
.fi
.SS "void \fBwaitFor\fP (Stringpname, Objectvalue)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.waitFor()\&.
.PP
.nf
        {
                waitFor(pname, value, true);
        }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBVectorProperty\fP \fBALim\fP\fC [package, inherited]\fP"
.PP
Referenced by GroupObject\&.childValidated(), GraphicObject\&.GraphicObject(), and GroupObject\&.updateLimits()\&.
.SS "\fBBooleanProperty\fP \fBALimInclude\fP\fC [package, inherited]\fP"
.PP
Referenced by GraphicObject\&.GraphicObject(), PatchObject\&.PatchObject(), and SurfaceObject\&.SurfaceObject()\&.
.SS "int \fBautoMode\fP = 0\fC [protected, inherited]\fP"
.PP
Referenced by HandleObject\&.autoSet(), ColorbarObject\&.doLocate(), LegendObject\&.doLocate(), AxesObject\&.doZoom(), AxesObject\&.draw(), HandleObject\&.isAutoMode(), ColorbarObject\&.propertyChanged(), LegendObject\&.propertyChanged(), AxesObject\&.propertyChanged(), and AxesObject\&.unZoom()\&.
.SS "\fBColorProperty\fP \fBBackgroundColor\fP\fC [package]\fP"
.PP
Referenced by TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBBooleanProperty\fP \fBBeingDeleted\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.delete(), HandleObject\&.initProperties(), and AxesObject\&.removeChild()\&.
.SS "\fBCallbackProperty\fP \fBButtonDownFcn\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.doButtonDownFcn(), and HandleObject\&.initProperties()\&.
.SS "\fBHandleObjectListProperty\fP \fBChildren\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.addChild(), AxesObject\&.autoLegend(), AxesObject\&.autoScaleC(), LegendObject\&.buildLegend(), HandleObject\&.deleteChildren(), AxesContainer\&.display(), ColorbarObject\&.doClear(), LegendObject\&.doClear(), GroupObject\&.draw(), AxesObject\&.draw(), RootObject\&.findFigure(), AxesObject\&.getChildrenLimits(), AxesContainer\&.getObjectForPoint(), BarseriesObject\&.getPatch(), HandleObject\&.initProperties(), RootObject\&.removeChild(), HandleObject\&.removeChild(), AxesContainer\&.reshape(), ColorbarObject\&.updateImageFromColormap(), GroupObject\&.updateLimits(), GroupObject\&.validate(), and HandleObject\&.validate()\&.
.SS "\fBVectorProperty\fP \fBCLim\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleC(), GroupObject\&.childValidated(), AxesObject\&.childValidated(), BarseriesObject\&.doLayout(), GraphicObject\&.GraphicObject(), SurfaceObject\&.updateColorMinMax(), GroupObject\&.updateLimits(), ImageObject\&.updateMinMax(), and PatchObject\&.updateMinMax()\&.
.SS "\fBBooleanProperty\fP \fBCLimInclude\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleC(), BarseriesObject\&.BarseriesObject(), GraphicObject\&.GraphicObject(), ImageObject\&.ImageObject(), PatchObject\&.PatchObject(), and SurfaceObject\&.SurfaceObject()\&.
.SS "\fBBooleanProperty\fP \fBClipping\fP\fC [package, inherited]\fP"
.PP
Referenced by GLRenderer\&.draw(), AxesObject\&.draw(), HandleObject\&.initProperties(), and TextObject\&.TextObject()\&.
.SS "SimpleTextEngine\&.Content \fBcontent\fP\fC [private]\fP"
.PP
Referenced by TextObject\&.getExtent(), TextObject\&.propertyChanged(), TextObject\&.render(), TextObject\&.toPostScript(), TextObject\&.updateContent(), and TextObject\&.updateData()\&.
.SS "\fBCallbackProperty\fP \fBCreateFcn\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.initProperties(), and HandleObject\&.validate()\&.
.SS "String \fBcurrentUnits\fP\fC [private]\fP"
.PP
Referenced by TextObject\&.propertyChanged(), TextObject\&.TextObject(), and TextObject\&.validate()\&.
.SS "ByteBuffer \fBdata\fP\fC [private]\fP"
.PP
Referenced by TextObject\&.drawAsImage(), TextObject\&.propertyChanged(), TextObject\&.updateContent(), and TextObject\&.updateData()\&.
.SS "\fBPropertySet\fP \fBdefaultSet\fP = new \fBPropertySet\fP()\fC [protected, inherited]\fP"
.PP
Referenced by HandleObject\&.getDefaultProperty(), and HandleObject\&.set()\&.
.SS "\fBCallbackProperty\fP \fBDeleteFcn\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.delete(), and HandleObject\&.initProperties()\&.
.SS "\fBColorProperty\fP \fBEdgeColor\fP\fC [package]\fP"
.PP
Referenced by TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "Font \fBfont\fP = null\fC [private]\fP"
.SS "\fBRadioProperty\fP \fBFontAngle\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), TextObject\&.getExtent(), LegendObject\&.makeItemFromLine(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBStringProperty\fP \fBFontName\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), TextObject\&.getExtent(), LegendObject\&.makeItemFromLine(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBDoubleProperty\fP \fBFontSize\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), TextObject\&.getExtent(), LegendObject\&.makeItemFromLine(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBRadioProperty\fP \fBFontUnits\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), TextObject\&.getExtent(), LegendObject\&.makeItemFromLine(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBRadioProperty\fP \fBFontWeight\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), TextObject\&.getExtent(), LegendObject\&.makeItemFromLine(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "int \fBglID\fP\fC [protected, inherited]\fP"
.PP
Referenced by GraphicObject\&.GraphicObject()\&.
.SS "int \fBh\fP\fC [package]\fP"
.PP
Referenced by TextObject\&.drawAsImage(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBRadioProperty\fP \fBHAlign\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), AxesObject\&.draw(), TextObject\&.drawAsImage(), AxesObject\&.makeTextObject(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateContent()\&.
.SS "\fBRadioProperty\fP \fBHandleVisibility\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObjectListProperty\&.getVisibleObjects(), HandleObject\&.initProperties(), and AxesObject\&.makeTextObject()\&.
.SS "\fBBooleanProperty\fP \fBLegendInclude\fP\fC [package, inherited]\fP"
.PP
Referenced by GraphicObject\&.GraphicObject(), GraphicObject\&.isLegendable(), and LineObject\&.LineObject()\&.
.SS "\fBLineStyleProperty\fP \fBLineStyle\fP\fC [package]\fP"
.PP
Referenced by TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBDoubleProperty\fP \fBLineWidth\fP\fC [package]\fP"
.PP
Referenced by TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBDoubleProperty\fP \fBMargin\fP\fC [package]\fP"
.PP
Referenced by TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBHandleObjectListProperty\fP \fBParent\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.delete(), HandleObject\&.getAncestor(), GraphicObject\&.getAxes(), AxesObject\&.getAxesContainer(), AxesObject\&.getCanvas(), HandleObject\&.getDefaultProperty(), UIControlObject\&.getParentComponent(), UIPanelObject\&.getParentComponent(), HandleObject\&.initProperties(), LegendObject\&.LegendObject(), and HandleObject\&.validate()\&.
.SS "\fBVectorProperty\fP \fBPosition\fP\fC [package]\fP"
.PP
Referenced by LegendObject\&.doLayout(), J2DRenderer\&.draw(), AxesObject\&.draw(), GLRenderer\&.draw(), TextObject\&.drawAsImage(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), and TextObject\&.updateMinMax()\&.
.SS "\fBBooleanProperty\fP \fBPositionMode\fP\fC [package]\fP"
.PP
Referenced by AxesObject\&.draw(), TextObject\&.propertyChanged(), and TextObject\&.TextObject()\&.
.SS "Rectangle \fBr\fP\fC [private]\fP"
.PP
Referenced by TextObject\&.drawAsImage(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBDoubleProperty\fP \fBRotation\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), AxesObject\&.draw(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "AffineTransform \fBT\fP\fC [private]\fP"
.PP
Referenced by TextObject\&.drawAsImage(), and TextObject\&.updateData()\&.
.SS "\fBStringProperty\fP \fBTag\fP\fC [package, inherited]\fP"
.PP
Referenced by ColorbarObject\&.ColorbarObject(), HandleObject\&.initProperties(), and LegendObject\&.LegendObject()\&.
.SS "\fBColorProperty\fP \fBTextColor\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), LegendObject\&.makeItemFromLine(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBStringProperty\fP \fBTextString\fP\fC [package]\fP"
.PP
Referenced by TextObject\&.draw(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), and TextObject\&.updateContent()\&.
.SS "\fBStringProperty\fP \fBType\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.deleteChildren(), HandleObject\&.getAncestor(), HandleObject\&.getType(), HandleObject\&.initProperties(), and OctaveSink\&.OctaveSink()\&.
.SS "\fBRadioProperty\fP \fBUnits\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), GLRenderer\&.draw(), TextObject\&.drawAsImage(), TextObject\&.propertyChanged(), TextObject\&.TextObject(), TextObject\&.updateMinMax(), and TextObject\&.validate()\&.
.SS "\fBObjectProperty\fP \fBUserData\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.initProperties()\&.
.SS "\fBRadioProperty\fP \fBVAlign\fP\fC [package]\fP"
.PP
Referenced by J2DRenderer\&.draw(), AxesObject\&.draw(), TextObject\&.drawAsImage(), LegendObject\&.makeItemFromLine(), AxesObject\&.makeTextObject(), TextObject\&.TextObject(), and TextObject\&.toPostScript()\&.
.SS "\fBBooleanProperty\fP \fBVisible\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.childValidated(), FigureObject\&.createFigure(), AxesObject\&.draw(), FigureObject\&.FigureObject(), AxesObject\&.getChildrenLimits(), HandleObject\&.initProperties(), FigureObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "int \fBw\fP\fC [private]\fP"
.PP
Referenced by TextObject\&.drawAsImage(), TextObject\&.toPostScript(), and TextObject\&.updateData()\&.
.SS "\fBVectorProperty\fP \fBXLim\fP\fC [package, inherited]\fP"
.PP
Referenced by BaseLineObject\&.BaseLineObject(), GroupObject\&.childValidated(), AxesObject\&.childValidated(), BarseriesObject\&.doLayout(), GraphicObject\&.GraphicObject(), GroupObject\&.updateLimits(), BaseLineObject\&.updateLine(), ImageObject\&.updateMinMax(), LineObject\&.updateMinMax(), SurfaceObject\&.updateMinMax(), PatchObject\&.updateMinMax(), and TextObject\&.updateMinMax()\&.
.SS "\fBBooleanProperty\fP \fBXLimInclude\fP\fC [package, inherited]\fP"
.PP
Referenced by BaseLineObject\&.BaseLineObject(), GraphicObject\&.GraphicObject(), AxesObject\&.makeTextObject(), and BaseLineObject\&.propertyChanged()\&.
.SS "\fBVectorProperty\fP \fBYLim\fP\fC [package, inherited]\fP"
.PP
Referenced by BaseLineObject\&.BaseLineObject(), GroupObject\&.childValidated(), AxesObject\&.childValidated(), BarseriesObject\&.doLayout(), GraphicObject\&.GraphicObject(), GroupObject\&.updateLimits(), BaseLineObject\&.updateLine(), ImageObject\&.updateMinMax(), LineObject\&.updateMinMax(), SurfaceObject\&.updateMinMax(), PatchObject\&.updateMinMax(), and TextObject\&.updateMinMax()\&.
.SS "\fBBooleanProperty\fP \fBYLimInclude\fP\fC [package, inherited]\fP"
.PP
Referenced by GraphicObject\&.GraphicObject(), AxesObject\&.makeTextObject(), and BaseLineObject\&.propertyChanged()\&.
.SS "\fBVectorProperty\fP \fBZLim\fP\fC [package, inherited]\fP"
.PP
Referenced by GroupObject\&.childValidated(), AxesObject\&.childValidated(), BarseriesObject\&.doLayout(), GraphicObject\&.GraphicObject(), GroupObject\&.updateLimits(), LineObject\&.updateMinMax(), SurfaceObject\&.updateMinMax(), PatchObject\&.updateMinMax(), and TextObject\&.updateMinMax()\&.
.SS "\fBBooleanProperty\fP \fBZLimInclude\fP\fC [package, inherited]\fP"
.PP
Referenced by GraphicObject\&.GraphicObject(), LineObject\&.LineObject(), PatchObject\&.PatchObject(), LineObject\&.propertyChanged(), SurfaceObject\&.SurfaceObject(), and LineObject\&.validate()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Octave from the source code\&.
