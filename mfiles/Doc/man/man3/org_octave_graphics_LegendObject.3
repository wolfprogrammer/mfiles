.TH "LegendObject" 3 "Tue Nov 27 2012" "Version 3.2" "Octave" \" -*- nroff -*-
.ad l
.nh
.SH NAME
LegendObject \- 
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBAxesObject\fP\&.
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBLegendItem\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBLegendObject\fP (\fBAxesObject\fP \fBaxes\fP, \fBString\fP[] names)"
.br
.ti -1c
.RI "void \fBbuildLegend\fP (\fBAxesObject\fP \fBaxes\fP, \fBString\fP[] names)"
.br
.ti -1c
.RI "int \fBsize\fP ()"
.br
.ti -1c
.RI "void \fBpropertyChanged\fP (\fBProperty\fP p)  throws PropertyException 	"
.br
.ti -1c
.RI "void \fBreset\fP (\fBString\fP mode)"
.br
.ti -1c
.RI "void \fBvalidate\fP ()"
.br
.ti -1c
.RI "void \fBdeleteChildren\fP ()"
.br
.ti -1c
.RI "void \fBremoveChild\fP (\fBHandleObject\fP child)"
.br
.ti -1c
.RI "\fBRenderCanvas\fP \fBgetCanvas\fP ()"
.br
.ti -1c
.RI "\fBFigureObject\fP \fBgetFigure\fP ()"
.br
.ti -1c
.RI "\fBAxesContainer\fP \fBgetAxesContainer\fP ()"
.br
.ti -1c
.RI "\fBLegendObject\fP \fBgetLegend\fP ()"
.br
.ti -1c
.RI "\fBLegendObject\fP \fBmakeLegend\fP (\fBString\fP names[])"
.br
.ti -1c
.RI "\fBColorbarObject\fP \fBmakeColorbar\fP (boolean mode)"
.br
.ti -1c
.RI "\fBBaseLineObject\fP \fBgetBaseLine\fP ()"
.br
.ti -1c
.RI "void \fBchildValidated\fP (\fBHandleObject\fP child)"
.br
.ti -1c
.RI "void \fBdraw\fP (\fBRenderer\fP r)"
.br
.ti -1c
.RI "void \fBunZoom\fP ()"
.br
.ti -1c
.RI "void \fBstartOperation\fP (int op, MouseEvent e)"
.br
.ti -1c
.RI "void \fBendOperation\fP (int op, MouseEvent e)"
.br
.ti -1c
.RI "void \fBcancelOperation\fP (int op)"
.br
.ti -1c
.RI "void \fBoperation\fP (int op, MouseEvent e)"
.br
.ti -1c
.RI "void \fBupdateScalers\fP ()"
.br
.ti -1c
.RI "void \fBunTransform\fP (double x, double y, double z, double[] p, int offset)"
.br
.ti -1c
.RI "void \fBtransform\fP (double x, double y, double z, double[] p, int offset)"
.br
.ti -1c
.RI "void \fBupdateXFormMatrices\fP ()"
.br
.ti -1c
.RI "double \fBgetHandle\fP ()"
.br
.ti -1c
.RI "\fBString\fP \fBgetType\fP ()"
.br
.ti -1c
.RI "\fBProperty\fP \fBgetDefaultProperty\fP (\fBString\fP name)"
.br
.ti -1c
.RI "boolean \fBisLegendable\fP ()"
.br
.ti -1c
.RI "void \fBdelete\fP ()"
.br
.ti -1c
.RI "void \fBaddChild\fP (\fBHandleObject\fP child)"
.br
.ti -1c
.RI "void \fBaddProperty\fP (\fBProperty\fP p)"
.br
.ti -1c
.RI "boolean \fBisValid\fP ()"
.br
.ti -1c
.RI "void \fBsetCachedData\fP (Renderer\&.CachedData d)"
.br
.ti -1c
.RI "Renderer\&.CachedData \fBgetCachedData\fP ()"
.br
.ti -1c
.RI "java\&.awt\&.Component \fBgetComponent\fP ()"
.br
.ti -1c
.RI "\fBHandleObject\fP \fBgetAncestor\fP (\fBString\fP type)"
.br
.ti -1c
.RI "Object \fBget\fP (\fBString\fP name)  throws PropertyException 	"
.br
.ti -1c
.RI "Object \fBget\fP (\fBProperty\fP p)"
.br
.ti -1c
.RI "void \fBset\fP (\fBString\fP name, Object value)  throws PropertyException 	"
.br
.ti -1c
.RI "void \fBset\fP (\fBProperty\fP p, Object value)  throws PropertyException 	"
.br
.ti -1c
.RI "void \fBwaitFor\fP ()"
.br
.ti -1c
.RI "void \fBwaitFor\fP (\fBString\fP pname)"
.br
.ti -1c
.RI "void \fBwaitFor\fP (\fBString\fP pname, Object value)"
.br
.ti -1c
.RI "void \fBdoButtonDownFcn\fP (MouseEvent e)"
.br
.ti -1c
.RI "void \fBaddHandleEventSink\fP (\fBString\fP name, \fBHandleEventSink\fP sink)"
.br
.ti -1c
.RI "void \fBremoveHandleEventSink\fP (\fBHandleEventSink\fP sink)"
.br
.ti -1c
.RI "boolean \fBhasHandleEvent\fP (\fBString\fP name)"
.br
.ti -1c
.RI "void \fBeventOccured\fP (\fBHandleEvent\fP evt)  throws PropertyException 	"
.br
.ti -1c
.RI "void \fBsourceDeleted\fP (Object source)"
.br
.ti -1c
.RI "boolean \fBexecuteOnce\fP ()"
.br
.ti -1c
.RI "\fBProperty\fP \fBgetProperty\fP (\fBString\fP name)"
.br
.ti -1c
.RI "boolean \fBhasProperty\fP (\fBString\fP name)"
.br
.ti -1c
.RI "void \fBshow\fP ()"
.br
.ti -1c
.RI "\fBString\fP[] \fBgetNames\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static boolean \fBisHandle\fP (double \fBhandle\fP)"
.br
.ti -1c
.RI "static \fBHandleObject\fP \fBgetHandleObject\fP (double \fBhandle\fP)  throws Exception 	"
.br
.ti -1c
.RI "static void \fBremoveHandleObject\fP (double \fBhandle\fP)"
.br
.ti -1c
.RI "static void \fBaddHandleObject\fP (double \fBhandle\fP, \fBHandleObject\fP obj)"
.br
.ti -1c
.RI "static void \fBshutdown\fP ()"
.br
.ti -1c
.RI "static void \fBlistObjects\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBsetInternalPosition\fP (double[] p)"
.br
.ti -1c
.RI "void \fBautoLegend\fP ()"
.br
.ti -1c
.RI "void \fBautoScale\fP ()"
.br
.ti -1c
.RI "double[] \fBgetChildrenLimits\fP (\fBString\fP Lim, boolean logMode, boolean isZ)"
.br
.ti -1c
.RI "double \fBgetTickInterval\fP (double[] lim, int nMax)"
.br
.ti -1c
.RI "void \fBautoAxis\fP (\fBVectorProperty\fP Lim, boolean autoLim, \fBVectorProperty\fP Tick, boolean \fBautoTick\fP, \fBRadioProperty\fP Scale, boolean isZ)"
.br
.ti -1c
.RI "void \fBautoScaleX\fP ()"
.br
.ti -1c
.RI "void \fBautoScaleY\fP ()"
.br
.ti -1c
.RI "void \fBautoScaleZ\fP ()"
.br
.ti -1c
.RI "void \fBautoScaleC\fP ()"
.br
.ti -1c
.RI "void \fBautoScaleA\fP ()"
.br
.ti -1c
.RI "void \fBautoTick\fP ()"
.br
.ti -1c
.RI "double[] \fBcomputeMinorTicks\fP (\fBVectorProperty\fP Lim, \fBVectorProperty\fP Tick, \fBRadioProperty\fP Scale)"
.br
.ti -1c
.RI "void \fBautoTickX\fP ()"
.br
.ti -1c
.RI "void \fBautoMinorTickX\fP ()"
.br
.ti -1c
.RI "void \fBautoTickY\fP ()"
.br
.ti -1c
.RI "void \fBautoMinorTickY\fP ()"
.br
.ti -1c
.RI "void \fBautoTickZ\fP ()"
.br
.ti -1c
.RI "void \fBautoMinorTickZ\fP ()"
.br
.ti -1c
.RI "void \fBautoTickLabel\fP ()"
.br
.ti -1c
.RI "boolean \fBcomputeAutoTickLabels\fP (\fBVectorProperty\fP Tick, \fBRadioProperty\fP Scale, \fBStringArrayProperty\fP TickLabel)"
.br
.ti -1c
.RI "void \fBautoTickLabelX\fP ()"
.br
.ti -1c
.RI "void \fBautoTickLabelY\fP ()"
.br
.ti -1c
.RI "void \fBautoTickLabelZ\fP ()"
.br
.ti -1c
.RI "void \fBautoCamera\fP ()"
.br
.ti -1c
.RI "void \fBautoAspectRatio\fP ()"
.br
.ti -1c
.RI "void \fBinitProperties\fP (\fBHandleObject\fP parent, \fBString\fP type)"
.br
.ti -1c
.RI "void \fBsetHandle\fP (double \fBhandle\fP)"
.br
.ti -1c
.RI "void \fBlisten\fP (\fBProperty\fP p)"
.br
.ti -1c
.RI "void \fBautoSet\fP (\fBProperty\fP p, Object value)"
.br
.ti -1c
.RI "boolean \fBisAutoMode\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static double \fBnewHandle\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "boolean \fBalwaysDrawBox\fP = true"
.br
.ti -1c
.RI "int \fBautoMode\fP = 0"
.br
.ti -1c
.RI "\fBPropertySet\fP \fBdefaultSet\fP = new \fBPropertySet\fP()"
.br
.in -1c
.SS "Package Functions"

.in +1c
.ti -1c
.RI "void \fBupdateActivePosition\fP ()"
.br
.ti -1c
.RI "Rectangle \fBgetBoundingBox\fP ()"
.br
.ti -1c
.RI "Rectangle \fBgetOuterBoundingBox\fP ()"
.br
.ti -1c
.RI "void \fBupdatePosition\fP ()"
.br
.ti -1c
.RI "void \fBupdateOuterPosition\fP ()"
.br
.ti -1c
.RI "double[] \fBconvertUnits\fP (double[] pos, \fBString\fP units)"
.br
.ti -1c
.RI "double[] \fBconvertUnits\fP (double[] pos, \fBString\fP units, \fBString\fP toUnits)"
.br
.ti -1c
.RI "Matrix \fBconvertCData\fP (Matrix cdata, \fBString\fP mapping)"
.br
.ti -1c
.RI "double[][] \fBconvertCData\fP (double[] cdata, \fBString\fP mapping)"
.br
.ti -1c
.RI "double[][][] \fBconvertCData\fP (double[][] cdata, \fBString\fP mapping)"
.br
.ti -1c
.RI "double[][] \fBconvertCDataToIndex\fP (double[][] cdata)"
.br
.in -1c
.SS "Package Attributes"

.in +1c
.ti -1c
.RI "\fBRadioProperty\fP \fBLocation\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBEdgeColor\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBTextColor\fP"
.br
.ti -1c
.RI "\fBStringArrayProperty\fP \fBString\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBOrientation\fP"
.br
.ti -1c
.RI "\fBLegendObject\fP \fBlegend\fP"
.br
.ti -1c
.RI "\fBColorbarObject\fP \fBcolorbar\fP"
.br
.ti -1c
.RI "\fBBaseLineObject\fP \fBbaseLine\fP"
.br
.ti -1c
.RI "int \fByPrev\fP"
.br
.ti -1c
.RI "int \fBxAnchor\fP"
.br
.ti -1c
.RI "int \fByAnchor\fP"
.br
.ti -1c
.RI "\fBScaler\fP \fBsx\fP"
.br
.ti -1c
.RI "\fBScaler\fP \fBsy\fP"
.br
.ti -1c
.RI "\fBScaler\fP \fBsz\fP"
.br
.ti -1c
.RI "\fBScaler\fP \fBlinScale\fP"
.br
.ti -1c
.RI "\fBScaler\fP \fBlogScale\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBActivePositionProperty\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBPosition\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBOuterPosition\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBUnits\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBProjection\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBAxesColor\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBXColor\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBYColor\fP"
.br
.ti -1c
.RI "\fBColorProperty\fP \fBZColor\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBXLim\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBYLim\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBZLim\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBXLimMode\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBYLimMode\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBZLimMode\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBXGrid\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBYGrid\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBZGrid\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBXMinorGrid\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBYMinorGrid\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBZMinorGrid\fP"
.br
.ti -1c
.RI "\fBLineStyleProperty\fP \fBGridLineStyle\fP"
.br
.ti -1c
.RI "\fBLineStyleProperty\fP \fBMinorGridLineStyle\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBXTick\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBYTick\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBZTick\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBXTickMode\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBYTickMode\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBZTickMode\fP"
.br
.ti -1c
.RI "\fBStringArrayProperty\fP \fBXTickLabel\fP"
.br
.ti -1c
.RI "\fBStringArrayProperty\fP \fBYTickLabel\fP"
.br
.ti -1c
.RI "\fBStringArrayProperty\fP \fBZTickLabel\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBXTickLabelMode\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBYTickLabelMode\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBZTickLabelMode\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBXMinorTick\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBYMinorTick\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBZMinorTick\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBNextPlot\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBBox\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBTickDir\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBTickDirMode\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBCameraTarget\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBCameraTargetMode\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBCameraPosition\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBCameraPositionMode\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBCameraUpVector\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBCameraUpVectorMode\fP"
.br
.ti -1c
.RI "\fBDoubleProperty\fP \fBCameraViewAngle\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBCameraViewAngleMode\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBDataAspectRatio\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBDataAspectRatioMode\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBPlotBoxAspectRatio\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBPlotBoxAspectRatioMode\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBView\fP"
.br
.ti -1c
.RI "\fBTextProperty\fP \fBTitle\fP"
.br
.ti -1c
.RI "\fBTextProperty\fP \fBXLabel\fP"
.br
.ti -1c
.RI "\fBTextProperty\fP \fBYLabel\fP"
.br
.ti -1c
.RI "\fBTextProperty\fP \fBZLabel\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBCLim\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBCLimMode\fP"
.br
.ti -1c
.RI "\fBVectorProperty\fP \fBALim\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBALimMode\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBXDir\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBYDir\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBZDir\fP"
.br
.ti -1c
.RI "\fBArrayProperty\fP \fBx_NormRenderTransform\fP"
.br
.ti -1c
.RI "\fBArrayProperty\fP \fBx_RenderTransform\fP"
.br
.ti -1c
.RI "\fBArrayProperty\fP \fBx_ViewTransform\fP"
.br
.ti -1c
.RI "\fBArrayProperty\fP \fBx_ProjectionTransform\fP"
.br
.ti -1c
.RI "\fBArrayProperty\fP \fBx_ViewportTransform\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBXScale\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBYScale\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBZScale\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBXAxisLocation\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBYAxisLocation\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBLayer\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBKey\fP"
.br
.ti -1c
.RI "\fBDoubleProperty\fP \fBLineWidth\fP"
.br
.ti -1c
.RI "\fBArrayProperty\fP \fBColorOrder\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBFontAngle\fP"
.br
.ti -1c
.RI "\fBStringProperty\fP \fBFontName\fP"
.br
.ti -1c
.RI "\fBDoubleProperty\fP \fBFontSize\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBFontWeight\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBFontUnits\fP"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_view\fP = new \fBMatrix3D\fP()"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_projection\fP = new \fBMatrix3D\fP()"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_viewport\fP = new \fBMatrix3D\fP()"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_normrender\fP = new \fBMatrix3D\fP()"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_render\fP = new \fBMatrix3D\fP()"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_renderInv\fP"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_mat1\fP = new \fBMatrix3D\fP()"
.br
.ti -1c
.RI "\fBMatrix3D\fP \fBx_mat2\fP = new \fBMatrix3D\fP()"
.br
.ti -1c
.RI "double \fBx_zmin\fP"
.br
.ti -1c
.RI "double \fBx_zmax\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBBeingDeleted\fP"
.br
.ti -1c
.RI "\fBCallbackProperty\fP \fBButtonDownFcn\fP"
.br
.ti -1c
.RI "\fBHandleObjectListProperty\fP \fBChildren\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBClipping\fP"
.br
.ti -1c
.RI "\fBCallbackProperty\fP \fBCreateFcn\fP"
.br
.ti -1c
.RI "\fBCallbackProperty\fP \fBDeleteFcn\fP"
.br
.ti -1c
.RI "\fBRadioProperty\fP \fBHandleVisibility\fP"
.br
.ti -1c
.RI "\fBHandleObjectListProperty\fP \fBParent\fP"
.br
.ti -1c
.RI "\fBStringProperty\fP \fBTag\fP"
.br
.ti -1c
.RI "\fBStringProperty\fP \fBType\fP"
.br
.ti -1c
.RI "\fBObjectProperty\fP \fBUserData\fP"
.br
.ti -1c
.RI "\fBBooleanProperty\fP \fBVisible\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBLegendItem\fP \fBmakeItemFromLine\fP (\fBHandleObject\fP line, \fBString\fP name)"
.br
.ti -1c
.RI "void \fBdoClear\fP ()"
.br
.ti -1c
.RI "void \fBdoLayout\fP ()"
.br
.ti -1c
.RI "void \fBdoLocate\fP ()"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "\fBLegendItem\fP[] \fBitems\fP"
.br
.ti -1c
.RI "\fBAxesObject\fP \fBaxes\fP"
.br
.ti -1c
.RI "Dimension \fBsize\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBLegendObject\fP (\fBAxesObject\fPaxes, \fBString\fP[]names)\fC [inline]\fP"
.PP
References AxesObject\&.ActivePositionProperty, AxesObject\&.alwaysDrawBox, LegendObject\&.buildLegend(), DoubleProperty\&.doubleValue(), LegendObject\&.EdgeColor, HandleObjectListProperty\&.elementAt(), AxesObject\&.FontAngle, AxesObject\&.FontName, AxesObject\&.FontSize, AxesObject\&.FontUnits, AxesObject\&.FontWeight, Property\&.get(), RadioProperty\&.getValue(), HandleObject\&.listen(), LegendObject\&.Location, LegendObject\&.Orientation, AxesObject\&.OuterPosition, HandleObject\&.Parent, AxesObject\&.Position, Property\&.reset(), LegendObject\&.String, HandleObject\&.Tag, LegendObject\&.TextColor, StringProperty\&.toString(), AxesObject\&.XColor, AxesObject\&.XLim, AxesObject\&.XLimMode, AxesObject\&.XTick, AxesObject\&.XTickLabel, AxesObject\&.XTickLabelMode, AxesObject\&.XTickMode, AxesObject\&.YColor, AxesObject\&.YLim, AxesObject\&.YLimMode, AxesObject\&.YTick, AxesObject\&.YTickLabel, AxesObject\&.YTickLabelMode, AxesObject\&.YTickMode, AxesObject\&.ZColor, AxesObject\&.ZLim, AxesObject\&.ZLimMode, AxesObject\&.ZTick, AxesObject\&.ZTickLabel, AxesObject\&.ZTickLabelMode, and AxesObject\&.ZTickMode\&.
.PP
.nf
        {
                super(axes\&.Parent\&.elementAt(0), false);
                alwaysDrawBox = false;

                Location = new RadioProperty(this, 'Location',
                        new String[] {
                                'North', 'South', 'East', 'West',
                                'NorthEast', 'NorthWest', 'SouthEast', 'SouthWest',
                                'NorthOutside', 'SouthOutside', 'EastOutside', 'WestOutside',
                                'NorthEastOutside', 'NorthWestOutside', 'SouthEastOutside', 'SouthWestOutside',
                                 'Best', 'BestOutside', 'none'},
                        'NorthEast');
                EdgeColor = new ColorProperty(this, 'EdgeColor', new String[] {'none'}, Color\&.black);
                TextColor = new ColorProperty(this, 'TextColor', new String[] {'none'}, Color\&.black);
                String = new StringArrayProperty(this, 'String', new String[0]);
                Orientation = new RadioProperty(this, 'Orientation', new String[] {'vertical', 'horizontal'}, 'vertical');

                ActivePositionProperty\&.reset('position');
                XLimMode\&.reset('manual');
                YLimMode\&.reset('manual');
                ZLimMode\&.reset('manual');
                XLim\&.reset(new double[] {0, 1});
                YLim\&.reset(new double[] {0, 1});
                ZLim\&.reset(new double[] {-0\&.5, 0\&.5});
                XTickMode\&.reset('manual');
                YTickMode\&.reset('manual');
                ZTickMode\&.reset('manual');
                XTick\&.reset(null);
                YTick\&.reset(null);
                ZTick\&.reset(null);
                XTickLabelMode\&.reset('manual');
                YTickLabelMode\&.reset('manual');
                ZTickLabelMode\&.reset('manual');
                XTickLabel\&.reset(null);
                YTickLabel\&.reset(null);
                ZTickLabel\&.reset(null);
                XColor\&.reset(EdgeColor\&.get());
                YColor\&.reset(EdgeColor\&.get());
                ZColor\&.reset(EdgeColor\&.get());
                Tag\&.reset('legend');
                FontName\&.reset(axes\&.FontName\&.toString());
                FontSize\&.reset(new Double(axes\&.FontSize\&.doubleValue()));
                FontUnits\&.reset(axes\&.FontUnits\&.getValue());
                FontWeight\&.reset(axes\&.FontWeight\&.getValue());
                FontAngle\&.reset(axes\&.FontAngle\&.getValue());

                listen(axes\&.Position);
                listen(axes\&.OuterPosition);
                listen(Location);
                listen(Orientation);
                listen(EdgeColor);
                listen(TextColor);
                listen(String);
                
                buildLegend(axes, names);
        }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void \fBaddChild\fP (\fBHandleObject\fPchild)\fC [inline, inherited]\fP"
.PP
References HandleObjectListProperty\&.addElement(), and HandleObject\&.Children\&.
.PP
Referenced by HandleObject\&.initProperties()\&.
.PP
.nf
        {
                synchronized (Children)
                {
                        Children\&.addElement(child);
                }
        }
.fi
.SS "void \fBaddHandleEventSink\fP (Stringname, \fBHandleEventSink\fPsink)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSource\fP\&.
.PP
References HandleEventSourceHelper\&.addHandleEventSink(), and HandleObject\&.eventSource\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                eventSource\&.addHandleEventSink(name, sink);
        }
.fi
.SS "static void \fBaddHandleObject\fP (doublehandle, \fBHandleObject\fPobj)\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
Referenced by HandleObject\&.HandleObject(), and HandleObject\&.setHandle()\&.
.PP
.nf
        {
                handleMap\&.put(new Double(handle), new WeakReference(obj));
        }
.fi
.SS "void \fBaddProperty\fP (\fBProperty\fPp)\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
References HandleObject\&.isValid(), and Property\&.unLock()\&.
.PP
.nf
        {
                super\&.addProperty(p);
                if (isValid())
                        p\&.unLock();
        }
.fi
.SS "void \fBautoAspectRatio\fP ()\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.autoSet(), AxesObject\&.DataAspectRatio, AxesObject\&.DataAspectRatioMode, VectorProperty\&.elementAt(), VectorProperty\&.getArray(), RadioProperty\&.is(), AxesObject\&.PlotBoxAspectRatio, AxesObject\&.PlotBoxAspectRatioMode, AxesObject\&.XLim, AxesObject\&.YLim, and AxesObject\&.ZLim\&.
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.childValidated(), AxesObject\&.doZoom(), AxesObject\&.propertyChanged(), AxesObject\&.removeChild(), AxesObject\&.reset(), AxesObject\&.setInternalPosition(), AxesObject\&.unZoom(), and AxesObject\&.validate()\&.
.PP
.nf
        {
                double dx = XLim\&.elementAt(1)-XLim\&.elementAt(0);
                double dy = YLim\&.elementAt(1)-YLim\&.elementAt(0);
                double dz = ZLim\&.elementAt(1)-ZLim\&.elementAt(0);
                
                if (DataAspectRatioMode\&.is('auto'))
                {
                        double dmin = Math\&.min(Math\&.min(dx, dy), dz);
                        autoSet(DataAspectRatio, new double[] {dx/dmin, dy/dmin, dz/dmin});
                }
                if (PlotBoxAspectRatioMode\&.is('auto'))
                {
                        if (DataAspectRatioMode\&.is('auto'))
                                autoSet(PlotBoxAspectRatio, new double[] {1,1,1});
                        else
                        {
                                double[] daspect = DataAspectRatio\&.getArray();
                                autoSet(PlotBoxAspectRatio, new double[] {
                                        dx/daspect[0],
                                        dy/daspect[1],
                                        dz/daspect[2]});
                        }
                }
                // TODO: if plotboxaspectratiomode is 'manual', limits
                // and/or dataaspectratio might be adapted
        }
.fi
.SS "void \fBautoAxis\fP (\fBVectorProperty\fPLim, booleanautoLim, \fBVectorProperty\fPTick, booleanautoTick, \fBRadioProperty\fPScale, booleanisZ)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.autoSet(), VectorProperty\&.getArray(), AxesObject\&.getChildrenLimits(), Property\&.getName(), AxesObject\&.getTickInterval(), and RadioProperty\&.is()\&.
.PP
Referenced by AxesObject\&.autoScaleX(), AxesObject\&.autoScaleY(), and AxesObject\&.autoScaleZ()\&.
.PP
.nf
        {
                double[] lim = (autoLim ? getChildrenLimits(Lim\&.getName(), Scale\&.is('log'), isZ) : Lim\&.getArray());

                if (Scale\&.is('linear'))
                {
                        double tickVal = getTickInterval(lim, 10);

                        if (autoLim)
                        {
                                lim[0] = Math\&.floor(lim[0]/tickVal) * tickVal;
                                lim[1] = Math\&.ceil(lim[1]/tickVal) * tickVal;
                                autoSet(Lim, lim);
                        }

                        if (autoTick)
                        {
                                double vmin = Math\&.ceil(lim[0]/tickVal) * tickVal;
                                double vmax = Math\&.floor(lim[1]/tickVal) * tickVal;
                                int nv = (int)Math\&.round((vmax-vmin)/tickVal+1);
                                double[] tickV = new double[nv];

                                for (int i=0; i<nv; i++)
                                        tickV[i] = vmin + i * tickVal;
                                autoSet(Tick, tickV);
                        }
                }
                else
                {
                        if (autoLim)
                        {
                                lim[0] = Math\&.pow(10, Math\&.floor(Math\&.log10(lim[0])));
                                lim[1] = Math\&.pow(10, Math\&.ceil(Math\&.log10(lim[1])));
                                autoSet(Lim, lim);
                        }

                        if (autoTick)
                        {
                                int n1 = (int)Math\&.ceil(Math\&.log10(lim[0])),
                                    n2 = (int)Math\&.floor(Math\&.log10(lim[1]));
                                double[] tickV = new double[n2-n1+1];
                                for (int i=0; i<tickV\&.length; i++)
                                        tickV[i] = Math\&.pow(10, n1+i);
                                autoSet(Tick, tickV);
                        }
                }
        }
.fi
.SS "void \fBautoCamera\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.updateXFormMatrices()\&.
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.childValidated(), AxesObject\&.doZoom(), AxesObject\&.propertyChanged(), AxesObject\&.removeChild(), AxesObject\&.reset(), AxesObject\&.setInternalPosition(), AxesObject\&.unZoom(), AxesObject\&.updateActivePosition(), and AxesObject\&.validate()\&.
.PP
.nf
        {
                updateXFormMatrices();
        }
.fi
.SS "void \fBautoLegend\fP ()\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.Children, HandleObject\&.HandleObject(), HandleObject\&.isLegendable(), BooleanProperty\&.isSet(), HandleObjectListProperty\&.iterator(), AxesObject\&.Key, and AxesObject\&.makeLegend()\&.
.PP
Referenced by AxesObject\&.childValidated(), AxesObject\&.propertyChanged(), and AxesObject\&.removeChild()\&.
.PP
.nf
        {
                if (Key\&.isSet())
                {
                        java\&.util\&.List names = new LinkedList();

                        synchronized(Children)
                        {
                                Iterator it = Children\&.iterator();
                                while (it\&.hasNext())
                                {
                                        HandleObject o = (HandleObject)it\&.next();
                                        if (o\&.isLegendable())
                                        {
                                                if (o instanceof LineObject)
                                                        names\&.add(((LineObject)o)\&.KeyLabel\&.toString());
                                                else
                                                        names\&.add('');
                                        }
                                }
                        }

                        String[] nameArray = new String[names\&.size()];
                        names\&.toArray(nameArray);
                        makeLegend(nameArray);
                }
        }
.fi
.SS "void \fBautoMinorTickX\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.computeMinorTicks(), AxesObject\&.x_minorTicks, AxesObject\&.XLim, AxesObject\&.XScale, and AxesObject\&.XTick\&.
.PP
Referenced by AxesObject\&.autoScaleX(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                x_minorTicks = computeMinorTicks(XLim, XTick, XScale);
        }
.fi
.SS "void \fBautoMinorTickY\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.computeMinorTicks(), AxesObject\&.y_minorTicks, AxesObject\&.YLim, AxesObject\&.YScale, and AxesObject\&.YTick\&.
.PP
Referenced by AxesObject\&.autoScaleY(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                y_minorTicks = computeMinorTicks(YLim, YTick, YScale);
        }
.fi
.SS "void \fBautoMinorTickZ\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.computeMinorTicks(), AxesObject\&.z_minorTicks, AxesObject\&.ZLim, AxesObject\&.ZScale, and AxesObject\&.ZTick\&.
.PP
Referenced by AxesObject\&.autoScaleZ(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                z_minorTicks = computeMinorTicks(ZLim, ZTick, ZScale);
        }
.fi
.SS "void \fBautoScale\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoScaleX(), AxesObject\&.autoScaleY(), and AxesObject\&.autoScaleZ()\&.
.PP
Referenced by AxesObject\&.childValidated(), AxesObject\&.propertyChanged(), and AxesObject\&.removeChild()\&.
.PP
.nf
        {
                autoScaleX();
                autoScaleY();
                autoScaleZ();
        }
.fi
.SS "void \fBautoScaleA\fP ()\fC [inline, protected, inherited]\fP"
.PP
Referenced by AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
        }
.fi
.SS "void \fBautoScaleC\fP ()\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.autoSet(), HandleObject\&.Children, GraphicObject\&.CLim, AxesObject\&.CLim, GraphicObject\&.CLimInclude, AxesObject\&.CLimMode, HandleObjectListProperty\&.elementAt(), HandleObject\&.get(), VectorProperty\&.getArray(), RadioProperty\&.is(), BooleanProperty\&.isSet(), and HandleObjectListProperty\&.size()\&.
.PP
Referenced by AxesObject\&.childValidated(), AxesObject\&.propertyChanged(), and AxesObject\&.removeChild()\&.
.PP
.nf
        {
                if (CLimMode\&.is('auto') && Children\&.size() > 0)
                {
                        double[] clim = { Double\&.POSITIVE_INFINITY, Double\&.NEGATIVE_INFINITY };

                        for (int i=0; i<Children\&.size(); i++)
                        {
                                GraphicObject child = (GraphicObject)Children\&.elementAt(i);
                                String mapping;

                                try     { mapping = (String)child\&.get('CDataMapping'); }
                                catch (PropertyException e) { mapping = ''; }

                                if (child\&.CLimInclude\&.isSet() && mapping\&.equals('scaled'))
                                {
                                        double[] _clim = child\&.CLim\&.getArray();
                                        clim[0] = Math\&.min(clim[0], _clim[0]);
                                        clim[1] = Math\&.max(clim[1], _clim[1]);
                                }
                        }

                        if (clim[0] > clim[1])
                        {
                                clim[0] = 0\&.0;
                                clim[1] = 1\&.0;
                        }

                        autoSet(CLim, clim);
                }
        }
.fi
.SS "void \fBautoScaleX\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoAxis(), AxesObject\&.autoMinorTickX(), AxesObject\&.autoTickLabelX(), RadioProperty\&.is(), AxesObject\&.XLim, AxesObject\&.XLimMode, AxesObject\&.XScale, AxesObject\&.XTick, and AxesObject\&.XTickMode\&.
.PP
Referenced by AxesObject\&.autoScale(), AxesObject\&.autoTickX(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                /*
                if (XLimMode\&.is('auto') && Children\&.size() > 0)
                {
                        double[] xlim = computeAutoScale('XLim', XScale, false);
                        autoSet(XLim, xlim);
                        autoTickX();
                }
                */

                if (XLimMode\&.is('auto') || XTickMode\&.is('auto'))
                {
                        autoAxis(XLim, XLimMode\&.is('auto'), XTick, XTickMode\&.is('auto'), XScale, false);
                        autoMinorTickX();
                        autoTickLabelX();
                }
        }
.fi
.SS "void \fBautoScaleY\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoAxis(), AxesObject\&.autoMinorTickY(), AxesObject\&.autoTickLabelY(), RadioProperty\&.is(), AxesObject\&.YLim, AxesObject\&.YLimMode, AxesObject\&.YScale, AxesObject\&.YTick, and AxesObject\&.YTickMode\&.
.PP
Referenced by AxesObject\&.autoScale(), AxesObject\&.autoTickY(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                /*
                if (YLimMode\&.is('auto') && Children\&.size() > 0)
                {
                        double[] ylim = computeAutoScale('YLim', YScale, false);
                        autoSet(YLim, ylim);
                        autoTickY();
                }
                */

                if (YLimMode\&.is('auto') || YTickMode\&.is('auto'))
                {
                        autoAxis(YLim, YLimMode\&.is('auto'), YTick, YTickMode\&.is('auto'), YScale, false);
                        autoMinorTickY();
                        autoTickLabelY();
                }
        }
.fi
.SS "void \fBautoScaleZ\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoAxis(), AxesObject\&.autoMinorTickZ(), AxesObject\&.autoTickLabelZ(), RadioProperty\&.is(), AxesObject\&.ZLim, AxesObject\&.ZLimMode, AxesObject\&.ZScale, AxesObject\&.ZTick, and AxesObject\&.ZTickMode\&.
.PP
Referenced by AxesObject\&.autoScale(), AxesObject\&.autoTickZ(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                /*
                if (ZLimMode\&.is('auto') && Children\&.size() > 0)
                {
                        double[] zlim = computeAutoScale('ZLim', ZScale, true);
                        autoSet(ZLim, zlim);
                        autoTickZ();
                }
                */

                if (ZLimMode\&.is('auto') || ZTickMode\&.is('auto'))
                {
                        autoAxis(ZLim, ZLimMode\&.is('auto'), ZTick, ZTickMode\&.is('auto'), ZScale, true);
                        autoMinorTickZ();
                        autoTickLabelZ();
                }
        }
.fi
.SS "void \fBautoSet\fP (\fBProperty\fPp, Objectvalue)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.autoMode, and Property\&.set()\&.
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.autoAxis(), AxesObject\&.autoScaleC(), AxesObject\&.computeAutoTickLabels(), FigureObject\&.propertyChanged(), AxesObject\&.propertyChanged(), AxesObject\&.setInternalPosition(), PatchObject\&.updateCData(), PatchObject\&.updateFVCData(), PatchObject\&.updateFVData(), AxesObject\&.updateOuterPosition(), FigureObject\&.updatePosition(), AxesObject\&.updatePosition(), AxesObject\&.updateXFormMatrices(), and PatchObject\&.updateXYZData()\&.
.PP
.nf
        {
                autoMode++;
                p\&.set(value, true);
                autoMode--;
        }
.fi
.SS "void \fBautoTick\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoTickX(), AxesObject\&.autoTickY(), and AxesObject\&.autoTickZ()\&.
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.doZoom(), AxesObject\&.reset(), AxesObject\&.setInternalPosition(), AxesObject\&.unZoom(), and AxesObject\&.validate()\&.
.PP
.nf
        {
                autoTickX();
                autoTickY();
                autoTickZ();
        }
.fi
.SS "void \fBautoTickLabel\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoTickLabelX(), AxesObject\&.autoTickLabelY(), and AxesObject\&.autoTickLabelZ()\&.
.PP
.nf
        {
                autoTickLabelX();
                autoTickLabelY();
                autoTickLabelZ();
        }
.fi
.SS "void \fBautoTickLabelX\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.computeAutoTickLabels(), RadioProperty\&.is(), AxesObject\&.x_logTickLabels, AxesObject\&.XScale, AxesObject\&.XTick, AxesObject\&.XTickLabel, and AxesObject\&.XTickLabelMode\&.
.PP
Referenced by AxesObject\&.autoScaleX(), AxesObject\&.autoTickLabel(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                if (XTickLabelMode\&.is('auto'))
                        x_logTickLabels = computeAutoTickLabels(XTick, XScale, XTickLabel);
        }
.fi
.SS "void \fBautoTickLabelY\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.computeAutoTickLabels(), RadioProperty\&.is(), AxesObject\&.y_logTickLabels, AxesObject\&.YScale, AxesObject\&.YTick, AxesObject\&.YTickLabel, and AxesObject\&.YTickLabelMode\&.
.PP
Referenced by AxesObject\&.autoScaleY(), AxesObject\&.autoTickLabel(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                if (YTickLabelMode\&.is('auto'))
                        y_logTickLabels = computeAutoTickLabels(YTick, YScale, YTickLabel);
        }
.fi
.SS "void \fBautoTickLabelZ\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.computeAutoTickLabels(), RadioProperty\&.is(), AxesObject\&.z_logTickLabels, AxesObject\&.ZScale, AxesObject\&.ZTick, AxesObject\&.ZTickLabel, and AxesObject\&.ZTickLabelMode\&.
.PP
Referenced by AxesObject\&.autoScaleZ(), AxesObject\&.autoTickLabel(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                if (ZTickLabelMode\&.is('auto'))
                        z_logTickLabels = computeAutoTickLabels(ZTick, ZScale, ZTickLabel);
        }
.fi
.SS "void \fBautoTickX\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoScaleX()\&.
.PP
Referenced by AxesObject\&.autoTick(), ColorbarObject\&.buildColorbar(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                /*
                if (XTickMode\&.is('auto'))
                {
                        double[] ticks = computeAutoTicks(XLim, XScale);
                        autoSet(XTick, ticks);
                }
                autoMinorTickX();
                autoTickLabelX();
                */
                autoScaleX();
        }
.fi
.SS "void \fBautoTickY\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoScaleY()\&.
.PP
Referenced by AxesObject\&.autoTick(), ColorbarObject\&.buildColorbar(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                /*
                if (YTickMode\&.is('auto'))
                {
                        double[] ticks = computeAutoTicks(YLim, YScale);
                        autoSet(YTick, ticks);
                }
                autoMinorTickY();
                autoTickLabelY();
                */
                autoScaleY();
        }
.fi
.SS "void \fBautoTickZ\fP ()\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoScaleZ()\&.
.PP
Referenced by AxesObject\&.autoTick(), and AxesObject\&.propertyChanged()\&.
.PP
.nf
        {
                /*
                if (ZTickMode\&.is('auto'))
                {
                        double[] ticks = computeAutoTicks(ZLim, ZScale);
                        autoSet(ZTick, ticks);
                }
                autoMinorTickZ();
                autoTickLabelZ();
                */
                autoScaleZ();
        }
.fi
.SS "void \fBbuildLegend\fP (\fBAxesObject\fPaxes, \fBString\fP[]names)\fC [inline]\fP"
.PP
References LegendObject\&.axes, HandleObject\&.Children, LegendObject\&.doClear(), LegendObject\&.doLayout(), LegendObject\&.doLocate(), HandleObject\&.HandleObject(), HandleObject\&.isLegendable(), LegendObject\&.items, HandleObjectListProperty\&.iterator(), LegendObject\&.makeItemFromLine(), Property\&.reset(), and LegendObject\&.String\&.
.PP
Referenced by LegendObject\&.LegendObject(), and AxesObject\&.makeLegend()\&.
.PP
.nf
        {
                doClear();
                this\&.axes = axes;

                LinkedList tmp = new LinkedList();
                Iterator it = axes\&.Children\&.iterator();
                int index = 0;

                while (it\&.hasNext())
                {
                        HandleObject obj = (HandleObject)it\&.next();

                        if (!obj\&.isLegendable())
                                continue;

                        if (index < names\&.length)
                                tmp\&.add(makeItemFromLine(obj, names[index++]));
                        else
                        {
                                index++;
                                tmp\&.add(makeItemFromLine(obj, 'data'+index));
                        }
                }

                if (index < names\&.length)
                        System\&.out\&.println('WARNING: ignoring extra legend entries');

                items = (LegendItem[])tmp\&.toArray(new LegendItem[tmp\&.size()]);
                doLayout();
                doLocate();
                
                String[] used_names = new String[items\&.length];
                for (int i=0; i<items\&.length; i++)
                        used_names[i] = items[i]\&.name;
                String\&.reset(used_names);
        }
.fi
.SS "void \fBcancelOperation\fP (intop)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.boundingBox, AxesObject\&.drawZoomBox(), AxesContainer\&.OP_ROTATE, AxesContainer\&.OP_ZOOM, AxesObject\&.xPrev, AxesObject\&.yPrev, and AxesObject\&.zoomBox\&.
.PP
Referenced by AxesContainer\&.cancelMouseOperation()\&.
.PP
.nf
        {
                switch (op)
                {
                        case FigureObject\&.OP_ZOOM:
                                if (zoomBox)
                                {
                                        drawZoomBox(xPrev, yPrev);
                                        zoomBox = false;
                                }
                                break;
                        case FigureObject\&.OP_ROTATE:
                                boundingBox = null;
                                break;
                }
        }
.fi
.SS "void \fBchildValidated\fP (\fBHandleObject\fPchild)\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBHandleObject\fP\&.
.PP
References AxesObject\&.autoAspectRatio(), AxesObject\&.autoCamera(), AxesObject\&.autoLegend(), AxesObject\&.autoScale(), AxesObject\&.autoScaleC(), GraphicObject\&.CLim, PropertySet\&.getProperty(), HandleObject\&.isValid(), HandleObject\&.listen(), HandleObject\&.Visible, GraphicObject\&.XLim, GraphicObject\&.YLim, and GraphicObject\&.ZLim\&.
.PP
.nf
        {
                if (!isValid())
                        return;

                autoScale();
                autoScaleC();
                autoAspectRatio();
                autoCamera();
                autoLegend();

                if (child instanceof GraphicObject)
                {
                        GraphicObject go = (GraphicObject)child;
                        listen(go\&.XLim);
                        listen(go\&.YLim);
                        listen(go\&.ZLim);
                        listen(go\&.CLim);
                        listen(go\&.Visible);

                        Property p = go\&.getProperty('KeyLabel');
                        if (p != null)
                                listen(p);
                }
        }
.fi
.SS "boolean \fBcomputeAutoTickLabels\fP (\fBVectorProperty\fPTick, \fBRadioProperty\fPScale, \fBStringArrayProperty\fPTickLabel)\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.allPowerOf10(), HandleObject\&.autoSet(), VectorProperty\&.getArray(), RadioProperty\&.is(), and AxesObject\&.isInteger()\&.
.PP
Referenced by AxesObject\&.autoTickLabelX(), AxesObject\&.autoTickLabelY(), and AxesObject\&.autoTickLabelZ()\&.
.PP
.nf
        {
                boolean retval = false;
                double[] ticks = Tick\&.getArray();
                String[] labels = new String[ticks\&.length];
                if (Scale\&.is('linear') || !allPowerOf10(ticks))
                        for (int i=0; i<ticks\&.length; i++)
                        {
                                if (isInteger(ticks[i]))
                                        labels[i] = Long\&.toString(Math\&.round(ticks[i]));
                                else
                                {
                                        double val = ((double)Math\&.round(ticks[i]*100))/100;
                                        labels[i] = Double\&.toString(val);
                                }
                        }
                else
                {
                        for (int i=0; i<ticks\&.length; i++)
                        {
                                double v = Math\&.log10(ticks[i]);
                                if (Math\&.floor(v) == v)
                                        labels[i] = Integer\&.toString((int)v);
                                else
                                        labels[i] = Double\&.toString(v);
                        }
                        retval = true;
                }
                autoSet(TickLabel, labels);
                return retval;
        }
.fi
.SS "double [] \fBcomputeMinorTicks\fP (\fBVectorProperty\fPLim, \fBVectorProperty\fPTick, \fBRadioProperty\fPScale)\fC [inline, protected, inherited]\fP"
.PP
References VectorProperty\&.getArray(), and RadioProperty\&.is()\&.
.PP
Referenced by AxesObject\&.autoMinorTickX(), AxesObject\&.autoMinorTickY(), and AxesObject\&.autoMinorTickZ()\&.
.PP
.nf
        {
                double[] mticks;

                if (Scale\&.is('linear'))
                        mticks = new double[0];
                else
                {
                        ArrayList tl = new ArrayList();
                        double[] lim = Lim\&.getArray(), ticks = Tick\&.getArray();
                        double v1 = lim[0], v2;
                        for (int i=0; i<=ticks\&.length; i++)
                        {
                                v2 = (i < ticks\&.length ? ticks[i] : lim[1]);
                                if (v1 < v2)
                                {
                                        double b = Math\&.pow(10, Math\&.floor(Math\&.log10(v1)));
                                        if (v2 >= b*10)
                                        {
                                                double v = b*(Math\&.floor(v1/b)+1);
                                                while (v < v2)
                                                {
                                                        tl\&.add(new Double(v));
                                                        v += b;
                                                        if (v >= 10*b)
                                                                b *= 10;
                                                }
                                        }
                                }
                                v1 = v2;
                        }
                        mticks = new double[tl\&.size()];
                        for (int i=0; i<mticks\&.length; i++)
                                mticks[i] = ((Double)tl\&.get(i))\&.doubleValue();
                }
                return mticks;
        }
.fi
.SS "Matrix \fBconvertCData\fP (Matrixcdata, Stringmapping)\fC [inline, package, inherited]\fP"
.PP
References ArrayProperty\&.asDoubleMatrix(), AxesObject\&.CLim, FigureObject\&.Colormap, VectorProperty\&.getArray(), and AxesObject\&.getFigure()\&.
.PP
Referenced by SurfaceObject\&.getCData(), PatchObject\&.getCData(), and GLRenderer\&.makeTextureFromCData()\&.
.PP
.nf
        {
                double[] clim = CLim\&.getArray();
                double[][] cmap = getFigure()\&.Colormap\&.asDoubleMatrix();
                boolean isScaled = mapping\&.equals('scaled');
                Matrix c;

                int ndims = cdata\&.getNDims();
                int[] dims = new int[ndims+1];
                for (int i=0; i<ndims; i++)
                        dims[i] = cdata\&.getDim(i);
                dims[ndims] = 3;

                if (cdata\&.getClassName()\&.equals('double'))
                {
                        double[] buf = cdata\&.toDouble();
                        int len = buf\&.length;
                        double[] cbuf = new double[len*3];

                        for (int i=0; i<len; i++)
                        {
                                int index = (isScaled ?
                                                (int)Math\&.round((cmap\&.length-1)*(buf[i]-clim[0])/(clim[1]-clim[0])) :
                                                (int)Math\&.round(buf[i]-1));
                                if (index < 0) index = 0;
                                else if (index >= cmap\&.length) index = cmap\&.length-1;
                                cbuf[i+0*len] = cmap[index][0];
                                cbuf[i+1*len] = cmap[index][1];
                                cbuf[i+2*len] = cmap[index][2];
                        }

                        c = new Matrix(cbuf, dims);
                }
                else
                        c = new Matrix();

                return c;
        }
.fi
.SS "double [][] \fBconvertCData\fP (double[]cdata, Stringmapping)\fC [inline, package, inherited]\fP"
.PP
References ArrayProperty\&.asDoubleMatrix(), AxesObject\&.CLim, FigureObject\&.Colormap, VectorProperty\&.getArray(), and AxesObject\&.getFigure()\&.
.PP
.nf
        {
                double[] clim = CLim\&.getArray();
                double[][] cmap = getFigure()\&.Colormap\&.asDoubleMatrix();
                double[][] c = new double[cdata\&.length][];

                if (mapping\&.equals('scaled'))
                        for (int i=0; i<cdata\&.length; i++)
                        {
                                int index = (int)Math\&.round((cmap\&.length-1)*(cdata[i]-clim[0])/(clim[1]-clim[0]));
                                if (index < 0) index = 0;
                                else if (index >= cmap\&.length) index = cmap\&.length-1;
                                c[i] = cmap[index];
                        }
                else
                        for (int i=0; i<cdata\&.length; i++)
                        {
                                int index = (int)Math\&.round(cdata[i]);
                                if (index < 0) index = 0;
                                else if (index >= cmap\&.length) index = cmap\&.length-1;
                                c[i] = cmap[index];
                        }

                return c;
        }
.fi
.SS "double [][][] \fBconvertCData\fP (doublecdata[][], Stringmapping)\fC [inline, package, inherited]\fP"
.PP
References ArrayProperty\&.asDoubleMatrix(), AxesObject\&.CLim, FigureObject\&.Colormap, VectorProperty\&.getArray(), and AxesObject\&.getFigure()\&.
.PP
.nf
        {
                double[] clim = CLim\&.getArray();
                double[][] cmap = getFigure()\&.Colormap\&.asDoubleMatrix();
                double[][][] c = new double[cdata\&.length][cdata[0]\&.length][];
                boolean scaled = mapping\&.equals('scaled');

                if (mapping\&.equals('scaled'))
                        for (int i=0; i<cdata\&.length; i++)
                                for (int j=0; j<cdata[i]\&.length; j++)
                                {
                                        int index = (int)Math\&.round((cmap\&.length-1)*(cdata[i][j]-clim[0])/(clim[1]-clim[0]));
                                        if (index < 0) index = 0;
                                        else if (index >= cmap\&.length) index = cmap\&.length-1;
                                        //System\&.arraycopy(cmap[index], 0, c[i][j], 0, 3);
                                        c[i][j] = cmap[index];
                                }
                else
                        for (int i=0; i<cdata\&.length; i++)
                                for (int j=0; j<cdata[i]\&.length; j++)
                                {
                                        int index = (int)Math\&.round(cdata[i][j]);
                                        if (index < 0) index = 0;
                                        else if (index >= cmap\&.length) index = cmap\&.length-1;
                                        c[i][j] = cmap[index];
                                }
                return c;
        }
.fi
.SS "double [][] \fBconvertCDataToIndex\fP (doublecdata[][])\fC [inline, package, inherited]\fP"
.PP
References ArrayProperty\&.asDoubleMatrix(), AxesObject\&.CLim, FigureObject\&.Colormap, VectorProperty\&.getArray(), and AxesObject\&.getFigure()\&.
.PP
.nf
        {
                double[] clim = CLim\&.getArray();
                double[][] cmap = getFigure()\&.Colormap\&.asDoubleMatrix();
                double[][]c = new double[cdata\&.length][cdata[0]\&.length];

                for (int i=0; i<cdata\&.length; i++)
                        for (int j=0; j<cdata[i]\&.length; j++)
                                c[i][j] = (cdata[i][j]-clim[0])/(clim[1]-clim[0]);

                return c;
        }
.fi
.SS "double [] \fBconvertUnits\fP (double[]pos, Stringunits)\fC [inline, package, inherited]\fP"
.PP
Referenced by J2DRenderer\&.draw(), GLRenderer\&.draw(), TextObject\&.drawAsImage(), TextObject\&.propertyChanged(), and TextObject\&.updateMinMax()\&.
.PP
.nf
        {
                return convertUnits(pos, units, 'data');
        }
.fi
.SS "double [] \fBconvertUnits\fP (double[]pos, Stringunits, StringtoUnits)\fC [inline, package, inherited]\fP"
.PP
References AxesObject\&.getBoundingBox(), AxesObject\&.getCanvas(), RenderCanvas\&.getHeight(), Utils\&.getScreenResolution(), AxesObject\&.transform(), AxesObject\&.unTransform(), AxesObject\&.x_zmax, and AxesObject\&.x_zmin\&.
.PP
.nf
        {
                double[] p;
                double dz = (x_zmax-x_zmin), z1 = x_zmin;

                if (units\&.equalsIgnoreCase('data'))
                        p = (double[])pos\&.clone();
                else
                {
                        Rectangle bb = getBoundingBox();
                        double hc = getCanvas()\&.getHeight();
                        double dpi = Utils\&.getScreenResolution();

                        if (units\&.equalsIgnoreCase('pixels'))
                                p = (double[])pos\&.clone();
                        else if (units\&.equalsIgnoreCase('normalized'))
                                p = new double[] {pos[0]*bb\&.width, pos[1]*bb\&.height, dz*pos[2]};
                        else if (units\&.equalsIgnoreCase('inches'))
                                p = new double[] {pos[0]*dpi, pos[1]*dpi, pos[2]*dpi};
                        else if (units\&.equalsIgnoreCase('centimeters'))
                                p = new double[] {pos[0]*dpi/2\&.54, pos[1]*dpi/2\&.54, pos[2]*dpi/2\&.54};
                        else if (units\&.equalsIgnoreCase('points'))
                                p = new double[] {pos[0]*dpi/72\&.0, pos[1]*dpi/72\&.0, pos[2]*dpi/72\&.0};
                        else
                                p = new double[] {0, 0, 0};
                        unTransform(bb\&.x+p[0], hc-(bb\&.y+p[1]), z1+p[2], p, 0);
                }

                if (!toUnits\&.equalsIgnoreCase('data'))
                {
                        Rectangle bb = getBoundingBox();
                        double hc = getCanvas()\&.getHeight();
                        double dpi = Utils\&.getScreenResolution();

                        transform(p[0], p[1], p[2], p, 0);
                        p[0] -= bb\&.x;
                        p[1] = hc-bb\&.y-p[1];
                        p[2] -= z1;
                        
                        if (toUnits\&.equalsIgnoreCase('normalized'))
                        {
                                p[0] /= bb\&.width;
                                p[1] /= bb\&.height;
                                p[2] /= dz;
                        }
                        else if (toUnits\&.equalsIgnoreCase('inches'))
                        {
                                p[0] /= dpi;
                                p[1] /= dpi;
                                p[2] /= dpi;
                        }
                        else if (toUnits\&.equalsIgnoreCase('centimeters'))
                        {
                                p[0] /= dpi/2\&.54;
                                p[1] /= dpi/2\&.54;
                                p[2] /= dpi/2\&.54;
                        }
                        else if (toUnits\&.equalsIgnoreCase('points'))
                        {
                                p[0] /= dpi/72\&.0;
                                p[1] /= dpi/72\&.0;
                                p[2] /= dpi/72\&.0;
                        }
                }

                return p;
        }
.fi
.SS "void \fBdelete\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
Reimplemented in \fBFigureObject\fP, \fBUIPanelObject\fP, \fBUIControlObject\fP, \fBBarseriesObject\fP, and \fBColorbarObject\fP\&.
.PP
References HandleObject\&.BeingDeleted, HandleObject\&.cachedData, HandleEventSourceHelper\&.delete(), HandleObject\&.deleteChildren(), HandleObject\&.DeleteFcn, HandleObjectListProperty\&.elementAt(), HandleObject\&.eventSource, HandleObject\&.eventSourceSet, CallbackProperty\&.execute(), HandleEventSourceHelper\&.fireEvent(), HandleObject\&.getHandle(), HandleObject\&.Parent, HandleObject\&.removeChild(), HandleObject\&.removeHandleEventSink(), HandleObject\&.removeHandleObject(), and Property\&.reset()\&.
.PP
Referenced by HandleObject\&.deleteChildren(), AxesObject\&.deleteChildren(), ColorbarObject\&.doClear(), LegendObject\&.doClear(), and AxesObject\&.makeLegend()\&.
.PP
.nf
        {
                BeingDeleted\&.reset('on');
                try { eventSource\&.fireEvent('ObjectDeleted'); }
                catch (PropertyException ex) {}
                DeleteFcn\&.execute(new Object[] {
                        new Double(getHandle()),
                        null});
                removeHandleObject(getHandle());

                super\&.delete();

                Iterator it = eventSourceSet\&.iterator();
                while (it\&.hasNext())
                        ((HandleEventSource)it\&.next())\&.removeHandleEventSink(this);
                eventSource\&.delete();

                deleteChildren();
                if (cachedData != null)
                        cachedData\&.dispose();
                Parent\&.elementAt(0)\&.removeChild(this);
        }
.fi
.SS "void \fBdeleteChildren\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBHandleObject\fP\&.
.PP
References AxesObject\&.colorbar, ColorbarObject\&.delete(), HandleObject\&.delete(), and AxesObject\&.legend\&.
.PP
Referenced by AxesObject\&.reset()\&.
.PP
.nf
        {
                super\&.deleteChildren();
                if (legend != null)
                {
                        legend\&.delete();
                        legend = null;
                }
                if (colorbar != null)
                {
                        colorbar\&.delete();
                        colorbar = null;
                }
        }
.fi
.SS "void \fBdoButtonDownFcn\fP (MouseEvente)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.ButtonDownFcn, CallbackProperty\&.execute(), HandleObject\&.getAncestor(), HandleObject\&.getHandle(), and CallbackProperty\&.unwind()\&.
.PP
Referenced by UIControlAdapter\&.mousePressed(), and AxesContainer\&.mousePressed()\&.
.PP
.nf
        {
                String selType = 'normal';

                switch (e\&.getButton())
                {
                        case MouseEvent\&.BUTTON2:
                                selType = 'extend';
                                break;
                        case MouseEvent\&.BUTTON3:
                                selType = 'alt';
                                break;
                }

                switch (e\&.getModifiers() & (MouseEvent\&.SHIFT_MASK|MouseEvent\&.CTRL_MASK))
                {
                        case MouseEvent\&.CTRL_MASK:
                                selType = 'alt';
                                break;
                        case MouseEvent\&.SHIFT_MASK:
                                selType = 'extend';
                                break;
                        case 0:
                                if (e\&.getClickCount() == 2)
                                        selType = 'open';
                                break;
                }

                ButtonDownFcn\&.unwind(((FigureObject)getAncestor('figure'))\&.SelectionType, selType);
                ButtonDownFcn\&.execute(new Object[] {
                        new Double(getHandle()),
                        null});
        }
.fi
.SS "void \fBdoClear\fP ()\fC [inline, private]\fP"
.PP
References HandleObject\&.Children, HandleObject\&.delete(), HandleObjectListProperty\&.elementAt(), and HandleObjectListProperty\&.size()\&.
.PP
Referenced by LegendObject\&.buildLegend()\&.
.PP
.nf
        {
                while (Children\&.size() > 0)
                        Children\&.elementAt(0)\&.delete();
        }
.fi
.SS "void \fBdoLayout\fP ()\fC [inline, private]\fP"
.PP
References AxesObject\&.getCanvas(), TextObject\&.getExtent(), RenderCanvas\&.getFont(), RenderCanvas\&.getFontMetrics(), RenderCanvas\&.getHeight(), RenderCanvas\&.getWidth(), RadioProperty\&.is(), LegendObject\&.items, LegendObject\&.LegendItem\&.line, LegendObject\&.LegendItem\&.marker, LegendObject\&.Orientation, TextObject\&.Position, AxesObject\&.Position, Property\&.reset(), Property\&.set(), LegendObject\&.size(), LegendObject\&.LegendItem\&.text, LineObject\&.XData, plt\&.y, and LineObject\&.YData\&.
.PP
Referenced by LegendObject\&.buildLegend(), and LegendObject\&.propertyChanged()\&.
.PP
.nf
        {
                RenderCanvas canvas = getCanvas();
                FontMetrics fm = canvas\&.getFontMetrics(canvas\&.getFont());
                int lineWidth = 30, margin = 5;
                int maxWidth = 0, maxHeight = fm\&.getHeight()+margin;

                int totalWidth = 0, totalHeight = 0;

                if (Orientation\&.is('vertical'))
                {
                        for (int i=0; i<items\&.length; i++)
                        {
                                Rectangle r = items[i]\&.text\&.getExtent();
                                maxWidth = Math\&.max(r\&.width, maxWidth);
                                maxHeight = Math\&.max(r\&.height+margin, maxHeight);
                        }

                        totalWidth = (maxWidth+3*margin+lineWidth);
                        totalHeight = items\&.length*maxHeight;

                        double xt = 1-((double)(maxWidth+margin))/totalWidth;
                        double x1 = ((double)margin)/totalWidth, x2 = ((double)(margin+lineWidth))/totalWidth;

                        for (int i=0; i<items\&.length; i++)
                        {
                                double ypos = 1-(i+0\&.5)/items\&.length;
                                if (items[i]\&.patch != null)
                                {
                                }
                                else
                                {
                                        items[i]\&.text\&.Position\&.reset(new double[] {xt, ypos, 0});
                                        items[i]\&.line\&.XData\&.reset(new double[] {x1, x2});
                                        items[i]\&.line\&.YData\&.reset(new double[] {ypos, ypos});
                                        items[i]\&.marker\&.XData\&.reset(new double[] {(x1+x2)/2});
                                        items[i]\&.marker\&.YData\&.reset(new double[] {ypos});
                                }
                        }
                }
                else
                {
                        int[] w = new int[items\&.length];

                        for (int i=0; i<items\&.length; i++)
                        {
                                Rectangle r = items[i]\&.text\&.getExtent();
                                w[i] = totalWidth;
                                totalWidth += (r\&.width+lineWidth+3*margin);
                                totalHeight = Math\&.max(r\&.height+margin, totalHeight);
                        }

                        double y = 0\&.5;
                        double x1 = ((double)margin)/totalWidth, x2 = ((double)(margin+lineWidth))/totalWidth;
                        double xt = ((double)(2*margin+lineWidth))/totalWidth;
                        
                        for (int i=0; i<items\&.length; i++)
                        {
                                double xpos = ((double)w[i])/totalWidth;
                                if (items[i]\&.patch != null)
                                {
                                }
                                else
                                {
                                        items[i]\&.text\&.Position\&.reset(new double[] {xpos+xt, y, 0});
                                        items[i]\&.line\&.XData\&.reset(new double[] {xpos+x1, xpos+x2});
                                        items[i]\&.line\&.YData\&.reset(new double[] {y, y});
                                        items[i]\&.marker\&.XData\&.reset(new double[] {xpos+(x1+x2)/2});
                                        items[i]\&.marker\&.YData\&.reset(new double[] {y});
                                }
                        }
                }

                Position\&.set(new double[] {0, 0, ((double)totalWidth)/canvas\&.getWidth(), ((double)totalHeight)/canvas\&.getHeight()}, true);
                size = new Dimension(totalWidth, totalHeight);
        }
.fi
.SS "void \fBdoLocate\fP ()\fC [inline, private]\fP"
.PP
References AxesObject\&.ActivePositionProperty, HandleObject\&.autoMode, LegendObject\&.axes, Utils\&.convertPosition(), VectorProperty\&.getArray(), AxesObject\&.getCanvas(), RenderCanvas\&.getComponent(), RadioProperty\&.getValue(), RadioProperty\&.is(), LegendObject\&.Location, AxesObject\&.OuterPosition, AxesObject\&.Position, Property\&.set(), AxesObject\&.setInternalPosition(), LegendObject\&.String, and AxesObject\&.Units\&.
.PP
Referenced by LegendObject\&.buildLegend(), LegendObject\&.propertyChanged(), and LegendObject\&.updateActivePosition()\&.
.PP
.nf
        {
                if (Location\&.is('none'))
                        return;

                RenderCanvas canvas = getCanvas();
                double[] aPos = Utils\&.convertPosition(axes\&.Position\&.getArray(), axes\&.Units\&.getValue(), 'pixels', canvas\&.getComponent());
                double[] aOPos = Utils\&.convertPosition(axes\&.OuterPosition\&.getArray(), axes\&.Units\&.getValue(), 'pixels', canvas\&.getComponent());
                double[] pos = Utils\&.convertPosition(Position\&.getArray(), Units\&.getValue(), 'pixels', canvas\&.getComponent());
                boolean outerActive = axes\&.ActivePositionProperty\&.is('outerposition');
                int margin = 10;

                String loc = Location\&.getValue()\&.toLowerCase();
                int hPos = (loc\&.contains('west') ? 0 : loc\&.contains('east') ? 2 : 1);
                int vPos = (loc\&.contains('south') ? 0 : loc\&.contains('north') ? 2 : 1);
                boolean outside = loc\&.contains('outside');

                if (!outside)
                {
                        switch (vPos)
                        {
                                case 0: /* south */
                                        pos[1] = aPos[1]+margin;
                                        break;
                                case 1: /* middle */
                                        pos[1] = aPos[1]+(aPos[3]-pos[3])/2;
                                        break;
                                case 2: /* north */
                                        pos[1] = aPos[1]+aPos[3]-margin-pos[3];
                                        break;
                        }
                        switch (hPos)
                        {
                                case 0: /* west */
                                        pos[0] = aPos[0]+margin;
                                        break;
                                case 1: /* center */
                                        pos[0] = aPos[0]+(aPos[2]-pos[2])/2;
                                        break;
                                case 2: /* east */
                                        pos[0] = aPos[0]+aPos[2]-margin-pos[2];
                                        break;
                        }
                }
                else
                {
                        switch (hPos)
                        {
                                case 0: /* west */
                                        if (outerActive)
                                        {
                                                double offset = margin+pos[2];
                                                aPos[0] += offset;
                                                aPos[2] -= offset;
                                        }
                                        pos[0] = aPos[0]-margin-pos[2];
                                        break;
                                case 1: /* center */
                                        pos[0] = aPos[0]+(aPos[2]-pos[2])/2;
                                        break;
                                case 2: /* east */
                                        if (outerActive)
                                                aPos[2] -= (margin+pos[2]);
                                        pos[0] = aPos[0]+aPos[2]+margin;
                                        break;
                        }
                        switch (vPos)
                        {
                                case 0: /* south */
                                        if (hPos == 1)
                                        {
                                                if (outerActive)
                                                {
                                                        double offset = margin+pos[3];
                                                        aPos[1] += offset;
                                                        aPos[3] -= offset;
                                                }
                                                pos[1] = aPos[1]-margin-pos[3];
                                        }
                                        else
                                                pos[1] = aPos[1];
                                        break;
                                case 1: /* middle */
                                        pos[1] = aPos[1]+(aPos[3]-pos[3])/2;
                                        break;
                                case 2: /* north */
                                        if (hPos == 1)
                                        {
                                                if (outerActive)
                                                        aPos[3] -= (margin+pos[3]);
                                                pos[1] = aPos[1]+aPos[3]+margin;
                                        }
                                        else
                                                pos[1] = aPos[1]+aPos[3]-pos[3];
                                        break;
                        }
                }

                Position\&.set(Utils\&.convertPosition(pos, 'pixels', Units\&.getValue(), canvas\&.getComponent()), true);
                autoMode++;
                axes\&.setInternalPosition(Utils\&.convertPosition(aPos, 'pixels', axes\&.Units\&.getValue(), canvas\&.getComponent()));
                autoMode--;
        }
.fi
.SS "void \fBdraw\fP (\fBRenderer\fPr)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.alwaysDrawBox, HandleObject\&.autoMode, AxesObject\&.AXE_ANY_DIR, AxesObject\&.AXE_DEPTH_DIR, AxesObject\&.AXE_HORZ_DIR, AxesObject\&.AXE_VERT_DIR, AxesObject\&.AxesColor, AxesObject\&.Box, AxesObject\&.CameraPosition, AxesObject\&.CameraTarget, AxesObject\&.CameraUpVectorMode, HandleObject\&.Children, HandleObject\&.Clipping, DoubleProperty\&.doubleValue(), GraphicObject\&.draw(), Renderer\&.drawQuads(), Renderer\&.drawSegments(), Renderer\&.drawText(), AxesObject\&.drawZoomBox(), Renderer\&.end(), DoubleProperty\&.floatValue(), AxesObject\&.FontAngle, AxesObject\&.FontName, AxesObject\&.FontSize, AxesObject\&.FontUnits, AxesObject\&.FontWeight, StringArrayProperty\&.getArray(), VectorProperty\&.getArray(), AxesObject\&.getBoundingBox(), AxesObject\&.getCanvas(), ColorProperty\&.getColor(), Utils\&.getFont(), PropertySet\&.getProperty(), TextProperty\&.getText(), RadioProperty\&.getValue(), AxesObject\&.GridLineStyle, TextObject\&.HAlign, PropertySet\&.hasProperty(), RadioProperty\&.is(), ColorProperty\&.is(), TextProperty\&.isEmpty(), BooleanProperty\&.isSet(), HandleObjectListProperty\&.iterator(), AxesObject\&.Layer, AxesObject\&.LineWidth, AxesObject\&.MinorGridLineStyle, TextObject\&.Position, TextObject\&.PositionMode, Property\&.reset(), TextObject\&.Rotation, AxesObject\&.Scaler\&.scale(), Property\&.set(), Renderer\&.setCamera(), Renderer\&.setClipBox(), Renderer\&.setClipping(), Renderer\&.setColor(), Renderer\&.setFont(), Renderer\&.setLineStyle(), Renderer\&.setLineWidth(), Renderer\&.setXForm(), AxesObject\&.sx, AxesObject\&.sy, AxesObject\&.sz, AxesObject\&.TickDir, AxesObject\&.TickDirMode, AxesObject\&.Title, Matrix3D\&.transform(), AxesObject\&.unTransform(), TextObject\&.VAlign, HandleObject\&.Visible, AxesObject\&.x_logTickLabels, AxesObject\&.x_minorTicks, AxesObject\&.x_render, AxesObject\&.x_zmax, AxesObject\&.x_zmin, AxesObject\&.XAxisLocation, AxesObject\&.XColor, AxesObject\&.XDir, AxesObject\&.XGrid, AxesObject\&.XLabel, AxesObject\&.XLim, AxesObject\&.XMinorGrid, AxesObject\&.XMinorTick, AxesObject\&.xPrev, AxesObject\&.xstate, AxesObject\&.XTick, AxesObject\&.XTickLabel, AxesObject\&.xticklen, AxesObject\&.y_logTickLabels, AxesObject\&.y_minorTicks, AxesObject\&.YAxisLocation, AxesObject\&.YColor, AxesObject\&.YDir, AxesObject\&.YGrid, AxesObject\&.YLabel, AxesObject\&.YLim, AxesObject\&.YMinorGrid, AxesObject\&.YMinorTick, AxesObject\&.yPrev, AxesObject\&.ystate, AxesObject\&.YTick, AxesObject\&.YTickLabel, AxesObject\&.yticklen, AxesObject\&.z_logTickLabels, AxesObject\&.z_minorTicks, AxesObject\&.ZColor, AxesObject\&.ZDir, AxesObject\&.ZGrid, AxesObject\&.ZLabel, AxesObject\&.ZLim, AxesObject\&.ZMinorGrid, AxesObject\&.ZMinorTick, AxesObject\&.zoomBox, AxesObject\&.zstate, AxesObject\&.ZTick, AxesObject\&.ZTickLabel, and AxesObject\&.zticklen\&.
.PP
.nf
        {
                r\&.setXForm(this);
        
                double xmin = sx\&.scale(XLim\&.getArray()[0]), xmax = sx\&.scale(XLim\&.getArray()[1]);
                double ymin = sy\&.scale(YLim\&.getArray()[0]), ymax = sy\&.scale(YLim\&.getArray()[1]);
                double zmin = sz\&.scale(ZLim\&.getArray()[0]), zmax = sz\&.scale(ZLim\&.getArray()[1]);

                double xd = (XDir\&.is('normal') ? 1 : -1);
                double yd = (YDir\&.is('normal') ? 1 : -1);
                double zd = (ZDir\&.is('normal') ? 1 : -1);

                double[] p1 = new double[3], p2 = new double[3], xv, yv, zv;

                xstate = ystate = zstate = AXE_ANY_DIR;

                x_render\&.transform(xmin, (ymin+ymax)/2, (zmin+zmax)/2, p1, 0);
                x_render\&.transform(xmax, (ymin+ymax)/2, (zmin+zmax)/2, p2, 0);
                xv = new double[] {Math\&.rint(p2[0]-p1[0]), Math\&.rint(p2[1]-p1[1]), (p2[2]-p1[2])};
                if (xv[0] == 0 && xv[1] == 0)
                        xstate = AXE_DEPTH_DIR;
                else if (xv[2] == 0)
                {
                        if (xv[0] == 0)
                                xstate = AXE_VERT_DIR;
                        else if (xv[1] == 0)
                                xstate = AXE_HORZ_DIR;
                }
                double xPlane;
                if (xv[2] == 0)
                        if (xv[1] == 0)
                                xPlane = (xv[0] > 0 ? xmax : xmin);
                        else
                                xPlane = (xv[1] < 0 ? xmax : xmin);
                else
                        xPlane = (xv[2] < 0 ? xmin : xmax);
                double xPlaneN = (xPlane == xmin ? xmax : xmin);
                double fx = (xmax-xmin)/Math\&.sqrt(xv[0]*xv[0]+xv[1]*xv[1]);

                x_render\&.transform((xmin+xmax)/2, ymin, (zmin+zmax)/2, p1, 0);
                x_render\&.transform((xmin+xmax)/2, ymax, (zmin+zmax)/2, p2, 0);
                yv = new double[] {Math\&.rint(p2[0]-p1[0]), Math\&.rint(p2[1]-p1[1]), p2[2]-p1[2]};
                if (yv[0] == 0 && yv[1] == 0)
                        ystate = AXE_DEPTH_DIR;
                else if (yv[2] == 0)
                {
                        if (yv[0] == 0)
                                ystate = AXE_VERT_DIR;
                        else if (yv[1] == 0)
                                ystate = AXE_HORZ_DIR;
                }
                double yPlane;
                if (yv[2] == 0)
                        if (yv[1] == 0)
                                yPlane = (yv[0] > 0 ? ymax : ymin);
                        else
                                yPlane = (yv[1] < 0 ? ymax : ymin);
                else
                        yPlane = (yv[2] < 0 ? ymin : ymax);
                double yPlaneN = (yPlane == ymin ? ymax : ymin);
                double fy = (ymax-ymin)/Math\&.sqrt(yv[0]*yv[0]+yv[1]*yv[1]);

                x_render\&.transform((xmin+xmax)/2, (ymin+ymax)/2, zmin, p1, 0);
                x_render\&.transform((xmin+xmax)/2, (ymin+ymax)/2, zmax, p2, 0);
                zv = new double[] {Math\&.rint(p2[0]-p1[0]), Math\&.rint(p2[1]-p1[1]), p2[2]-p1[2]};
                if (zv[0] == 0 && zv[1] == 0)
                        zstate = AXE_DEPTH_DIR;
                else if (zv[2] == 0)
                {
                        if (zv[0] == 0)
                                zstate = AXE_VERT_DIR;
                        else if (zv[1] == 0)
                                zstate = AXE_HORZ_DIR;
                }
                double zPlane;
                if (zv[2] == 0)
                        if (zv[1] == 0)
                                zPlane = (zv[0] > 0 ? zmin : zmax);
                        else
                                zPlane = (zv[1] < 0 ? zmin : zmax);
                else
                        zPlane = (zv[2] < 0 ? zmin : zmax);
                double zPlaneN = (zPlane == zmin ? zmax : zmin);
                double fz = (zmax-zmin)/Math\&.sqrt(zv[0]*zv[0]+zv[1]*zv[1]);

                boolean mode2d = (((xstate > AXE_DEPTH_DIR ? 1 : 0) +
                                                   (ystate > AXE_DEPTH_DIR ? 1 : 0) +
                                                   (zstate > AXE_DEPTH_DIR ? 1 : 0)) == 2);
                if (TickDirMode\&.is('auto'))
                {
                        autoMode++;
                        TickDir\&.set(mode2d ? 'in' : 'out', true);
                        autoMode--;
                }

                xticklen = yticklen = zticklen = 7;

                double tickdir = (TickDir\&.is('in') ? -1 : 1);
                double xtickoffset = (mode2d && tickdir < 0 ? 0 : Math\&.max(1\&.0, xticklen)) + 5;
                double ytickoffset = (mode2d && tickdir < 0 ? 0 : Math\&.max(1\&.0, yticklen)) + 5;
                double ztickoffset = (mode2d && tickdir < 0 ? 0 : Math\&.max(1\&.0, zticklen)) + 5;

                boolean xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
                boolean boxSet = Box\&.isSet();

                boolean x2Dtop = false;
                boolean y2Dright = false;
                double zpTick = zPlane;
                boolean visible = Visible\&.isSet();

                /* 2D mode */
                if (xstate == AXE_HORZ_DIR && ystate == AXE_VERT_DIR)
                {
                        if (XAxisLocation\&.is('top'))
                        {
                                double tmp = yPlane;
                                yPlane = yPlaneN;
                                yPlaneN = tmp;
                                x2Dtop = true;
                        }
                        if (YAxisLocation\&.is('right'))
                        {
                                double tmp = xPlane;
                                xPlane = xPlaneN;
                                xPlaneN = tmp;
                                y2Dright = true;
                        }
                        if (Layer\&.is('top'))
                                zpTick = zPlaneN;
                }

                // work variables
                java\&.util\&.List l1 = new LinkedList();
                java\&.util\&.List l2 = new LinkedList();

                // Axes planes

                if (!AxesColor\&.is('none') && visible)
                {
                        r\&.setColor(AxesColor\&.getColor());

                        l1\&.add(new Point3D(xmin, ymin, zPlane));
                        l1\&.add(new Point3D(xmax, ymin, zPlane));
                        l1\&.add(new Point3D(xmax, ymax, zPlane));
                        l1\&.add(new Point3D(xmin, ymax, zPlane));

                        l1\&.add(new Point3D(xPlane, ymin, zmin));
                        l1\&.add(new Point3D(xPlane, ymax, zmin));
                        l1\&.add(new Point3D(xPlane, ymax, zmax));
                        l1\&.add(new Point3D(xPlane, ymin, zmax));

                        l1\&.add(new Point3D(xmin, yPlane, zmin));
                        l1\&.add(new Point3D(xmax, yPlane, zmin));
                        l1\&.add(new Point3D(xmax, yPlane, zmax));
                        l1\&.add(new Point3D(xmin, yPlane, zmax));

                        r\&.drawQuads(l1, 2\&.5);
                        l1\&.clear();
                }
                
                //boolean xySym = (xd*yd*(xPlane-xPlaneN)*(yPlane-yPlaneN) > 0);
                //boolean boxSet = Box\&.isSet();

                // Box

                r\&.setLineStyle('-', true);
                r\&.setLineWidth(LineWidth\&.floatValue());

                if ((boxSet || alwaysDrawBox) && visible)
                {
                        // X box
                        l1\&.add(new Point3D(xPlaneN, yPlaneN, zPlane)); l1\&.add(new Point3D(xPlane, yPlaneN, zPlane));
                        if (Box\&.isSet())
                        {
                                l1\&.add(new Point3D(xPlaneN, yPlane, zPlane)); l1\&.add(new Point3D(xPlane, yPlane, zPlane));
                                l1\&.add(new Point3D(xPlaneN, yPlane, zPlaneN)); l1\&.add(new Point3D(xPlane, yPlane, zPlaneN));
                                l1\&.add(new Point3D(xPlaneN, yPlaneN, zPlaneN)); l1\&.add(new Point3D(xPlane, yPlaneN, zPlaneN));
                        }
                        r\&.setColor(XColor\&.getColor());
                        r\&.drawSegments(l1);
                        l1\&.clear();

                        // Y box
                        l1\&.add(new Point3D(xPlaneN, yPlaneN, zPlane)); l1\&.add(new Point3D(xPlaneN, yPlane, zPlane));
                        if (Box\&.isSet())
                        {
                                l1\&.add(new Point3D(xPlane, yPlaneN, zPlane)); l1\&.add(new Point3D(xPlane, yPlane, zPlane));
                                l1\&.add(new Point3D(xPlane, yPlaneN, zPlaneN)); l1\&.add(new Point3D(xPlane, yPlane, zPlaneN));
                                l1\&.add(new Point3D(xPlaneN, yPlaneN, zPlaneN)); l1\&.add(new Point3D(xPlaneN, yPlane, zPlaneN));
                        }
                        r\&.setColor(YColor\&.getColor());
                        r\&.drawSegments(l1);
                        l1\&.clear();

                        // Z box
                        if (xySym)
                        { l1\&.add(new Point3D(xPlaneN, yPlane, zPlaneN)); l1\&.add(new Point3D(xPlaneN, yPlane, zPlane)); }
                        else
                        { l1\&.add(new Point3D(xPlane, yPlaneN, zPlaneN)); l1\&.add(new Point3D(xPlane, yPlaneN, zPlane)); }
                        if (Box\&.isSet())
                        {
                                l1\&.add(new Point3D(xPlane, yPlane, zPlaneN)); l1\&.add(new Point3D(xPlane, yPlane, zPlane));
                                if (xySym)
                                { l1\&.add(new Point3D(xPlane, yPlaneN, zPlaneN)); l1\&.add(new Point3D(xPlane, yPlaneN, zPlane)); }
                                else
                                { l1\&.add(new Point3D(xPlaneN, yPlane, zPlaneN)); l1\&.add(new Point3D(xPlaneN, yPlane, zPlane)); }
                                l1\&.add(new Point3D(xPlaneN, yPlaneN, zPlaneN)); l1\&.add(new Point3D(xPlaneN, yPlaneN, zPlane));
                        }
                        r\&.setColor(ZColor\&.getColor());
                        r\&.drawSegments(l1);
                        l1\&.clear();
                }

                r\&.setFont(Utils\&.getFont(FontName, FontSize, FontUnits, FontAngle,
                        FontWeight, getBoundingBox()\&.height));

                // X Grid

                if (xstate != AXE_DEPTH_DIR && visible)
                {
                        boolean doXGrid = XGrid\&.isSet() && !GridLineStyle\&.is('none');
                        boolean doXMinorGrid = XMinorGrid\&.isSet() && !MinorGridLineStyle\&.is('none');
                        boolean doXMinorTick = XMinorTick\&.isSet();
                        double[] xticks = sx\&.scale(XTick\&.getArray());
                        double[] xmticks = sx\&.scale(x_minorTicks);
                        String[] xticklabels = XTickLabel\&.getArray();
                        int wmax = 0, hmax = 0;
                        boolean tickAlongZ = Double\&.isInfinite(fy);

                        r\&.setColor(XColor\&.getColor());

                        // grid lines
                        if (doXGrid)
                        {
                                for (int i=0; i<xticks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xticks[i], yPlaneN, zpTick));
                                        l1\&.add(new Point3D(xticks[i], yPlane, zpTick));
                                        if (zstate != AXE_DEPTH_DIR)
                                        {
                                                l1\&.add(new Point3D(xticks[i], yPlane, zPlaneN));
                                                l1\&.add(new Point3D(xticks[i], yPlane, zPlane));
                                        }
                                }
                                r\&.setLineStyle(GridLineStyle\&.getValue(), true);
                                r\&.drawSegments(l1);
                                r\&.setLineStyle('-', true);
                                l1\&.clear();
                        }

                        // tick marks
                        if (tickAlongZ)
                        {
                                for (int i=0; i<xticks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xticks[i], yPlaneN, zPlane));
                                        l1\&.add(new Point3D(xticks[i], yPlaneN, zPlane+Math\&.signum(zPlane-zPlaneN)*fz*xticklen*tickdir));
                                        if (Box\&.isSet() && xstate != AXE_ANY_DIR)
                                        {
                                                l1\&.add(new Point3D(xticks[i], yPlaneN, zPlaneN));
                                                l1\&.add(new Point3D(xticks[i], yPlaneN,
                                                        zPlaneN+Math\&.signum(zPlaneN-zPlane)*fz*xticklen*tickdir));
                                        }
                                        l2\&.add(new double[] {xticks[i], yPlaneN, zPlane+Math\&.signum(zPlane-zPlaneN)*fz*xtickoffset});
                                }
                        }
                        else
                        {
                                for (int i=0; i<xticks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xticks[i], yPlaneN, zpTick));
                                        l1\&.add(new Point3D(xticks[i], yPlaneN+Math\&.signum(yPlaneN-yPlane)*fy*xticklen*tickdir, zpTick));
                                        if (Box\&.isSet() && xstate != AXE_ANY_DIR)
                                        {
                                                l1\&.add(new Point3D(xticks[i], yPlane, zpTick));
                                                l1\&.add(new Point3D(xticks[i],
                                                        yPlane+Math\&.signum(yPlane-yPlaneN)*fy*xticklen*tickdir, zpTick));
                                        }
                                        l2\&.add(new double[] {xticks[i], yPlaneN+Math\&.signum(yPlaneN-yPlane)*fy*xtickoffset, zPlane});
                                }
                        }
                        r\&.drawSegments(l1);
                        l1\&.clear();

                        // tick texts
                        for (int i=0; i<xticks\&.length && i<xticklabels\&.length; i++)
                        {
                                String txt = (x_logTickLabels ? '10^{'+xticklabels[i]+'}' : xticklabels[i]);
                                Rectangle d = r\&.drawText(txt, (double[])l2\&.get(i),
                                                (xstate == AXE_HORZ_DIR ? 1 : (xySym ? 0 : 2)),
                                                (xstate == AXE_VERT_DIR ? 1 : (zd*zv[2] <= 0 && !x2Dtop ? 2 : 0)));
                                if (d\&.width > wmax) wmax = d\&.width;
                                if (d\&.height > hmax) hmax = d\&.height;
                        }
                        l2\&.clear();
                        wmax += 5;

                        // minor grid lines
                        if (doXMinorGrid)
                        {
                                for (int i=0; i<x_minorTicks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xmticks[i], yPlaneN, zpTick));
                                        l1\&.add(new Point3D(xmticks[i], yPlane, zpTick));
                                        if (zstate != AXE_DEPTH_DIR)
                                        {
                                                l1\&.add(new Point3D(xmticks[i], yPlane, zPlaneN));
                                                l1\&.add(new Point3D(xmticks[i], yPlane, zPlane));
                                        }
                                }
                                r\&.setLineStyle(MinorGridLineStyle\&.getValue(), true);
                                r\&.drawSegments(l1);
                                r\&.setLineStyle('-', true);
                                l1\&.clear();
                        }

                        // minor tick marks
                        if (doXMinorTick)
                        {
                                if (tickAlongZ)
                                {
                                        for (int i=0; i<x_minorTicks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xmticks[i], yPlaneN, zPlane));
                                                l1\&.add(new Point3D(xmticks[i], yPlaneN,
                                                        zPlane+Math\&.signum(zPlane-zPlaneN)*fz*xticklen/2*tickdir));
                                                if (Box\&.isSet() && xstate != AXE_ANY_DIR)
                                                {
                                                        l1\&.add(new Point3D(xmticks[i], yPlaneN, zPlaneN));
                                                        l1\&.add(new Point3D(xmticks[i], yPlaneN,
                                                                zPlaneN+Math\&.signum(zPlaneN-zPlane)*fz*xticklen/2*tickdir));
                                                }
                                        }
                                }
                                else
                                {
                                        for (int i=0; i<x_minorTicks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xmticks[i], yPlaneN, zpTick));
                                                l1\&.add(new Point3D(xmticks[i],
                                                        yPlaneN+Math\&.signum(yPlaneN-yPlane)*fy*xticklen/2*tickdir, zpTick));
                                                if (Box\&.isSet() && xstate != AXE_ANY_DIR)
                                                {
                                                        l1\&.add(new Point3D(xmticks[i], yPlane, zpTick));
                                                        l1\&.add(new Point3D(xmticks[i],
                                                                yPlane+Math\&.signum(yPlane-yPlaneN)*fy*xticklen/2*tickdir, zpTick));
                                                }
                                        }
                                }
                                r\&.drawSegments(l1);
                                l1\&.clear();
                        }

                        // label
                        if (!XLabel\&.isEmpty())
                        {
                                TextObject xLabObj = XLabel\&.getText();
                                if (xLabObj\&.PositionMode\&.isSet())
                                {
                                        xLabObj\&.HAlign\&.reset(xstate > AXE_DEPTH_DIR ? 'center' : (xySym ? 'left' : 'right'));
                                        xLabObj\&.VAlign\&.reset(xstate == AXE_VERT_DIR ? 'bottom' : (zd*zv[2] <= 0 ? 'top' : 'bottom'));

                                        double angle = 0;
                                        double[] p = new double[] {(xmin+xmax)/2, yPlaneN, zPlane};
                                        if (tickAlongZ)
                                                p[2] += (Math\&.signum(zPlane-zPlaneN)*fz*xtickoffset);
                                        else
                                                p[1] += (Math\&.signum(yPlaneN-yPlane)*fy*xtickoffset);
                                        x_render\&.transform(p[0], p[1], p[2], p, 0);
                                        switch (xstate)
                                        {
                                                case AXE_ANY_DIR:
                                                        p[0] += (xySym ? wmax : -wmax);
                                                        p[1] += (zd*zv[2] <= 0 ? hmax : -hmax);
                                                        break;
                                                case AXE_VERT_DIR:
                                                        p[0] -= wmax;
                                                        angle = 90;
                                                        break;
                                                case AXE_HORZ_DIR:
                                                        p[1] += hmax;
                                                        break;
                                        }
                                        unTransform(p[0], p[1], p[2], p, 0);
                                        xLabObj\&.Position\&.reset(new double[] {p[0], p[1], p[2]});
                                        if (xLabObj\&.Rotation\&.doubleValue() != angle)
                                                try { xLabObj\&.Rotation\&.set(new Double(angle)); }
                                                catch (PropertyException e) {}
                                }
                                //xLabObj\&.draw(r);
                        }
                }

                // Y Grid

                if (ystate != AXE_DEPTH_DIR && visible)
                {
                        boolean doYGrid = YGrid\&.isSet() && !GridLineStyle\&.is('none');
                        boolean doYMinorGrid = YMinorGrid\&.isSet() && !MinorGridLineStyle\&.is('none');
                        boolean doYMinorTick = YMinorTick\&.isSet();
                        double[] yticks = sy\&.scale(YTick\&.getArray());
                        double[] ymticks = sy\&.scale(y_minorTicks);
                        String[] yticklabels = YTickLabel\&.getArray();
                        int wmax = 0, hmax = 0;
                        boolean tickAlongZ = Double\&.isInfinite(fx);
                        
                        r\&.setColor(YColor\&.getColor());

                        // grid lines
                        if (doYGrid)
                        {
                                for (int i=0; i<yticks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xPlaneN, yticks[i], zpTick));
                                        l1\&.add(new Point3D(xPlane, yticks[i], zpTick));
                                        if (zstate != AXE_DEPTH_DIR)
                                        {
                                                l1\&.add(new Point3D(xPlane, yticks[i], zPlaneN));
                                                l1\&.add(new Point3D(xPlane, yticks[i], zPlane));
                                        }
                                }
                                r\&.setLineStyle(GridLineStyle\&.getValue(), true);
                                r\&.drawSegments(l1);
                                r\&.setLineStyle('-', true);
                                l1\&.clear();
                        }

                        // tick marks
                        if (tickAlongZ)
                        {
                                for (int i=0; i<yticks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xPlaneN, yticks[i], zPlane));
                                        l1\&.add(new Point3D(xPlaneN, yticks[i], zPlane+Math\&.signum(zPlane-zPlaneN)*fz*yticklen*tickdir));
                                        if (Box\&.isSet() && ystate != AXE_ANY_DIR)
                                        {
                                                l1\&.add(new Point3D(xPlaneN, yticks[i], zPlaneN));
                                                l1\&.add(new Point3D(xPlaneN, yticks[i],
                                                        zPlaneN+Math\&.signum(zPlaneN-zPlane)*fz*yticklen*tickdir));
                                        }
                                        l2\&.add(new double[] {xPlaneN, yticks[i], zPlane+Math\&.signum(zPlane-zPlaneN)*fz*ytickoffset});
                                }
                        }
                        else
                        {
                                for (int i=0; i<yticks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xPlaneN, yticks[i], zpTick));
                                        l1\&.add(new Point3D(xPlaneN+Math\&.signum(xPlaneN-xPlane)*fx*yticklen*tickdir, yticks[i], zpTick));
                                        if (Box\&.isSet() && ystate != AXE_ANY_DIR)
                                        {
                                                l1\&.add(new Point3D(xPlane, yticks[i], zpTick));
                                                l1\&.add(new Point3D(xPlane+Math\&.signum(xPlane-xPlaneN)*fx*yticklen*tickdir,
                                                        yticks[i], zpTick));
                                        }
                                        l2\&.add(new double[]{xPlaneN+Math\&.signum(xPlaneN-xPlane)*fx*ytickoffset, yticks[i], zPlane});
                                }
                        }
                        r\&.drawSegments(l1);
                        l1\&.clear();

                        // tick texts
                        for (int i=0; i<yticks\&.length && i<yticklabels\&.length; i++)
                        {
                                String txt = (y_logTickLabels ? '10^{'+yticklabels[i]+'}' : yticklabels[i]);
                                Rectangle d = r\&.drawText(txt, (double[])l2\&.get(i),
                                                (ystate == AXE_HORZ_DIR ? 1 : (!xySym || y2Dright ? 0 : 2)),
                                                (ystate == AXE_VERT_DIR ? 1 : (zd*zv[2] <= 0 ? 2 : 0)));
                                if (d\&.width > wmax) wmax = d\&.width;
                                if (d\&.height > hmax) hmax = d\&.height;
                        }
                        l2\&.clear();
                        wmax += 5;

                        // minor grid lines
                        if (doYMinorGrid)
                        {
                                for (int i=0; i<y_minorTicks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xPlaneN, ymticks[i], zpTick));
                                        l1\&.add(new Point3D(xPlane, ymticks[i], zpTick));
                                        if (zstate != AXE_DEPTH_DIR)
                                        {
                                                l1\&.add(new Point3D(xPlane, ymticks[i], zPlaneN));
                                                l1\&.add(new Point3D(xPlane, ymticks[i], zPlane));
                                        }
                                }
                                r\&.setLineStyle(MinorGridLineStyle\&.getValue(), true);
                                r\&.drawSegments(l1);
                                r\&.setLineStyle('-', true);
                                l1\&.clear();
                        }

                        // minor tick marks
                        if (doYMinorTick)
                        {
                                if (tickAlongZ)
                                {
                                        for (int i=0; i<y_minorTicks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xPlaneN, ymticks[i], zPlane));
                                                l1\&.add(new Point3D(xPlaneN, ymticks[i],
                                                        zPlane+Math\&.signum(zPlane-zPlaneN)*fz*yticklen/2*tickdir));
                                                if (Box\&.isSet() && ystate != AXE_ANY_DIR)
                                                {
                                                        l1\&.add(new Point3D(xPlaneN, ymticks[i], zPlaneN));
                                                        l1\&.add(new Point3D(xPlaneN, ymticks[i],
                                                                zPlaneN+Math\&.signum(zPlaneN-zPlane)*fz*yticklen/2*tickdir));
                                                }
                                        }
                                }
                                else
                                {
                                        for (int i=0; i<y_minorTicks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xPlaneN, ymticks[i], zpTick));
                                                l1\&.add(new Point3D(xPlaneN+Math\&.signum(xPlaneN-xPlane)*fx*yticklen/2*tickdir,
                                                        ymticks[i], zpTick));
                                                if (Box\&.isSet() && ystate != AXE_ANY_DIR)
                                                {
                                                        l1\&.add(new Point3D(xPlane, ymticks[i], zpTick));
                                                        l1\&.add(new Point3D(xPlane+Math\&.signum(xPlane-xPlaneN)*fx*yticklen/2*tickdir,
                                                                ymticks[i], zpTick));
                                                }
                                        }
                                }
                                r\&.drawSegments(l1);
                                l1\&.clear();
                        }

                        // label
                        if (!YLabel\&.isEmpty())
                        {
                                TextObject yLabObj = YLabel\&.getText();
                                if (yLabObj\&.PositionMode\&.isSet())
                                {
                                        yLabObj\&.HAlign\&.reset(ystate > AXE_DEPTH_DIR ? 'center' : (!xySym ? 'left' : 'right'));
                                        yLabObj\&.VAlign\&.reset(ystate == AXE_VERT_DIR ? 'bottom' : (zd*zv[2] <= 0 ? 'top' : 'bottom'));
                                
                                        double angle = 0;
                                        double[] p = new double[] {xPlaneN, (ymin+ymax)/2, zPlane};
                                        if (tickAlongZ)
                                                p[2] += (Math\&.signum(zPlane-zPlaneN)*fz*ytickoffset);
                                        else
                                                p[0] += (Math\&.signum(xPlaneN-xPlane)*fx*ytickoffset);
                                        x_render\&.transform(p[0], p[1], p[2], p, 0);
                                        switch (ystate)
                                        {
                                                case AXE_ANY_DIR:
                                                        p[0] += (!xySym ? wmax : -wmax);
                                                        p[1] += (zd*zv[2] <= 0 ? hmax : -hmax);
                                                        break;
                                                case AXE_VERT_DIR:
                                                        p[0] -= wmax;
                                                        angle = 90;
                                                        break;
                                                case AXE_HORZ_DIR:
                                                        p[1] += hmax;
                                                        break;
                                        }
                                        unTransform(p[0], p[1], p[2], p, 0);
                                        yLabObj\&.Position\&.reset(new double[] {p[0], p[1], p[2]});
                                        if (yLabObj\&.Rotation\&.doubleValue() != angle)
                                                try { yLabObj\&.Rotation\&.set(new Double(angle)); }
                                                catch (PropertyException e) {}
                                }
                                //yLabObj\&.draw(r);
                        }
                }
                
                // Z Grid

                if (zstate != AXE_DEPTH_DIR && visible)
                {
                        boolean doZGrid = ZGrid\&.isSet() && !GridLineStyle\&.is('none');
                        boolean doZMinorGrid = ZMinorGrid\&.isSet() && !MinorGridLineStyle\&.is('none');
                        boolean doZMinorTick = ZMinorTick\&.isSet();
                        double[] zticks = sz\&.scale(ZTick\&.getArray());
                        double[] zmticks = sz\&.scale(z_minorTicks);
                        int wmax = 0, hmax = 0;
                        String[] zticklabels = ZTickLabel\&.getArray();

                        r\&.setColor(ZColor\&.getColor());

                        // grid lines
                        if (doZGrid)
                        {
                                for (int i=0; i<zticks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xPlaneN, yPlane, zticks[i]));
                                        l1\&.add(new Point3D(xPlane, yPlane, zticks[i]));
                                        l1\&.add(new Point3D(xPlane, yPlaneN, zticks[i]));
                                        l1\&.add(new Point3D(xPlane, yPlane, zticks[i]));
                                }
                                r\&.setLineStyle(GridLineStyle\&.getValue(), true);
                                r\&.drawSegments(l1);
                                r\&.setLineStyle('-', true);
                                l1\&.clear();
                        }

                        // tick marks
                        if (xySym)
                        {
                                if (Double\&.isInfinite(fy))
                                        for (int i=0; i<zticks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xPlaneN, yPlane, zticks[i]));
                                                l1\&.add(new Point3D(xPlaneN+Math\&.signum(xPlaneN-xPlane)*fx*zticklen*tickdir,
                                                                yPlane, zticks[i]));
                                                if (Box\&.isSet() && zstate != AXE_ANY_DIR)
                                                {
                                                        l1\&.add(new Point3D(xPlane, yPlane, zticks[i]));
                                                        l1\&.add(new Point3D(xPlane+Math\&.signum(xPlane-xPlaneN)*fx*zticklen*tickdir,
                                                                        yPlane, zticks[i]));
                                                }
                                                l2\&.add(new double[] {xPlaneN+Math\&.signum(xPlaneN-xPlane)*fx*ztickoffset, yPlane, zticks[i]});
                                        }
                                else
                                        for (int i=0; i<zticks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xPlaneN, yPlane, zticks[i]));
                                                l1\&.add(new Point3D(xPlaneN, yPlane+Math\&.signum(yPlane-yPlaneN)*fy*zticklen*tickdir,
                                                                zticks[i]));
                                                l2\&.add(new double[] {xPlaneN, yPlane+Math\&.signum(yPlane-yPlaneN)*fy*ztickoffset, zticks[i]});
                                        }
                        }
                        else
                        {
                                if (Double\&.isInfinite(fx))
                                        for (int i=0; i<zticks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xPlane, yPlaneN, zticks[i]));
                                                l1\&.add(new Point3D(xPlane, yPlaneN+Math\&.signum(yPlaneN-yPlane)*fy*zticklen*tickdir,
                                                                zticks[i]));
                                                if (Box\&.isSet() && zstate != AXE_ANY_DIR)
                                                {
                                                        l1\&.add(new Point3D(xPlane, yPlane, zticks[i]));
                                                        l1\&.add(new Point3D(xPlane, yPlane+Math\&.signum(yPlane-yPlaneN)*fy*zticklen*tickdir,
                                                                        zticks[i]));
                                                }
                                                l2\&.add(new double[] {xPlane, yPlaneN+Math\&.signum(yPlaneN-yPlane)*fy*ztickoffset, zticks[i]});
                                        }
                                else
                                        for (int i=0; i<zticks\&.length; i++)
                                        {
                                                l1\&.add(new Point3D(xPlane, yPlaneN, zticks[i]));
                                                l1\&.add(new Point3D(xPlane+Math\&.signum(xPlane-xPlaneN)*fx*zticklen*tickdir, yPlaneN,
                                                                zticks[i]));
                                                l2\&.add(new double[] {xPlane+Math\&.signum(xPlane-xPlaneN)*fx*ztickoffset, yPlaneN, zticks[i]});
                                        }
                        }
                        r\&.drawSegments(l1);
                        l1\&.clear();

                        // tick texts
                        for (int i=0; i<zticks\&.length && i<zticklabels\&.length; i++)
                        {
                                String txt = (z_logTickLabels ? '10^{'+zticklabels[i]+'}' : zticklabels[i]);
                                Rectangle d = r\&.drawText(txt, (double[])l2\&.get(i),
                                                2,
                                                (zstate == AXE_VERT_DIR ? 1 : (zd*zv[2] < 0 ? 0 : 2)));
                                if (d\&.width > wmax) wmax = d\&.width;
                                if (d\&.height > hmax) hmax = d\&.height;
                        }
                        l2\&.clear();
                        wmax += 5;

                        // minor grid lines
                        if (doZMinorGrid)
                        {
                                for (int i=0; i<z_minorTicks\&.length; i++)
                                {
                                        l1\&.add(new Point3D(xPlaneN, yPlane, zmticks[i]));
                                        l1\&.add(new Point3D(xPlane, yPlane, zmticks[i]));
                                        l1\&.add(new Point3D(xPlane, yPlaneN, zmticks[i]));
                                        l1\&.add(new Point3D(xPlane, yPlane, zmticks[i]));
                                }
                                r\&.setLineStyle(MinorGridLineStyle\&.getValue(), true);
                                r\&.drawSegments(l1);
                                r\&.setLineStyle('-', true);
                                l1\&.clear();
                        }

                        // minor tick marks
                        if (doZMinorTick)
                        {
                                if (xySym)
                                {
                                        if (Double\&.isInfinite(fy))
                                                for (int i=0; i<z_minorTicks\&.length; i++)
                                                {
                                                        l1\&.add(new Point3D(xPlaneN, yPlane, zmticks[i]));
                                                        l1\&.add(new Point3D(xPlaneN+Math\&.signum(xPlaneN-xPlane)*fx*zticklen/2*tickdir,
                                                                                yPlane, zmticks[i]));
                                                        if (Box\&.isSet() && zstate != AXE_ANY_DIR)
                                                        {
                                                                l1\&.add(new Point3D(xPlane, yPlane, zmticks[i]));
                                                                l1\&.add(new Point3D(xPlane+Math\&.signum(xPlane-xPlaneN)*fx*zticklen/2*tickdir,
                                                                                        yPlane, zmticks[i]));
                                                        }
                                                }
                                        else
                                                for (int i=0; i<z_minorTicks\&.length; i++)
                                                {
                                                        l1\&.add(new Point3D(xPlaneN, yPlane, zmticks[i]));
                                                        l1\&.add(new Point3D(xPlaneN, yPlane+Math\&.signum(yPlane-yPlaneN)*fy*zticklen/2*tickdir,
                                                                                zmticks[i]));
                                                }
                                }
                                else
                                {
                                        if (Double\&.isInfinite(fx))
                                                for (int i=0; i<z_minorTicks\&.length; i++)
                                                {
                                                        l1\&.add(new Point3D(xPlane, yPlaneN, zmticks[i]));
                                                        l1\&.add(new Point3D(xPlane, yPlaneN+Math\&.signum(yPlaneN-yPlane)*fy*zticklen/2*tickdir,
                                                                                zmticks[i]));
                                                        if (Box\&.isSet() && zstate != AXE_ANY_DIR)
                                                        {
                                                                l1\&.add(new Point3D(xPlane, yPlane, zmticks[i]));
                                                                l1\&.add(new Point3D(xPlane, yPlane+Math\&.signum(yPlane-yPlaneN)*fy*zticklen/2*tickdir,
                                                                                        zmticks[i]));
                                                        }
                                                }
                                        else
                                                for (int i=0; i<z_minorTicks\&.length; i++)
                                                {
                                                        l1\&.add(new Point3D(xPlane, yPlaneN, zmticks[i]));
                                                        l1\&.add(new Point3D(xPlane+Math\&.signum(xPlane-xPlaneN)*fx*zticklen/2*tickdir, yPlaneN,
                                                                                zmticks[i]));
                                                }
                                }
                                r\&.drawSegments(l1);
                                l1\&.clear();
                        }

                        // label
                        if (!ZLabel\&.isEmpty())
                        {
                                TextObject zLabObj = ZLabel\&.getText();
                                if (zLabObj\&.PositionMode\&.isSet())
                                {
                                        boolean camAuto = CameraUpVectorMode\&.is('auto');

                                        zLabObj\&.HAlign\&.reset((zstate > AXE_DEPTH_DIR || camAuto) ? 'center' : 'right');
                                        zLabObj\&.VAlign\&.reset(zstate == AXE_VERT_DIR ? 'bottom' : ((zd*zv[2] < 0 || camAuto) ? 'bottom' : 'top'));
                                
                                        double angle = 0;
                                        double[] p;
                                        if (xySym)
                                        {
                                                p = new double[] {xPlaneN, yPlane, (zmin+zmax)/2};
                                                if (Double\&.isInfinite(fy))
                                                        p[0] += (Math\&.signum(xPlaneN-xPlane)*fx*ztickoffset);
                                                else
                                                        p[1] += (Math\&.signum(yPlane-yPlaneN)*fy*ztickoffset);
                                        }
                                        else
                                        {
                                                p = new double[] {xPlane, yPlaneN, (zmin+zmax)/2};
                                                if (Double\&.isInfinite(fx))
                                                        p[1] += (Math\&.signum(yPlaneN-yPlane)*fy*ztickoffset);
                                                else
                                                        p[0] += (Math\&.signum(xPlane-xPlaneN)*fx*ztickoffset);
                                        }
                                        x_render\&.transform(p[0], p[1], p[2], p, 0);
                                        switch (zstate)
                                        {
                                                case AXE_ANY_DIR:
                                                        if (camAuto)
                                                        {
                                                                p[0] -= wmax;
                                                                angle = 90;
                                                        }
                                                        /* TODO: what's the correct offset?
                                                        p[0] += (!xySym ? wmax : -wmax);
                                                        p[1] += (zd*zv[2] <= 0 ? hmax : -hmax);
                                                        */
                                                        break;
                                                case AXE_VERT_DIR:
                                                        p[0] -= wmax;
                                                        angle = 90;
                                                        break;
                                                case AXE_HORZ_DIR:
                                                        p[1] += hmax;
                                                        break;
                                        }
                                        unTransform(p[0], p[1], p[2], p, 0);
                                        zLabObj\&.Position\&.reset(new double[] {p[0], p[1], p[2]});
                                        if (zLabObj\&.Rotation\&.doubleValue() != angle)
                                                try { zLabObj\&.Rotation\&.set(new Double(angle)); }
                                                catch (PropertyException e) {}
                                }
                                //zLabObj\&.draw(r);
                        }
                }

                r\&.setLineStyle('-', false);
                
                // Title

                if (!Title\&.isEmpty())
                {
                        TextObject titleObj = Title\&.getText();
                        if (titleObj\&.PositionMode\&.isSet())
                        {
                                // position title automatically
                                Rectangle bb = getBoundingBox();
                                double[] p = new double[3];
                                unTransform(bb\&.x+bb\&.width/2, getCanvas()\&.getHeight()-(bb\&.y+bb\&.height+10), (x_zmin+x_zmax)/2, p, 0);
                                titleObj\&.Position\&.reset(p);
                        }
                        //titleObj\&.draw(r);
                }

                // Children

                Iterator it;

                // TODO: how to avoid clipping on the clip planes?
                r\&.setClipBox(xmin, xmax, ymin, ymax, zmin, zmax);
                r\&.setCamera(CameraPosition\&.getArray(), CameraTarget\&.getArray());

                synchronized (Children)
                {
                        LinkedList objList = new LinkedList();

                        // Do lights first
                        it = Children\&.iterator();
                        while (it\&.hasNext())
                        {
                                GraphicObject obj = (GraphicObject)it\&.next();
                                if (obj\&.Visible\&.isSet())
                                        if (obj instanceof LightObject)
                                                obj\&.draw(r);
                                        else
                                                objList\&.add(obj);
                        }

                        // Do other objects
                        it = objList\&.iterator();
                        while (it\&.hasNext())
                        {
                                GraphicObject obj = (GraphicObject)it\&.next();
                                if (!obj\&.hasProperty('Units') || ((RadioProperty)obj\&.getProperty('Units'))\&.is('data'))
                                {
                                        r\&.setClipping(obj\&.Clipping\&.isSet());
                                        obj\&.draw(r);
                                        it\&.remove();
                                }
                        }

                        // Final pass
                        it = objList\&.iterator();
                        while (it\&.hasNext())
                        {
                                GraphicObject obj = (GraphicObject)it\&.next();
                                r\&.setClipping(obj\&.Clipping\&.isSet());
                                obj\&.draw(r);
                        }
                }

                r\&.setClipping(false);
                r\&.end();
                
                if (zoomBox)
                {
                        drawZoomBox(xPrev, yPrev);
                }
        }
.fi
.SS "void \fBendOperation\fP (intop, MouseEvente)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.boundingBox, AxesObject\&.doZoom(), AxesObject\&.drawZoomBox(), AxesContainer\&.OP_ROTATE, AxesContainer\&.OP_ZOOM, AxesObject\&.xAnchor, AxesObject\&.xPrev, AxesObject\&.yAnchor, AxesObject\&.yPrev, and AxesObject\&.zoomBox\&.
.PP
Referenced by AxesContainer\&.mouseReleased()\&.
.PP
.nf
        {
                switch (op)
                {
                        case FigureObject\&.OP_ZOOM:
                                if (zoomBox)
                                {
                                        drawZoomBox(xPrev, yPrev);
                                        zoomBox = false;
                                        if (xPrev != xAnchor && yPrev != yAnchor)
                                                doZoom(xAnchor, yAnchor, xPrev, yPrev);
                                }
                                break;
                        case FigureObject\&.OP_ROTATE:
                                boundingBox = null;
                                break;
                }
        }
.fi
.SS "void \fBeventOccured\fP (\fBHandleEvent\fPevt)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSink\fP\&.
.PP
References HandleObject\&.propertyChanged()\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                if (evt\&.getName()\&.equals('PropertyChanged'))
                        propertyChanged(evt\&.getProperty());
        }
.fi
.SS "boolean \fBexecuteOnce\fP ()\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSink\fP\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                return false;
        }
.fi
.SS "Object \fBget\fP (\fBProperty\fPp)\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBFigureObject\fP, and \fBUIControlObject\fP\&.
.PP
.nf
        {
                return p\&.get();
        }
.fi
.SS "Object \fBget\fP (Stringname)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
References Property\&.get(), and HandleObject\&.getDefaultProperty()\&.
.PP
Referenced by AxesObject\&.autoScaleC(), and LegendObject\&.makeItemFromLine()\&.
.PP
.nf
        {
                if (name\&.toLowerCase()\&.startsWith('default'))
                {
                        Property p = getDefaultProperty(name);
                        if (p != null)
                                return p\&.get();
                        throw new PropertyException('invalid default property - ' + name\&.toLowerCase());
                }
                else
                        return super\&.get(name);
        }
.fi
.SS "\fBHandleObject\fP \fBgetAncestor\fP (Stringtype)\fC [inline, inherited]\fP"
.PP
References HandleObjectListProperty\&.elementAt(), HandleObject\&.Parent, HandleObjectListProperty\&.size(), StringProperty\&.toString(), and HandleObject\&.Type\&.
.PP
Referenced by AxesContainer\&.createCanvas(), HandleObject\&.doButtonDownFcn(), AxesContainer\&.getDefaultMouseOp(), AxesObject\&.getFigure(), and GraphicObject\&.set()\&.
.PP
.nf
        {
                HandleObject curr = this;

                while (true)
                {
                        if (curr\&.Type\&.toString()\&.equalsIgnoreCase(type))
                                return curr;
                        else if (curr\&.Parent\&.size() <= 0)
                                return null;
                        else
                                curr = curr\&.Parent\&.elementAt(0);
                }
        }
.fi
.SS "\fBAxesContainer\fP \fBgetAxesContainer\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObjectListProperty\&.elementAt(), HandleObject\&.Parent, and HandleObjectListProperty\&.size()\&.
.PP
.nf
        {
                if (Parent\&.size() > 0)
                        return (AxesContainer)Parent\&.elementAt(0);
                else
                        return null;
        }
.fi
.SS "\fBBaseLineObject\fP \fBgetBaseLine\fP ()\fC [inline, inherited]\fP"
.PP
References AxesObject\&.baseLine, LineObject\&.LineColor, Property\&.reset(), and LineObject\&.validate()\&.
.PP
Referenced by BarseriesObject\&.BarseriesObject()\&.
.PP
.nf
        {
                if (baseLine == null)
                {
                        baseLine = new BaseLineObject(this, 0);
                        baseLine\&.LineColor\&.reset('k');
                        baseLine\&.validate();
                }
                return baseLine;
        }
.fi
.SS "Rectangle \fBgetBoundingBox\fP ()\fC [inline, package, inherited]\fP"
.PP
References Utils\&.convertPosition(), VectorProperty\&.getArray(), AxesObject\&.getCanvas(), RenderCanvas\&.getComponent(), RadioProperty\&.getValue(), AxesObject\&.Position, and AxesObject\&.Units\&.
.PP
Referenced by AxesObject\&.convertUnits(), AxesObject\&.draw(), AxesObject\&.startOperation(), and AxesObject\&.updateXFormMatrices()\&.
.PP
.nf
        {
                double[] pos = Utils\&.convertPosition(Position\&.getArray(), Units\&.getValue(), 'pixels', getCanvas()\&.getComponent());
                return new Rectangle((int)(pos[0]-1), (int)(pos[1]-1), (int)pos[2], (int)pos[3]);
        }
.fi
.SS "Renderer\&.CachedData \fBgetCachedData\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObject\&.cachedData\&.
.PP
Referenced by GLRenderer\&.draw()\&.
.PP
.nf
        {
                return cachedData;
        }
.fi
.SS "\fBRenderCanvas\fP \fBgetCanvas\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObjectListProperty\&.elementAt(), and HandleObject\&.Parent\&.
.PP
Referenced by ColorbarObject\&.buildColorbar(), AxesObject\&.convertUnits(), LegendObject\&.doLayout(), ColorbarObject\&.doLocate(), LegendObject\&.doLocate(), AxesObject\&.doZoom(), AxesObject\&.draw(), AxesObject\&.drawZoomBox(), AxesObject\&.getBoundingBox(), TextObject\&.getExtent(), AxesObject\&.getOuterBoundingBox(), AxesObject\&.operation(), AxesObject\&.propertyChanged(), AxesObject\&.unZoom(), ColorbarObject\&.updateActivePosition(), LegendObject\&.updateActivePosition(), TextObject\&.updateData(), AxesObject\&.updateOuterPosition(), AxesObject\&.updatePosition(), and AxesObject\&.updateXFormMatrices()\&.
.PP
.nf
        {
                return ((AxesContainer)Parent\&.elementAt(0))\&.getCanvas();
        }
.fi
.SS "double [] \fBgetChildrenLimits\fP (StringLim, booleanlogMode, booleanisZ)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.Children, HandleObjectListProperty\&.elementAt(), PropertySet\&.getProperty(), BooleanProperty\&.isSet(), HandleObjectListProperty\&.size(), and HandleObject\&.Visible\&.
.PP
Referenced by AxesObject\&.autoAxis()\&.
.PP
.nf
        {
                String LimInclude = Lim+'Include';
                double[] lim = (logMode ?
                                new double[] { Double\&.POSITIVE_INFINITY, Double\&.MIN_VALUE } :
                                new double[] { Double\&.POSITIVE_INFINITY, Double\&.NEGATIVE_INFINITY });

                for (int i=0; i<Children\&.size(); i++)
                {
                        GraphicObject go = (GraphicObject)Children\&.elementAt(i);
                        if (go\&.Visible\&.isSet() && ((BooleanProperty)go\&.getProperty(LimInclude))\&.isSet())
                        {
                                double[] _lim = ((VectorProperty)go\&.getProperty(Lim))\&.getArray();
                                if (logMode)
                                {
                                        lim[0] = Math\&.min(_lim[2], lim[0]);
                                        lim[1] = Math\&.max(_lim[3], lim[1]);
                                }
                                else
                                {
                                        lim[0] = Math\&.min(_lim[0], lim[0]);
                                        lim[1] = Math\&.max(_lim[1], lim[1]);
                                }
                        }
                }

                if (logMode)
                {
                        if (lim[0] > lim[1])
                        {
                                lim[0] = 1;
                                lim[1] = 10;
                        }
                }
                else
                {
                        if (lim[0] > lim[1])
                        {
                                lim[0] = (isZ ? -0\&.5 : 0);
                                lim[1] = (isZ ? 0\&.5 : 1);
                        }
                        else if (lim[0] == lim[1])
                        {
                                lim[0] -= 0\&.5;
                                lim[1] += 0\&.5;
                        }
                }

                return lim;
        }
.fi
.SS "java\&.awt\&.Component \fBgetComponent\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBFigureObject\fP, \fBUIPanelObject\fP, and \fBUIControlObject\fP\&.
.PP
Referenced by UIControlObject\&.getParentComponent(), and UIPanelObject\&.getParentComponent()\&.
.PP
.nf
        {
                System\&.out\&.println('Warning: no component associated with ' + getClass());
                return null;
        }
.fi
.SS "\fBProperty\fP \fBgetDefaultProperty\fP (Stringname)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.defaultSet, HandleObjectListProperty\&.elementAt(), Factory\&.getDefaultProperty(), HandleObject\&.getDefaultProperty(), PropertySet\&.getProperty(), HandleObject\&.Parent, and HandleObjectListProperty\&.size()\&.
.PP
Referenced by HandleObject\&.get(), HandleObject\&.getDefaultProperty(), Property\&.initDefault(), and HandleObject\&.set()\&.
.PP
.nf
        {
                Property p = defaultSet\&.getProperty(name);
                if (p != null)
                        return p;
                else if (Parent\&.size() > 0)
                        return Parent\&.elementAt(0)\&.getDefaultProperty(name);
                else
                        return Factory\&.getDefaultProperty(name);
        }
.fi
.SS "\fBFigureObject\fP \fBgetFigure\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObject\&.getAncestor()\&.
.PP
Referenced by ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), AxesObject\&.convertCData(), AxesObject\&.convertCDataToIndex(), Utils\&.getAlphaData(), SurfaceObject\&.getAlphaData(), PatchObject\&.getAlphaData(), ColorbarObject\&.propertyChanged(), and J2DRenderer\&.setXForm()\&.
.PP
.nf
        {
                return (FigureObject)getAncestor('figure');
        }
.fi
.SS "double \fBgetHandle\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObject\&.handle\&.
.PP
Referenced by UIPanelObject\&.componentResized(), FigureObject\&.componentResized(), UIControlObject\&.controlActivated(), HandleObject\&.delete(), HandleObject\&.doButtonDownFcn(), OctaveSink\&.doInvoke(), RootObject\&.findFigure(), HandleObjectListProperty\&.getHandleArray(), HandleObject\&.HandleObject(), AxesObject\&.reset(), HandleObject\&.setHandle(), HandleObjectListProperty\&.toString(), FigureObject\&.updateHandle(), FigureObject\&.updateTitle(), HandleObject\&.validate(), and FigureObject\&.windowClosing()\&.
.PP
.nf
        {
                return handle;
        }
.fi
.SS "static \fBHandleObject\fP \fBgetHandleObject\fP (doublehandle)  throws \fBException\fP 	\fC [inline, static, inherited]\fP"
.PP
References RootObject\&.getInstance(), HandleObject\&.handle, and HandleObject\&.handleMap\&.
.PP
Referenced by TextProperty\&.convertValue(), HandleObjectListProperty\&.convertValue(), and RootObject\&.createNewFigure()\&.
.PP
.nf
        {
                WeakReference ref = (WeakReference)handleMap\&.get(new Double(handle));
                if (ref != null && ref\&.get() != null)
                {
                        return (HandleObject)ref\&.get();
                }
                if (handle == 0)
                        return RootObject\&.getInstance();
                throw new Exception('invalid handle - ' + handle);
        }
.fi
.SS "\fBLegendObject\fP \fBgetLegend\fP ()\fC [inline, inherited]\fP"
.PP
References AxesObject\&.legend\&.
.PP
.nf
        {
            return legend;
        }
.fi
.SS "\fBString\fP [] \fBgetNames\fP ()\fC [inline, inherited]\fP"
.PP
References Property\&.getName(), and Property\&.isVisible()\&.
.PP
.nf
        {
                List names = new ArrayList();
                Iterator it = values()\&.iterator();
                while (it\&.hasNext())
                {
                        Property p = (Property)it\&.next();
                        if (p\&.isVisible())
                                names\&.add(p\&.getName());
                }
                return (String[])names\&.toArray(new String[names\&.size()]);
        }
.fi
.SS "Rectangle \fBgetOuterBoundingBox\fP ()\fC [inline, package, inherited]\fP"
.PP
References Utils\&.convertPosition(), VectorProperty\&.getArray(), AxesObject\&.getCanvas(), RenderCanvas\&.getComponent(), RadioProperty\&.getValue(), AxesObject\&.OuterPosition, and AxesObject\&.Units\&.
.PP
.nf
        {
                double[] pos = Utils\&.convertPosition(OuterPosition\&.getArray(), Units\&.getValue(), 'pixels', getCanvas()\&.getComponent());
                return new Rectangle((int)(pos[0]-1), (int)(pos[1]-1), (int)pos[2], (int)pos[3]);
        }
.fi
.SS "\fBProperty\fP \fBgetProperty\fP (Stringname)\fC [inline, inherited]\fP"
.PP
Referenced by AxesObject\&.childValidated(), AxesObject\&.draw(), PropertySet\&.get(), AxesObject\&.getChildrenLimits(), HandleObject\&.getDefaultProperty(), OctaveSink\&.OctaveSink(), PropertySet\&.set(), and HandleObject\&.waitFor()\&.
.PP
.nf
        {
                return (Property)get((Object)name\&.toLowerCase());
        }
.fi
.SS "double \fBgetTickInterval\fP (double[]lim, intnMax)\fC [inline, protected, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAxis()\&.
.PP
.nf
        {
                double range = (lim[1]-lim[0]);
                double power = Math\&.pow(10, Math\&.floor(Math\&.log10(range)));
                double ndec = range/power;
                double ntickdec = nMax/ndec;
                double tick;

                if (ntickdec > 40)
                        tick = 0\&.05;
                else if (ntickdec > 20)
                        tick = 0\&.1;
                else if (ntickdec > 10)
                        tick = 0\&.2;
                else if (ntickdec > 4)
                        tick = 0\&.5;
                else if (ntickdec > 1\&.5)
                        tick = 1;
                else if (ntickdec > 0\&.5)
                        tick = 2;
                else
                        tick = Math\&.ceil(ndec);

                return (tick*power);
        }
.fi
.SS "\fBString\fP \fBgetType\fP ()\fC [inline, inherited]\fP"
.PP
References StringProperty\&.toString(), and HandleObject\&.Type\&.
.PP
Referenced by Property\&.initDefault()\&.
.PP
.nf
        {
                return (Type != null ? Type\&.toString() : '');
        }
.fi
.SS "boolean \fBhasHandleEvent\fP (Stringname)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSource\fP\&.
.PP
References HandleObject\&.eventSource, and HandleEventSourceHelper\&.hasHandleEvent()\&.
.PP
Referenced by OctaveSink\&.OctaveSink()\&.
.PP
.nf
        {
                return eventSource\&.hasHandleEvent(name);
        }
.fi
.SS "boolean \fBhasProperty\fP (Stringname)\fC [inline, inherited]\fP"
.PP
Referenced by AxesObject\&.draw()\&.
.PP
.nf
        {
                return containsKey(name\&.toLowerCase());
        }
.fi
.SS "void \fBinitProperties\fP (\fBHandleObject\fPparent, Stringtype)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.addChild(), HandleObjectListProperty\&.addElement(), HandleObject\&.BeingDeleted, HandleObject\&.ButtonDownFcn, HandleObject\&.Children, HandleObject\&.Clipping, HandleObject\&.CreateFcn, HandleObject\&.DeleteFcn, HandleObject\&.HandleVisibility, HandleObject\&.Parent, HandleObject\&.Tag, HandleObject\&.Type, HandleObject\&.UserData, and HandleObject\&.Visible\&.
.PP
Referenced by HandleObject\&.HandleObject()\&.
.PP
.nf
        {
                // These properties must be created first, in order to
                // get correct behavior when looking for default values
                // of properties
                Type = new StringProperty(this, 'Type', type);
                Parent = new HandleObjectListProperty(this, 'Parent', -1);
                if (parent != null)
                        Parent\&.addElement(parent);

                // Create other properties
                BeingDeleted = new BooleanProperty(this, 'BeingDeleted', false);
                ButtonDownFcn = new CallbackProperty(this, 'ButtonDownFcn', (String)null);
                Children = new HandleObjectListProperty(this, 'Children', -1);
                Clipping = new BooleanProperty(this, 'Clipping', true);
                CreateFcn = new CallbackProperty(this, 'CreateFcn', (String)null);
                DeleteFcn = new CallbackProperty(this, 'DeleteFcn', (String)null);
                HandleVisibility = new RadioProperty(this, 'HandleVisibility', new String[] {'on', 'callback', 'off'}, 'on');
                Tag = new StringProperty(this, 'Tag', '');
                UserData = new ObjectProperty(this, 'UserData', null);
                Visible = new BooleanProperty(this, 'Visible', true);

                // TODO: move this to validate() ??
                if (parent != null)
                        parent\&.addChild(this);
        }
.fi
.SS "boolean \fBisAutoMode\fP ()\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.autoMode\&.
.PP
Referenced by ColorbarObject\&.propertyChanged(), FigureObject\&.propertyChanged(), LegendObject\&.propertyChanged(), and PatchObject\&.propertyChanged()\&.
.PP
.nf
        {
                return (autoMode > 0);
        }
.fi
.SS "static boolean \fBisHandle\fP (doublehandle)\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
Referenced by TextProperty\&.convertValue(), RootObject\&.createNewFigure(), and RootObject\&.getUnusedFigureNumber()\&.
.PP
.nf
        {
                WeakReference ref = (WeakReference)handleMap\&.get(new Double(handle));
                if (ref != null && ref\&.get() != null)
                        return true;
                return false;
        }
.fi
.SS "boolean \fBisLegendable\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBGraphicObject\fP, and \fBBaseLineObject\fP\&.
.PP
Referenced by AxesObject\&.autoLegend(), and LegendObject\&.buildLegend()\&.
.PP
.nf
        {
                return false;
        }
.fi
.SS "boolean \fBisValid\fP ()\fC [inline, inherited]\fP"
.PP
References HandleObject\&.valid\&.
.PP
Referenced by HandleObject\&.addProperty(), AxesObject\&.childValidated(), UIControlObject\&.controlActivated(), AxesContainer\&.display(), AxesContainer\&.getObjectForPoint(), and AxesContainer\&.reshape()\&.
.PP
.nf
        {
                return valid;
        }
.fi
.SS "void \fBlisten\fP (\fBProperty\fPp)\fC [inline, protected, inherited]\fP"
.PP
References Property\&.addHandleEventSink(), HandleObject\&.eventSourceSet, and Property\&.getParent()\&.
.PP
Referenced by AxesObject\&.AxesObject(), BarseriesObject\&.BarseriesObject(), BaseLineObject\&.BaseLineObject(), GroupObject\&.childValidated(), AxesObject\&.childValidated(), ColorbarObject\&.ColorbarObject(), FigureObject\&.FigureObject(), ImageObject\&.ImageObject(), LegendObject\&.LegendObject(), LineObject\&.LineObject(), PatchObject\&.PatchObject(), RootObject\&.RootObject(), SurfaceObject\&.SurfaceObject(), TextObject\&.TextObject(), UIControlObject\&.UIControlObject(), and UIPanelObject\&.UIPanelObject()\&.
.PP
.nf
        {
                p\&.addHandleEventSink('PropertyChanged', this);
                if (p\&.getParent() != this)
                        eventSourceSet\&.add(p);
        }
.fi
.SS "static void \fBlistObjects\fP ()\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap, and HandleObject\&.HandleObject()\&.
.PP
.nf
        {
                Iterator it = handleMap\&.entrySet()\&.iterator();
                while (it\&.hasNext())
                {
                        Map\&.Entry entry = (Map\&.Entry)it\&.next();
                        HandleObject hObj = (HandleObject)((WeakReference)entry\&.getValue())\&.get();
                        System\&.out\&.println(entry\&.getKey() + ' = ' + hObj\&.getClass());
                }
        }
.fi
.SS "\fBColorbarObject\fP \fBmakeColorbar\fP (booleanmode)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.colorbar, ColorbarObject\&.delete(), and AxesObject\&.validate()\&.
.PP
.nf
        {
                if (colorbar == null && mode)
                {
                        colorbar = new ColorbarObject(this);
                        colorbar\&.validate();
                }
                else if (!mode && colorbar != null)
                {
                        colorbar\&.delete();
                        colorbar = null;
                }
                return colorbar;
        }
.fi
.SS "\fBLegendItem\fP \fBmakeItemFromLine\fP (\fBHandleObject\fPline, \fBString\fPname)\fC [inline, private]\fP"
.PP
References TextObject\&.FontAngle, TextObject\&.FontName, TextObject\&.FontSize, TextObject\&.FontUnits, TextObject\&.FontWeight, Property\&.get(), HandleObject\&.get(), LegendObject\&.LegendItem\&.line, LineObject\&.LineColor, LineObject\&.LineStyle, LineObject\&.LineWidth, LegendObject\&.LegendItem\&.marker, LineObject\&.Marker, LineObject\&.MarkerEdgeColor, LineObject\&.MarkerFaceColor, LegendObject\&.LegendItem\&.name, Property\&.reset(), LegendObject\&.LegendItem\&.text, TextObject\&.TextColor, LegendObject\&.TextColor, LineObject\&.validate(), TextObject\&.validate(), and TextObject\&.VAlign\&.
.PP
Referenced by LegendObject\&.buildLegend()\&.
.PP
.nf
        {
                LegendItem item = new LegendItem();
                item\&.name = name;

                try
                {
                        item\&.text = new TextObject(this, name, new double[] {0, 0, 0});
                        item\&.text\&.VAlign\&.reset('middle');
                        item\&.text\&.TextColor\&.reset(TextColor\&.get());
                        item\&.text\&.FontName\&.reset(this\&.get('FontName'));
                        item\&.text\&.FontSize\&.reset(this\&.get('FontSize'));
                        item\&.text\&.FontUnits\&.reset(this\&.get('FontUnits'));
                        item\&.text\&.FontWeight\&.reset(this\&.get('FontWeight'));
                        item\&.text\&.FontAngle\&.reset(this\&.get('FontAngle'));
                        item\&.text\&.validate();

                        item\&.line = new LineObject(this);
                        item\&.line\&.LineColor\&.reset(line\&.get('Color'));
                        item\&.line\&.LineStyle\&.reset(line\&.get('LineStyle'));
                        item\&.line\&.LineWidth\&.reset(line\&.get('LineWidth'));
                        item\&.line\&.validate();

                        item\&.marker = new LineObject(this);
                        item\&.marker\&.LineColor\&.reset(line\&.get('Color'));
                        item\&.marker\&.LineStyle\&.reset('none');
                        item\&.marker\&.Marker\&.reset(line\&.get('Marker'));
                        item\&.marker\&.MarkerEdgeColor\&.reset(line\&.get('MarkerEdgeColor'));
                        item\&.marker\&.MarkerFaceColor\&.reset(line\&.get('MarkerFaceColor'));
                        item\&.marker\&.validate();
                }
                catch (PropertyException e) {}

                return item;
        }
.fi
.SS "\fBLegendObject\fP \fBmakeLegend\fP (Stringnames[])\fC [inline, inherited]\fP"
.PP
References LegendObject\&.buildLegend(), HandleObject\&.delete(), AxesObject\&.legend, LegendObject\&.size, and AxesObject\&.validate()\&.
.PP
Referenced by AxesObject\&.autoLegend()\&.
.PP
.nf
        {
                if (names == null || names\&.length == 0)
                {
                        if (legend != null)
                        {
                                legend\&.delete();
                                legend = null;
                        }
                }
                else
                {
                        if (legend == null)
                        {
                                legend = new LegendObject(this, names);
                                legend\&.validate();
                        }
                        else
                                legend\&.buildLegend(this, names);
                        if (legend\&.size() == 0)
                        {
                                legend\&.delete();
                                legend = null;
                        }
                }
                return legend;
        }
.fi
.SS "static double \fBnewHandle\fP ()\fC [inline, static, protected, inherited]\fP"
.PP
References HandleObject\&.handleSeed\&.
.PP
Referenced by HandleObject\&.HandleObject(), UIPanelObject\&.UIPanelObject(), and FigureObject\&.updateHandle()\&.
.PP
.nf
        {
                double h = handleSeed;
                handleSeed = Math\&.ceil(handleSeed) - 1 - Math\&.random();
                return h;
        }
.fi
.SS "void \fBoperation\fP (intop, MouseEvente)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.boundingBox, AxesObject\&.drawZoomBox(), VectorProperty\&.getArray(), AxesObject\&.getCanvas(), AxesContainer\&.OP_ROTATE, AxesContainer\&.OP_ZOOM, RenderCanvas\&.redraw(), AxesObject\&.View, AxesObject\&.xPrev, AxesObject\&.yPrev, and AxesObject\&.zoomBox\&.
.PP
Referenced by AxesContainer\&.mouseDragged()\&.
.PP
.nf
        {
                switch (op)
                {
                        case FigureObject\&.OP_ROTATE:
                                double new_anglex = View\&.getArray()[1], new_anglez = View\&.getArray()[0];

                                // TODO: use actual axes size
                                new_anglez += (xPrev-e\&.getX()) * (180\&.0/boundingBox\&.width);
                                new_anglex += (e\&.getY()-yPrev) * (180\&.0/boundingBox\&.height);

                                // clipping
                                if (new_anglex > 90) new_anglex = 90;
                                else if (new_anglex < -90) new_anglex = -90;
                                if (new_anglez > 180) new_anglez -= 360;
                                else if (new_anglez < -180) new_anglez += 360;

                                // snapping
                                double margin = 1;
                                for (int alpha = -90; alpha <= 90; alpha += 90)
                                        if (alpha-margin < new_anglex && new_anglex < alpha+margin)
                                                new_anglex = alpha;
                                for (int alpha = -180; alpha <= 180; alpha += 90)
                                        if (alpha-margin < new_anglez && new_anglez < alpha+margin)
                                                if (alpha == 180)
                                                        new_anglez = -180;
                                                else
                                                        new_anglez = alpha;

                                try { set(View, new double[] {new_anglez, new_anglex}); }
                                catch (PropertyException ex) {}
                                xPrev = e\&.getX();
                                yPrev = e\&.getY();

                                getCanvas()\&.redraw();
                                break;
                        case FigureObject\&.OP_ZOOM:
                                if (zoomBox)
                                {
                                        drawZoomBox(xPrev, yPrev, e\&.getX(), e\&.getY());
                                        xPrev = e\&.getX();
                                        yPrev = e\&.getY();
                                }
                                break;
                }
        }
.fi
.SS "void \fBpropertyChanged\fP (\fBProperty\fPp)  throws \fBPropertyException\fP 	\fC [inline]\fP"
.PP
Reimplemented from \fBAxesObject\fP\&.
.PP
References HandleObject\&.autoMode, LegendObject\&.axes, LegendObject\&.doLayout(), LegendObject\&.doLocate(), LegendObject\&.EdgeColor, Property\&.get(), StringArrayProperty\&.getArray(), HandleObject\&.isAutoMode(), LegendObject\&.items, LegendObject\&.Location, LegendObject\&.Orientation, AxesObject\&.OuterPosition, AxesObject\&.Position, GraphicObject\&.set(), Property\&.set(), LegendObject\&.String, LegendObject\&.LegendItem\&.text, LegendObject\&.TextColor, AxesObject\&.updateActivePosition(), AxesObject\&.XColor, AxesObject\&.YColor, and AxesObject\&.ZColor\&.
.PP
.nf
        {
                super\&.propertyChanged(p);

                if (p == EdgeColor)
                {
                        Object c = EdgeColor\&.get();
                        XColor\&.set(c);
                        YColor\&.set(c);
                        ZColor\&.set(c);
                }
                else if (p == TextColor)
                {
                        for (int i=0; i<items\&.length; i++)
                                items[i]\&.text\&.set('Color', TextColor\&.get());
                }
                else if (p == String)
                {
                        String[] s = String\&.getArray();
                        for (int i=0; i<items\&.length; i++)
                                if (i < s\&.length)
                                        items[i]\&.text\&.set('String', s[i]);
                                else
                                        items[i]\&.text\&.set('String', '');
                        doLayout();
                        doLocate();

                        String[] used_names = new String[Math\&.min(s\&.length, items\&.length)];
                        System\&.arraycopy(s, 0, used_names, 0, used_names\&.length);
                        String\&.set(used_names);
                }
                else if (!isAutoMode() && (p == axes\&.Position || p == axes\&.OuterPosition))
                        doLocate();
                else if (p == Location)
                {
                        autoMode++;
                        axes\&.updateActivePosition();
                        autoMode--;
                        doLocate();
                }
                else if (p == Orientation)
                {
                        doLayout();
                        doLocate();
                }
        }
.fi
.SS "void \fBremoveChild\fP (\fBHandleObject\fPchild)\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBHandleObject\fP\&.
.PP
References AxesObject\&.autoAspectRatio(), AxesObject\&.autoCamera(), AxesObject\&.autoLegend(), AxesObject\&.autoScale(), AxesObject\&.autoScaleC(), AxesObject\&.baseLine, HandleObject\&.BeingDeleted, AxesObject\&.colorbar, BooleanProperty\&.isSet(), AxesObject\&.legend, AxesObject\&.removeChild(), and AxesObject\&.updateActivePosition()\&.
.PP
Referenced by ColorbarObject\&.delete(), and AxesObject\&.removeChild()\&.
.PP
.nf
        {
                if (child == baseLine)
                        baseLine = null;
                else if (child == legend)
                        legend = null;
                else if (child == colorbar)
                {
                        updateActivePosition();
                        colorbar = null;
                }

                super\&.removeChild(child);

                if (!BeingDeleted\&.isSet())
                {
                        autoScale();
                        autoScaleC();
                        autoAspectRatio();
                        autoCamera();
                        autoLegend();
                }
        }
.fi
.SS "void \fBremoveHandleEventSink\fP (\fBHandleEventSink\fPsink)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSource\fP\&.
.PP
References HandleObject\&.eventSource, and HandleEventSourceHelper\&.removeHandleEventSink()\&.
.PP
Referenced by HandleObject\&.delete()\&.
.PP
.nf
        {
                eventSource\&.removeHandleEventSink(sink);
        }
.fi
.SS "static void \fBremoveHandleObject\fP (doublehandle)\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
Referenced by HandleObject\&.delete(), and HandleObject\&.setHandle()\&.
.PP
.nf
        {
                handleMap\&.remove(new Double(handle));
        }
.fi
.SS "void \fBreset\fP (Stringmode)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.ALim, AxesObject\&.ALimMode, AxesObject\&.autoAspectRatio(), AxesObject\&.autoCamera(), AxesObject\&.autoTick(), AxesObject\&.AxesColor, AxesObject\&.Box, AxesObject\&.CameraPosition, AxesObject\&.CameraPositionMode, AxesObject\&.CameraTarget, AxesObject\&.CameraTargetMode, AxesObject\&.CameraUpVector, AxesObject\&.CameraUpVectorMode, AxesObject\&.CameraViewAngle, AxesObject\&.CameraViewAngleMode, AxesObject\&.CLim, AxesObject\&.CLimMode, AxesObject\&.DataAspectRatio, AxesObject\&.DataAspectRatioMode, AxesObject\&.deleteChildren(), HandleObject\&.getHandle(), AxesObject\&.GridLineStyle, AxesObject\&.Key, AxesObject\&.Layer, AxesObject\&.makeTextObject(), AxesObject\&.MinorGridLineStyle, AxesObject\&.PlotBoxAspectRatio, AxesObject\&.PlotBoxAspectRatioMode, AxesObject\&.Projection, Property\&.reset(), AxesObject\&.TickDir, AxesObject\&.TickDirMode, AxesObject\&.Title, AxesObject\&.updateActivePosition(), AxesObject\&.View, HandleObject\&.Visible, AxesObject\&.XAxisLocation, AxesObject\&.XColor, AxesObject\&.XDir, AxesObject\&.XGrid, AxesObject\&.XLabel, AxesObject\&.XLim, AxesObject\&.XLimMode, AxesObject\&.XMinorGrid, AxesObject\&.XMinorTick, AxesObject\&.XScale, AxesObject\&.XTick, AxesObject\&.XTickLabel, AxesObject\&.XTickLabelMode, AxesObject\&.XTickMode, AxesObject\&.YAxisLocation, AxesObject\&.YColor, AxesObject\&.YDir, AxesObject\&.YGrid, AxesObject\&.YLabel, AxesObject\&.YLim, AxesObject\&.YLimMode, AxesObject\&.YMinorGrid, AxesObject\&.YMinorTick, AxesObject\&.YScale, AxesObject\&.YTick, AxesObject\&.YTickLabel, AxesObject\&.YTickLabelMode, AxesObject\&.YTickMode, AxesObject\&.ZColor, AxesObject\&.ZDir, AxesObject\&.ZGrid, AxesObject\&.ZLabel, AxesObject\&.ZLim, AxesObject\&.ZLimMode, AxesObject\&.ZMinorGrid, AxesObject\&.ZMinorTick, AxesObject\&.ZScale, AxesObject\&.ZTick, AxesObject\&.ZTickLabel, AxesObject\&.ZTickLabelMode, and AxesObject\&.ZTickMode\&.
.PP
.nf
        {
                deleteChildren();

                Projection\&.reset('orthogonal');
                AxesColor\&.reset(Color\&.white);
                XColor\&.reset(Color\&.black);
                YColor\&.reset(Color\&.black);
                ZColor\&.reset(Color\&.black);
                XLim\&.reset(new double[] {0, 1});
                YLim\&.reset(new double[] {0, 1});
                ZLim\&.reset(new double[] {-0\&.5, 0\&.5});
                XLimMode\&.reset('auto');
                YLimMode\&.reset('auto');
                ZLimMode\&.reset('auto');
                XGrid\&.reset(new Boolean(false));
                YGrid\&.reset(new Boolean(false));
                ZGrid\&.reset(new Boolean(false));
                XTick\&.reset(new double[0]);
                YTick\&.reset(new double[0]);
                ZTick\&.reset(new double[0]);
                XTickMode\&.reset('auto');
                YTickMode\&.reset('auto');
                ZTickMode\&.reset('auto');
                XTickLabel\&.reset(new String[0]);
                YTickLabel\&.reset(new String[0]);
                ZTickLabel\&.reset(new String[0]);
                XTickLabelMode\&.reset('auto');
                YTickLabelMode\&.reset('auto');
                ZTickLabelMode\&.reset('auto');
                TickDir\&.reset('in');
                TickDirMode\&.reset('auto');
                CameraTarget\&.reset(new double[] {0, 0, 0});
                CameraTargetMode\&.reset('auto');
                CameraPosition\&.reset(new double[] {0, 0, 0});
                CameraPositionMode\&.reset('auto');
                CameraUpVector\&.reset(new double[] {0, 1, 0});
                CameraUpVectorMode\&.reset('auto');
                CameraViewAngle\&.reset(new Double(10));
                CameraViewAngleMode\&.reset('auto');
                DataAspectRatio\&.reset(new double[] {1, 1, 1});
                DataAspectRatioMode\&.reset('auto');
                PlotBoxAspectRatio\&.reset(new double[] {1, 1, 1});
                PlotBoxAspectRatioMode\&.reset('auto');
                View\&.reset(new double[] {0, 90});
                Title\&.reset('');
                XLabel\&.reset('');
                YLabel\&.reset('');
                ZLabel\&.reset('');
                CLim\&.reset(new double[] {0, 1});
                CLimMode\&.reset('auto');
                ALim\&.reset(new double[] {0, 1});
                ALimMode\&.reset('auto');
                Box\&.reset(new Boolean(true));
                XDir\&.reset('normal');
                YDir\&.reset('normal');
                ZDir\&.reset('normal');
                XScale\&.reset('linear');
                YScale\&.reset('linear');
                ZScale\&.reset('linear');
                GridLineStyle\&.reset(':');
                MinorGridLineStyle\&.reset(':');
                XMinorTick\&.reset(new Boolean(false));
                YMinorTick\&.reset(new Boolean(false));
                ZMinorTick\&.reset(new Boolean(false));
                XMinorGrid\&.reset(new Boolean(false));
                YMinorGrid\&.reset(new Boolean(false));
                ZMinorGrid\&.reset(new Boolean(false));
                XAxisLocation\&.reset('bottom');
                YAxisLocation\&.reset('left');
                Layer\&.reset('bottom');
                Visible\&.reset(new Boolean(true));
                Key\&.reset(new Boolean(false));

                Title\&.reset(new Double(makeTextObject('center', 'bottom')\&.getHandle()));
                XLabel\&.reset(new Double(makeTextObject('center', 'top')\&.getHandle()));
                YLabel\&.reset(new Double(makeTextObject('center', 'bottom')\&.getHandle()));
                ZLabel\&.reset(new Double(makeTextObject('center', 'bottom')\&.getHandle()));

                updateActivePosition();
                autoTick();
                autoAspectRatio();
                autoCamera();
        }
.fi
.SS "void \fBset\fP (\fBProperty\fPp, Objectvalue)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Reimplemented in \fBUIControlObject\fP, and \fBGraphicObject\fP\&.
.PP
.nf
        {
                p\&.set(value);
        }
.fi
.SS "void \fBset\fP (Stringname, Objectvalue)  throws \fBPropertyException\fP 	\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBPropertySet\fP\&.
.PP
References PropertySet\&.addProperty(), Property\&.cloneProperty(), HandleObject\&.defaultSet, HandleObject\&.getDefaultProperty(), and Property\&.set()\&.
.PP
.nf
        {
                if (name\&.toLowerCase()\&.startsWith('default'))
                {
                        Property p = getDefaultProperty(name);
                        if (p != null)
                        {
                                Property new_p = p\&.cloneProperty();
                                new_p\&.set(value);
                                defaultSet\&.addProperty(new_p);
                        }
                        else
                                throw new PropertyException('invalid default property - ' + name\&.toLowerCase());
                }
                else
                        super\&.set(name, value);
        }
.fi
.SS "void \fBsetCachedData\fP (Renderer\&.CachedDatad)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.cachedData\&.
.PP
Referenced by GLRenderer\&.draw(), and SurfaceObject\&.propertyChanged()\&.
.PP
.nf
        {
                if (cachedData != null)
                        cachedData\&.dispose();
                cachedData = d;
        }
.fi
.SS "void \fBsetHandle\fP (doublehandle)\fC [inline, protected, inherited]\fP"
.PP
References HandleObject\&.addHandleObject(), HandleObject\&.getHandle(), HandleObject\&.handle, and HandleObject\&.removeHandleObject()\&.
.PP
Referenced by FigureObject\&.updateHandle()\&.
.PP
.nf
        {
                removeHandleObject(getHandle());
                this\&.handle = handle;
                addHandleObject(getHandle(), this);
        }
.fi
.SS "void \fBsetInternalPosition\fP (double[]p)\fC [inline, protected, inherited]\fP"
.PP
References AxesObject\&.autoAspectRatio(), AxesObject\&.autoCamera(), HandleObject\&.autoSet(), AxesObject\&.autoTick(), and AxesObject\&.Position\&.
.PP
Referenced by ColorbarObject\&.doLocate(), and LegendObject\&.doLocate()\&.
.PP
.nf
        {
                autoSet(Position, p);
                autoTick();
                autoAspectRatio();
                autoCamera();
        }
.fi
.SS "void \fBshow\fP ()\fC [inline, inherited]\fP"
.PP
References Property\&.getName(), and Property\&.isVisible()\&.
.PP
.nf
        {
                Iterator it = values()\&.iterator();
                while (it\&.hasNext())
                {
                        Property p = (Property)it\&.next();
                        if (p\&.isVisible())
                        {
                                get(p); /* force any getter to execute */
                                System\&.out\&.println('  ' + p\&.getName() + ' = ' + p);
                        }
                }
        }
.fi
.SS "static void \fBshutdown\fP ()\fC [inline, static, inherited]\fP"
.PP
References HandleObject\&.handleMap\&.
.PP
.nf
        {
                LinkedList figList = new LinkedList();
                Iterator it = handleMap\&.values()\&.iterator();

                while (it\&.hasNext())
                {
                        WeakReference ref = (WeakReference)it\&.next();
                        if (ref != null && ref\&.get() != null && ref\&.get() instanceof FigureObject)
                                figList\&.add(ref\&.get());
                }

                it = figList\&.iterator();
                while (it\&.hasNext())
                        ((HandleObject)it\&.next())\&.delete();
        }
.fi
.SS "int \fBsize\fP ()\fC [inline]\fP"
.PP
References LegendObject\&.items\&.
.PP
Referenced by LegendObject\&.doLayout(), and LegendObject\&.updateActivePosition()\&.
.PP
.nf
        {
                return (items != null ? items\&.length : 0);
        }
.fi
.SS "void \fBsourceDeleted\fP (Objectsource)\fC [inline, inherited]\fP"
.PP
Implements \fBHandleEventSink\fP\&.
.PP
References HandleObject\&.eventSourceSet\&.
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                eventSourceSet\&.remove(source);
        }
.fi
.SS "void \fBstartOperation\fP (intop, MouseEvente)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.AXE_DEPTH_DIR, AxesObject\&.AXE_HORZ_DIR, AxesObject\&.AXE_VERT_DIR, AxesObject\&.boundingBox, AxesObject\&.drawZoomBox(), AxesObject\&.getBoundingBox(), AxesContainer\&.OP_ROTATE, AxesContainer\&.OP_ZOOM, AxesObject\&.xAnchor, AxesObject\&.xPrev, AxesObject\&.xstate, AxesObject\&.yAnchor, AxesObject\&.yPrev, AxesObject\&.ystate, AxesObject\&.zoomBox, and AxesObject\&.zstate\&.
.PP
Referenced by AxesContainer\&.mousePressed()\&.
.PP
.nf
        {
                xAnchor = xPrev = e\&.getX();
                yAnchor = yPrev = e\&.getY();

                switch (op)
                {
                        case FigureObject\&.OP_ZOOM:
                                // start zoom box only in 2D mode
                                if (zstate == AXE_DEPTH_DIR && xstate == AXE_HORZ_DIR && ystate == AXE_VERT_DIR)
                                {
                                        drawZoomBox(xPrev, yPrev);
                                        zoomBox = true;
                                }
                                break;
                        case FigureObject\&.OP_ROTATE:
                                boundingBox = getBoundingBox();
                                break;
                }
        }
.fi
.SS "void \fBtransform\fP (doublex, doubley, doublez, double[]p, intoffset)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.Scaler\&.scale(), AxesObject\&.sx, AxesObject\&.sy, AxesObject\&.sz, and Matrix3D\&.transform()\&.
.PP
Referenced by AxesObject\&.convertUnits()\&.
.PP
.nf
        {
                x_render\&.transform(sx\&.scale(x), sy\&.scale(y), sz\&.scale(z), p, offset);
        }
.fi
.SS "void \fBunTransform\fP (doublex, doubley, doublez, double[]p, intoffset)\fC [inline, inherited]\fP"
.PP
References AxesObject\&.sx, AxesObject\&.sy, AxesObject\&.sz, Matrix3D\&.transform(), and AxesObject\&.Scaler\&.unscale()\&.
.PP
Referenced by AxesObject\&.convertUnits(), AxesObject\&.doZoom(), and AxesObject\&.draw()\&.
.PP
.nf
        {
                x_renderInv\&.transform(x, y, z, p, offset);
                p[0+offset] = sx\&.unscale(p[0+offset]);
                p[1+offset] = sy\&.unscale(p[1+offset]);
                p[2+offset] = sz\&.unscale(p[2+offset]);
        }
.fi
.SS "void \fBunZoom\fP ()\fC [inline, inherited]\fP"
.PP
References AxesObject\&.autoAspectRatio(), AxesObject\&.autoCamera(), HandleObject\&.autoMode, AxesObject\&.autoTick(), AxesObject\&.getCanvas(), RenderCanvas\&.redraw(), Property\&.set(), AxesObject\&.XLim, AxesObject\&.XLimMode, AxesObject\&.YLim, AxesObject\&.YLimMode, and AxesObject\&.zoomStack\&.
.PP
Referenced by AxesContainer\&.mouseClicked()\&.
.PP
.nf
        {
                if (zoomStack\&.size() >= 4)
                {
                        autoMode++;
                        YLim\&.set(zoomStack\&.pop(), true);
                        YLimMode\&.set(zoomStack\&.pop(), true);
                        XLim\&.set(zoomStack\&.pop(), true);
                        XLimMode\&.set(zoomStack\&.pop(), true);
                        autoMode--;
                        autoTick();
                        autoAspectRatio();
                        autoCamera();
                        getCanvas()\&.redraw();
                }
        }
.fi
.SS "void \fBupdateActivePosition\fP ()\fC [inline, package]\fP"
.PP
Reimplemented from \fBAxesObject\fP\&.
.PP
References Utils\&.convertPosition(), LegendObject\&.doLocate(), VectorProperty\&.getArray(), AxesObject\&.getCanvas(), RenderCanvas\&.getComponent(), RadioProperty\&.getValue(), AxesObject\&.Position, Property\&.set(), LegendObject\&.size(), and AxesObject\&.Units\&.
.PP
.nf
        {
                RenderCanvas canvas = getCanvas();
                double[] pos = Utils\&.convertPosition(Position\&.getArray(), Units\&.getValue(), 'pixels', canvas\&.getComponent());
                pos[2] = size\&.width;
                pos[3] = size\&.height;
                Position\&.set(Utils\&.convertPosition(pos, 'pixels', Units\&.getValue(), canvas\&.getComponent()), true);
                doLocate();
        }
.fi
.SS "void \fBupdateOuterPosition\fP ()\fC [inline, package, inherited]\fP"
.PP
References HandleObject\&.autoSet(), Utils\&.convertPosition(), AxesObject\&.FontAngle, AxesObject\&.FontName, AxesObject\&.FontSize, AxesObject\&.FontUnits, AxesObject\&.FontWeight, VectorProperty\&.getArray(), AxesObject\&.getCanvas(), RenderCanvas\&.getComponent(), Utils\&.getFont(), RenderCanvas\&.getFontMetrics(), RadioProperty\&.getValue(), AxesObject\&.OuterPosition, AxesObject\&.Position, and AxesObject\&.Units\&.
.PP
Referenced by AxesObject\&.propertyChanged(), and AxesObject\&.updateActivePosition()\&.
.PP
.nf
        {
                RenderCanvas canvas = getCanvas();
                double[] p = Utils\&.convertPosition(Position\&.getArray(), Units\&.getValue(), 'pixels', canvas\&.getComponent());
                FontMetrics fm = canvas\&.getFontMetrics(Utils\&.getFont(FontName, FontSize, FontUnits,
                                        FontAngle, FontWeight, p[3]));
                int marginH = 10+fm\&.stringWidth('0000')+fm\&.getHeight()+5+7,
                        marginV = 10+2*fm\&.getHeight()+10+7;
                
                p[0] -= marginH;
                p[1] -= marginV;
                p[2] += 2*marginH;
                p[3] += 2*marginV;
                autoSet(OuterPosition, Utils\&.convertPosition(p, 'pixels', Units\&.getValue(), canvas\&.getComponent()));
        }
.fi
.SS "void \fBupdatePosition\fP ()\fC [inline, package, inherited]\fP"
.PP
References HandleObject\&.autoSet(), Utils\&.convertPosition(), AxesObject\&.FontAngle, AxesObject\&.FontName, AxesObject\&.FontSize, AxesObject\&.FontUnits, AxesObject\&.FontWeight, VectorProperty\&.getArray(), AxesObject\&.getCanvas(), RenderCanvas\&.getComponent(), Utils\&.getFont(), RenderCanvas\&.getFontMetrics(), RadioProperty\&.getValue(), AxesObject\&.OuterPosition, AxesObject\&.Position, and AxesObject\&.Units\&.
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), and AxesObject\&.updateActivePosition()\&.
.PP
.nf
        {
                RenderCanvas canvas = getCanvas();
                double[] p = Utils\&.convertPosition(OuterPosition\&.getArray(), Units\&.getValue(), 'pixels', canvas\&.getComponent());
                FontMetrics fm = canvas\&.getFontMetrics(Utils\&.getFont(FontName, FontSize, FontUnits,
                                        FontAngle, FontWeight, p[3]));
                int marginH = 10+fm\&.stringWidth('0000')+fm\&.getHeight()+5+7,
                        marginV = 10+2*fm\&.getHeight()+10+7;

                p[0] += marginH;
                p[1] += marginV;
                p[2] -= 2*marginH;
                p[3] -= 2*marginV;
                autoSet(Position, Utils\&.convertPosition(p, 'pixels', Units\&.getValue(), canvas\&.getComponent()));
        }
.fi
.SS "void \fBupdateScalers\fP ()\fC [inline, inherited]\fP"
.PP
References RadioProperty\&.is(), AxesObject\&.linScale, AxesObject\&.logScale, AxesObject\&.sx, AxesObject\&.sy, AxesObject\&.sz, AxesObject\&.XScale, AxesObject\&.YScale, and AxesObject\&.ZScale\&.
.PP
Referenced by AxesObject\&.updateXFormMatrices()\&.
.PP
.nf
        {
                sx = (XScale\&.is('linear') ? linScale : logScale);
                sy = (YScale\&.is('linear') ? linScale : logScale);
                sz = (ZScale\&.is('linear') ? linScale : logScale);
        }
.fi
.SS "void \fBupdateXFormMatrices\fP ()\fC [inline, inherited]\fP"xd
.PP
yd
.PP
zd 
.PP
References Vector3D\&.add(), HandleObject\&.autoSet(), AxesObject\&.CameraPosition, AxesObject\&.CameraPositionMode, AxesObject\&.CameraTarget, AxesObject\&.CameraTargetMode, AxesObject\&.CameraUpVector, AxesObject\&.CameraUpVectorMode, AxesObject\&.CameraViewAngle, AxesObject\&.CameraViewAngleMode, Vector3D\&.cross(), AxesObject\&.DataAspectRatioMode, Vector3D\&.dot(), DoubleProperty\&.doubleValue(), Matrix3D\&.eye(), Vector3D\&.get(), VectorProperty\&.getArray(), AxesObject\&.getBoundingBox(), AxesObject\&.getCanvas(), Vector3D\&.getData(), Matrix3D\&.getData(), RenderCanvas\&.getHeight(), Matrix3D\&.inv(), RadioProperty\&.is(), Matrix3D\&.mult(), Vector3D\&.norm(), Vector3D\&.normalize(), AxesObject\&.PlotBoxAspectRatio, AxesObject\&.PlotBoxAspectRatioMode, Property\&.reset(), AxesObject\&.Scaler\&.scale(), Matrix3D\&.scale(), Vector3D\&.scale(), Vector3D\&.sub(), AxesObject\&.sx, AxesObject\&.sy, AxesObject\&.sz, Vector3D\&.transform(), Matrix3D\&.transform(), Matrix3D\&.translate(), AxesObject\&.updateScalers(), AxesObject\&.View, AxesObject\&.x_NormRenderTransform, AxesObject\&.x_ProjectionTransform, AxesObject\&.x_RenderTransform, AxesObject\&.x_ViewportTransform, AxesObject\&.x_ViewTransform, AxesObject\&.XDir, AxesObject\&.XLim, AxesObject\&.YDir, AxesObject\&.YLim, AxesObject\&.ZDir, and AxesObject\&.ZLim\&.
.PP
Referenced by AxesObject\&.autoCamera()\&.
.PP
.nf
        {
                updateScalers();

                RenderCanvas canvas = getCanvas();
                double xd = (XDir\&.is('normal') ? 1 : -1);
                double yd = (YDir\&.is('normal') ? 1 : -1);
                double zd = (ZDir\&.is('normal') ? 1 : -1);

                double[] xlim = sx\&.scale(XLim\&.getArray());
                double[] ylim = sy\&.scale(YLim\&.getArray());
                double[] zlim = sz\&.scale(ZLim\&.getArray());

                double xo = xlim[xd > 0 ? 0 : 1];
                double yo = ylim[yd > 0 ? 0 : 1];
                double zo = zlim[zd > 0 ? 0 : 1];

                double[] pb = PlotBoxAspectRatio\&.getArray();

                boolean autocam = CameraPositionMode\&.is('auto') &&
                                CameraTargetMode\&.is('auto') && CameraUpVectorMode\&.is('auto') &&
                                CameraViewAngleMode\&.is('auto');
                boolean dowarp = autocam && DataAspectRatioMode\&.is('auto') &&
                                PlotBoxAspectRatioMode\&.is('auto');

                Vector3D c_eye;
                Vector3D c_center;
                Vector3D c_upv;

                if (CameraTargetMode\&.is('auto'))
                {
                        double[] p = new double[] {(xlim[0]+xlim[1])/2, (ylim[0]+ylim[1])/2, (zlim[0]+zlim[1])/2};
                        c_center = new Vector3D(p);
                        autoSet(CameraTarget, p);
                }
                else
                        c_center = new Vector3D(CameraTarget\&.getArray());

                if (CameraPositionMode\&.is('auto'))
                {
                        double az = View\&.getArray()[0];
                        double el = View\&.getArray()[1];
                        double d = 5*Math\&.sqrt(pb[0]*pb[0]+pb[1]*pb[1]+pb[2]*pb[2]);

                        if (el == 90 || el == -90)
                                c_eye = new Vector3D(new double[] {0, 0, d*Math\&.signum(el)});
                        else
                        {
                                az *= Math\&.PI/180\&.0;
                                el *= Math\&.PI/180\&.0;
                                c_eye = new Vector3D(new double[] {
                                        d*Math\&.cos(el)*Math\&.sin(az),
                                        -d*Math\&.cos(el)*Math\&.cos(az),
                                        d*Math\&.sin(el)}, false);
                        }
                        c_eye\&.scale((xlim[1]-xlim[0])/(xd*pb[0]), (ylim[1]-ylim[0])/(yd*pb[1]), (zlim[1]-zlim[0])/(zd*pb[2]));
                        c_eye\&.add(c_center);
                        autoSet(CameraPosition, c_eye\&.getData()\&.clone());
                }
                else
                        c_eye = new Vector3D(CameraPosition\&.getArray());

                if (CameraUpVectorMode\&.is('auto'))
                {
                        double az = View\&.getArray()[0];
                        double el = View\&.getArray()[1];

                        if (el == 90 || el == -90)
                        {
                                c_upv = new Vector3D(new double[] {
                                        -Math\&.sin(az*Math\&.PI/180\&.0),
                                        Math\&.cos(az*Math\&.PI/180\&.0),
                                        0});
                                c_upv\&.scale((xlim[1]-xlim[0])/(/*xd**/pb[0]), (ylim[1]-ylim[0])/(/*yd**/pb[1]), 0);
                        }
                        else
                                c_upv = new Vector3D(new double[] {0,0,1}, false);
                        autoSet(CameraUpVector, c_upv\&.getData()\&.clone());
                }
                else
                        c_upv = new Vector3D(CameraUpVector\&.getArray());

                x_view\&.eye();
                x_projection\&.eye();
                x_viewport\&.eye();
                x_normrender\&.eye();
                x_render\&.eye();

                Matrix3D x_pre = new Matrix3D();

                x_pre\&.scale(pb[0], pb[1], pb[2]);
                x_pre\&.translate(-0\&.5, -0\&.5, -0\&.5);
                x_pre\&.scale(xd/(xlim[1]-xlim[0]), yd/(ylim[1]-ylim[0]), zd/(zlim[1]-zlim[0]));
                x_pre\&.translate(-xo, -yo, -zo);

                c_eye\&.transform(x_pre);
                c_center\&.transform(x_pre);
                c_upv\&.scale(
                        pb[0]/(xlim[1]-xlim[0]),
                        pb[1]/(ylim[1]-ylim[0]),
                        pb[2]/(zlim[1]-zlim[0]));
                c_center\&.sub(c_eye);

                Vector3D F = c_center;
                Vector3D f = Vector3D\&.normalize(F);
                Vector3D UP = Vector3D\&.normalize(c_upv);

                if (Math\&.abs(Vector3D\&.dot(f, UP)) > 1e-15)
                {
                        double fa = 1/Math\&.sqrt(1-f\&.get(2)*f\&.get(2));
                        UP\&.scale(fa, fa, fa);
                }

                Vector3D s = Vector3D\&.cross(f, UP);
                Vector3D u = Vector3D\&.cross(s, f);

                x_view\&.scale(1, 1, -1);
                x_view\&.mult(
                        new double[] {
                                s\&.get(0), u\&.get(0), -f\&.get(0), 0,
                                s\&.get(1), u\&.get(1), -f\&.get(1), 0,
                                s\&.get(2), u\&.get(2), -f\&.get(2), 0,
                                0, 0, 0, 1});
                x_view\&.translate(-c_eye\&.get(0), -c_eye\&.get(1), -c_eye\&.get(2));
                x_view\&.scale(pb[0], pb[1], pb[2]);
                x_view\&.translate(-0\&.5, -0\&.5, -0\&.5);

                double[] unitCube = {
                        0,0,0,1,
                        1,0,0,1,
                        0,1,0,1,
                        0,0,1,1,
                        1,1,0,1,
                        1,0,1,1,
                        0,1,1,1,
                        1,1,1,1};
                double[] xUnitCube = new double[32];
                double xm = Double\&.POSITIVE_INFINITY, xM = Double\&.NEGATIVE_INFINITY;
                double ym = Double\&.POSITIVE_INFINITY, yM = Double\&.NEGATIVE_INFINITY;
                x_view\&.transform(unitCube, xUnitCube, 8, 0, 0);
                for (int i=0; i<8; i++)
                {
                        if (xUnitCube[i*4] < xm) xm = xUnitCube[i*4];
                        else if (xUnitCube[i*4] > xM) xM = xUnitCube[i*4];
                        if (xUnitCube[i*4+1] < ym) ym = xUnitCube[i*4+1];
                        else if (xUnitCube[i*4+1] > yM) yM = xUnitCube[i*4+1];
                }
                xM -= xm;
                yM -= ym;

                Rectangle bb = getBoundingBox();

                if (CameraViewAngleMode\&.is('auto'))
                {
                        double af;
                        if (dowarp)
                                af = 1/Math\&.max(xM, yM);
                        else
                        {
                                if (((double)bb\&.width)/bb\&.height > xM/yM)
                                        af = 1/yM;
                                else
                                        af = 1/xM;
                        }
                        double ang = 2*(180\&.0/Math\&.PI)*Math\&.atan(1/(2*af*F\&.norm()));
                        autoSet(CameraViewAngle, new Double(ang));
                }

                double pf = 1/(2*Math\&.tan((CameraViewAngle\&.doubleValue()/2)*Math\&.PI/180\&.0)*F\&.norm());
                x_projection\&.scale(pf, pf, 1);

                if (dowarp)
                {
                        xM *= pf;
                        yM *= pf;
                        x_viewport\&.translate(bb\&.x+bb\&.width/2, canvas\&.getHeight()-(bb\&.y+bb\&.height/2)+1, 0);
                        x_viewport\&.scale(bb\&.width/xM, -bb\&.height/yM, 1);
                }
                else
                {
                        double pix = 1;
                        if (autocam)
                        {
                                if (((double)bb\&.width)/bb\&.height > xM/yM)
                                        pix = bb\&.height;
                                else
                                        pix = bb\&.width;
                        }
                        else
                                pix = Math\&.min(bb\&.width, bb\&.height);
                        x_viewport\&.translate(bb\&.x+bb\&.width/2, canvas\&.getHeight()-(bb\&.y+bb\&.height/2)+1, 0);
                        x_viewport\&.scale(pix, -pix, 1);
                }

                x_normrender\&.mult(x_viewport);
                x_normrender\&.mult(x_projection);
                x_normrender\&.mult(x_view);

                x_normrender\&.transform(unitCube, xUnitCube, 8, 0, 0);
                x_zmin = Double\&.POSITIVE_INFINITY;
                x_zmax = Double\&.NEGATIVE_INFINITY;
                for (int i=0; i<8; i++)
                {
                        if (xUnitCube[i*4+2] < x_zmin) x_zmin = xUnitCube[i*4+2];
                        else if (xUnitCube[i*4+2] > x_zmax) x_zmax = xUnitCube[i*4+2];
                }

                //System\&.out\&.println(x_zmin);
                //System\&.out\&.println(x_zmax);

                x_render\&.mult(x_normrender);
                x_render\&.scale(xd/(xlim[1]-xlim[0]), yd/(ylim[1]-ylim[0]), zd/(zlim[1]-zlim[0]));
                x_render\&.translate(-xo, -yo, -zo);
                x_renderInv = x_render\&.inv();

                x_mat1\&.eye();
                x_mat1\&.mult(x_view);
                x_mat1\&.scale(xd/(xlim[1]-xlim[0]), yd/(ylim[1]-ylim[0]), zd/(zlim[1]-zlim[0]));
                x_mat1\&.translate(-xo, -yo, -zo);
                x_mat2\&.eye();
                x_mat2\&.mult(x_viewport);
                x_mat2\&.mult(x_projection);
                
                x_NormRenderTransform\&.reset(new Matrix(x_normrender\&.getData(), new int[] {4, 4}));
                x_RenderTransform\&.reset(new Matrix(x_render\&.getData(), new int[] {4, 4}));
                x_ViewTransform\&.reset(new Matrix(x_view\&.getData(), new int[] {4, 4}));
                x_ProjectionTransform\&.reset(new Matrix(x_projection\&.getData(), new int[] {4, 4}));
                x_ViewportTransform\&.reset(new Matrix(x_viewport\&.getData(), new int[] {4, 4}));
        }
.fi
.SS "void \fBvalidate\fP ()\fC [inline, inherited]\fP"
.PP
Reimplemented from \fBHandleObject\fP\&.
.PP
References AxesObject\&.autoAspectRatio(), AxesObject\&.autoCamera(), AxesObject\&.autoTick(), and AxesObject\&.updateActivePosition()\&.
.PP
Referenced by AxesObject\&.makeColorbar(), and AxesObject\&.makeLegend()\&.
.PP
.nf
        {
                updateActivePosition();
                autoTick();
                autoAspectRatio();
                autoCamera();
                super\&.validate();
        }
.fi
.SS "void \fBwaitFor\fP ()\fC [inline, inherited]\fP"
.PP
Referenced by HandleObject\&.waitFor()\&.
.PP
.nf
        {
                waitFor(null, null, false);
        }
.fi
.SS "void \fBwaitFor\fP (Stringpname)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.waitFor()\&.
.PP
.nf
        {
                waitFor(pname, null, false);
        }
.fi
.SS "void \fBwaitFor\fP (Stringpname, Objectvalue)\fC [inline, inherited]\fP"
.PP
References HandleObject\&.waitFor()\&.
.PP
.nf
        {
                waitFor(pname, value, true);
        }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBRadioProperty\fP \fBActivePositionProperty\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), ColorbarObject\&.doLocate(), LegendObject\&.doLocate(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.updateActivePosition()\&.
.SS "\fBVectorProperty\fP \fBALim\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), Utils\&.getAlphaData(), SurfaceObject\&.getAlphaData(), PatchObject\&.getAlphaData(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBALimMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "boolean \fBalwaysDrawBox\fP = true\fC [protected, inherited]\fP"
.PP
Referenced by ColorbarObject\&.ColorbarObject(), AxesObject\&.draw(), and LegendObject\&.LegendObject()\&.
.SS "int \fBautoMode\fP = 0\fC [protected, inherited]\fP"
.PP
Referenced by HandleObject\&.autoSet(), ColorbarObject\&.doLocate(), LegendObject\&.doLocate(), AxesObject\&.doZoom(), AxesObject\&.draw(), HandleObject\&.isAutoMode(), ColorbarObject\&.propertyChanged(), LegendObject\&.propertyChanged(), AxesObject\&.propertyChanged(), and AxesObject\&.unZoom()\&.
.SS "\fBAxesObject\fP \fBaxes\fP\fC [private]\fP"
.PP
Referenced by LegendObject\&.buildLegend(), LegendObject\&.doLocate(), and LegendObject\&.propertyChanged()\&.
.SS "\fBColorProperty\fP \fBAxesColor\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBBaseLineObject\fP \fBbaseLine\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.getBaseLine(), and AxesObject\&.removeChild()\&.
.SS "\fBBooleanProperty\fP \fBBeingDeleted\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.delete(), HandleObject\&.initProperties(), and AxesObject\&.removeChild()\&.
.SS "\fBBooleanProperty\fP \fBBox\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBCallbackProperty\fP \fBButtonDownFcn\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.doButtonDownFcn(), and HandleObject\&.initProperties()\&.
.SS "\fBVectorProperty\fP \fBCameraPosition\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBCameraPositionMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBVectorProperty\fP \fBCameraTarget\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBCameraTargetMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBVectorProperty\fP \fBCameraUpVector\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBCameraUpVectorMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBDoubleProperty\fP \fBCameraViewAngle\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBCameraViewAngleMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBHandleObjectListProperty\fP \fBChildren\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.addChild(), AxesObject\&.autoLegend(), AxesObject\&.autoScaleC(), LegendObject\&.buildLegend(), HandleObject\&.deleteChildren(), AxesContainer\&.display(), ColorbarObject\&.doClear(), LegendObject\&.doClear(), GroupObject\&.draw(), AxesObject\&.draw(), RootObject\&.findFigure(), AxesObject\&.getChildrenLimits(), AxesContainer\&.getObjectForPoint(), BarseriesObject\&.getPatch(), HandleObject\&.initProperties(), RootObject\&.removeChild(), HandleObject\&.removeChild(), AxesContainer\&.reshape(), ColorbarObject\&.updateImageFromColormap(), GroupObject\&.updateLimits(), GroupObject\&.validate(), and HandleObject\&.validate()\&.
.SS "\fBVectorProperty\fP \fBCLim\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleC(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), AxesObject\&.convertCData(), AxesObject\&.convertCDataToIndex(), ColorbarObject\&.propertyChanged(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and ColorbarObject\&.updateImageFromColormap()\&.
.SS "\fBRadioProperty\fP \fBCLimMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleC(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBBooleanProperty\fP \fBClipping\fP\fC [package, inherited]\fP"
.PP
Referenced by GLRenderer\&.draw(), AxesObject\&.draw(), HandleObject\&.initProperties(), and TextObject\&.TextObject()\&.
.SS "\fBColorbarObject\fP \fBcolorbar\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.deleteChildren(), AxesObject\&.makeColorbar(), and AxesObject\&.removeChild()\&.
.SS "\fBArrayProperty\fP \fBColorOrder\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject()\&.
.SS "\fBCallbackProperty\fP \fBCreateFcn\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.initProperties(), and HandleObject\&.validate()\&.
.SS "\fBVectorProperty\fP \fBDataAspectRatio\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBDataAspectRatioMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBPropertySet\fP \fBdefaultSet\fP = new \fBPropertySet\fP()\fC [protected, inherited]\fP"
.PP
Referenced by HandleObject\&.getDefaultProperty(), and HandleObject\&.set()\&.
.SS "\fBCallbackProperty\fP \fBDeleteFcn\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.delete(), and HandleObject\&.initProperties()\&.
.SS "\fBColorProperty\fP \fBEdgeColor\fP\fC [package]\fP"
.PP
Referenced by LegendObject\&.LegendObject(), and LegendObject\&.propertyChanged()\&.
.SS "\fBRadioProperty\fP \fBFontAngle\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBStringProperty\fP \fBFontName\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBDoubleProperty\fP \fBFontSize\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBRadioProperty\fP \fBFontUnits\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBRadioProperty\fP \fBFontWeight\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBLineStyleProperty\fP \fBGridLineStyle\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBHandleVisibility\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObjectListProperty\&.getVisibleObjects(), HandleObject\&.initProperties(), and AxesObject\&.makeTextObject()\&.
.SS "\fBLegendItem\fP [] \fBitems\fP\fC [private]\fP"
.PP
Referenced by LegendObject\&.buildLegend(), LegendObject\&.doLayout(), LegendObject\&.propertyChanged(), and LegendObject\&.size()\&.
.SS "\fBBooleanProperty\fP \fBKey\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoLegend(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBLayer\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBLegendObject\fP \fBlegend\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.deleteChildren(), AxesObject\&.getLegend(), AxesObject\&.makeLegend(), and AxesObject\&.removeChild()\&.
.SS "\fBDoubleProperty\fP \fBLineWidth\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.draw()\&.
.SS "\fBScaler\fP \fBlinScale\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.updateScalers()\&.
.SS "\fBRadioProperty\fP \fBLocation\fP\fC [package]\fP"
.PP
Referenced by LegendObject\&.doLocate(), LegendObject\&.LegendObject(), and LegendObject\&.propertyChanged()\&.
.SS "\fBScaler\fP \fBlogScale\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.updateScalers()\&.
.SS "\fBLineStyleProperty\fP \fBMinorGridLineStyle\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBNextPlot\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject()\&.
.SS "\fBRadioProperty\fP \fBOrientation\fP\fC [package]\fP"
.PP
Referenced by LegendObject\&.doLayout(), LegendObject\&.LegendObject(), and LegendObject\&.propertyChanged()\&.
.SS "\fBVectorProperty\fP \fBOuterPosition\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), ColorbarObject\&.doLocate(), LegendObject\&.doLocate(), AxesObject\&.getOuterBoundingBox(), LegendObject\&.LegendObject(), ColorbarObject\&.propertyChanged(), LegendObject\&.propertyChanged(), AxesObject\&.propertyChanged(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBHandleObjectListProperty\fP \fBParent\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.delete(), HandleObject\&.getAncestor(), GraphicObject\&.getAxes(), AxesObject\&.getAxesContainer(), AxesObject\&.getCanvas(), HandleObject\&.getDefaultProperty(), UIControlObject\&.getParentComponent(), UIPanelObject\&.getParentComponent(), HandleObject\&.initProperties(), LegendObject\&.LegendObject(), and HandleObject\&.validate()\&.
.SS "\fBVectorProperty\fP \fBPlotBoxAspectRatio\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBPlotBoxAspectRatioMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBVectorProperty\fP \fBPosition\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), LegendObject\&.doLayout(), ColorbarObject\&.doLocate(), LegendObject\&.doLocate(), AxesObject\&.getBoundingBox(), LegendObject\&.LegendObject(), ColorbarObject\&.propertyChanged(), LegendObject\&.propertyChanged(), AxesObject\&.propertyChanged(), AxesObject\&.setInternalPosition(), ColorbarObject\&.updateActivePosition(), LegendObject\&.updateActivePosition(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBRadioProperty\fP \fBProjection\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.reset()\&.
.SS "Dimension \fBsize\fP\fC [private]\fP"
.PP
Referenced by AxesObject\&.makeLegend()\&.
.SS "\fBStringArrayProperty\fP \fBString\fP\fC [package]\fP"
.PP
Referenced by LegendObject\&.buildLegend(), LegendObject\&.doLocate(), LegendObject\&.LegendObject(), and LegendObject\&.propertyChanged()\&.
.SS "\fBScaler\fP \fBsx\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.draw(), J2DRenderer\&.setXForm(), GLRenderer\&.setXForm(), AxesObject\&.transform(), AxesObject\&.unTransform(), AxesObject\&.updateScalers(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBScaler\fP \fBsy\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.draw(), J2DRenderer\&.setXForm(), GLRenderer\&.setXForm(), AxesObject\&.transform(), AxesObject\&.unTransform(), AxesObject\&.updateScalers(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBScaler\fP \fBsz\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.draw(), J2DRenderer\&.setXForm(), GLRenderer\&.setXForm(), AxesObject\&.transform(), AxesObject\&.unTransform(), AxesObject\&.updateScalers(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBStringProperty\fP \fBTag\fP\fC [package, inherited]\fP"
.PP
Referenced by ColorbarObject\&.ColorbarObject(), HandleObject\&.initProperties(), and LegendObject\&.LegendObject()\&.
.SS "\fBColorProperty\fP \fBTextColor\fP\fC [package]\fP"
.PP
Referenced by LegendObject\&.LegendObject(), LegendObject\&.makeItemFromLine(), and LegendObject\&.propertyChanged()\&.
.SS "\fBRadioProperty\fP \fBTickDir\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBTickDirMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBTextProperty\fP \fBTitle\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBStringProperty\fP \fBType\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.deleteChildren(), HandleObject\&.getAncestor(), HandleObject\&.getType(), HandleObject\&.initProperties(), and OctaveSink\&.OctaveSink()\&.
.SS "\fBRadioProperty\fP \fBUnits\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), ColorbarObject\&.doLocate(), LegendObject\&.doLocate(), AxesObject\&.getBoundingBox(), AxesObject\&.getOuterBoundingBox(), AxesObject\&.propertyChanged(), ColorbarObject\&.updateActivePosition(), LegendObject\&.updateActivePosition(), AxesObject\&.updateOuterPosition(), and AxesObject\&.updatePosition()\&.
.SS "\fBObjectProperty\fP \fBUserData\fP\fC [package, inherited]\fP"
.PP
Referenced by HandleObject\&.initProperties()\&.
.SS "\fBVectorProperty\fP \fBView\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.operation(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBBooleanProperty\fP \fBVisible\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.childValidated(), FigureObject\&.createFigure(), AxesObject\&.draw(), FigureObject\&.FigureObject(), AxesObject\&.getChildrenLimits(), HandleObject\&.initProperties(), FigureObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBMatrix3D\fP \fBx_mat1\fP = new \fBMatrix3D\fP()\fC [package, inherited]\fP"
.PP
Referenced by GLRenderer\&.setXForm()\&.
.SS "\fBMatrix3D\fP \fBx_mat2\fP = new \fBMatrix3D\fP()\fC [package, inherited]\fP"
.PP
Referenced by GLRenderer\&.setXForm()\&.
.SS "\fBMatrix3D\fP \fBx_normrender\fP = new \fBMatrix3D\fP()\fC [package, inherited]\fP"
.SS "\fBArrayProperty\fP \fBx_NormRenderTransform\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBMatrix3D\fP \fBx_projection\fP = new \fBMatrix3D\fP()\fC [package, inherited]\fP"
.SS "\fBArrayProperty\fP \fBx_ProjectionTransform\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBMatrix3D\fP \fBx_render\fP = new \fBMatrix3D\fP()\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.draw(), J2DRenderer\&.setXForm(), and GLRenderer\&.setXForm()\&.
.SS "\fBMatrix3D\fP \fBx_renderInv\fP\fC [package, inherited]\fP"
.SS "\fBArrayProperty\fP \fBx_RenderTransform\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBMatrix3D\fP \fBx_view\fP = new \fBMatrix3D\fP()\fC [package, inherited]\fP"
.SS "\fBMatrix3D\fP \fBx_viewport\fP = new \fBMatrix3D\fP()\fC [package, inherited]\fP"
.SS "\fBArrayProperty\fP \fBx_ViewportTransform\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBArrayProperty\fP \fBx_ViewTransform\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), and AxesObject\&.updateXFormMatrices()\&.
.SS "double \fBx_zmax\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.convertUnits(), AxesObject\&.doZoom(), AxesObject\&.draw(), and GLRenderer\&.setXForm()\&.
.SS "double \fBx_zmin\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.convertUnits(), AxesObject\&.doZoom(), AxesObject\&.draw(), and GLRenderer\&.setXForm()\&.
.SS "int \fBxAnchor\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.drawZoomBox(), AxesObject\&.endOperation(), and AxesObject\&.startOperation()\&.
.SS "\fBRadioProperty\fP \fBXAxisLocation\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBColorProperty\fP \fBXColor\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), LegendObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBXDir\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBBooleanProperty\fP \fBXGrid\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBTextProperty\fP \fBXLabel\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBVectorProperty\fP \fBXLim\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.autoMinorTickX(), AxesObject\&.autoScaleX(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), AxesObject\&.doZoom(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), AxesObject\&.unZoom(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBXLimMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleX(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), AxesObject\&.doZoom(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.unZoom()\&.
.SS "\fBBooleanProperty\fP \fBXMinorGrid\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBBooleanProperty\fP \fBXMinorTick\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBXScale\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoMinorTickX(), AxesObject\&.autoScaleX(), AxesObject\&.autoTickLabelX(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateScalers()\&.
.SS "\fBVectorProperty\fP \fBXTick\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoMinorTickX(), AxesObject\&.autoScaleX(), AxesObject\&.autoTickLabelX(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBStringArrayProperty\fP \fBXTickLabel\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoTickLabelX(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBXTickLabelMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoTickLabelX(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBXTickMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleX(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "int \fByAnchor\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.drawZoomBox(), AxesObject\&.endOperation(), and AxesObject\&.startOperation()\&.
.SS "\fBRadioProperty\fP \fBYAxisLocation\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBColorProperty\fP \fBYColor\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), LegendObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBYDir\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBBooleanProperty\fP \fBYGrid\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBTextProperty\fP \fBYLabel\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBVectorProperty\fP \fBYLim\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.autoMinorTickY(), AxesObject\&.autoScaleY(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), AxesObject\&.doZoom(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), AxesObject\&.unZoom(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBYLimMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleY(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), AxesObject\&.doZoom(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.unZoom()\&.
.SS "\fBBooleanProperty\fP \fBYMinorGrid\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBBooleanProperty\fP \fBYMinorTick\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "int \fByPrev\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.cancelOperation(), AxesObject\&.draw(), AxesObject\&.endOperation(), AxesObject\&.operation(), and AxesObject\&.startOperation()\&.
.SS "\fBRadioProperty\fP \fBYScale\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoMinorTickY(), AxesObject\&.autoScaleY(), AxesObject\&.autoTickLabelY(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateScalers()\&.
.SS "\fBVectorProperty\fP \fBYTick\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoMinorTickY(), AxesObject\&.autoScaleY(), AxesObject\&.autoTickLabelY(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBStringArrayProperty\fP \fBYTickLabel\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoTickLabelY(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBYTickLabelMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoTickLabelY(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), ColorbarObject\&.ColorbarObject(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBYTickMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleY(), AxesObject\&.AxesObject(), ColorbarObject\&.buildColorbar(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBColorProperty\fP \fBZColor\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), LegendObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBZDir\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBBooleanProperty\fP \fBZGrid\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBTextProperty\fP \fBZLabel\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBVectorProperty\fP \fBZLim\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoAspectRatio(), AxesObject\&.autoMinorTickZ(), AxesObject\&.autoScaleZ(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateXFormMatrices()\&.
.SS "\fBRadioProperty\fP \fBZLimMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleZ(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBBooleanProperty\fP \fBZMinorGrid\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), and AxesObject\&.reset()\&.
.SS "\fBBooleanProperty\fP \fBZMinorTick\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.AxesObject(), AxesObject\&.draw(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBZScale\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoMinorTickZ(), AxesObject\&.autoScaleZ(), AxesObject\&.autoTickLabelZ(), AxesObject\&.AxesObject(), AxesObject\&.propertyChanged(), AxesObject\&.reset(), and AxesObject\&.updateScalers()\&.
.SS "\fBVectorProperty\fP \fBZTick\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoMinorTickZ(), AxesObject\&.autoScaleZ(), AxesObject\&.autoTickLabelZ(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBStringArrayProperty\fP \fBZTickLabel\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoTickLabelZ(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), AxesObject\&.draw(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBZTickLabelMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoTickLabelZ(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.
.SS "\fBRadioProperty\fP \fBZTickMode\fP\fC [package, inherited]\fP"
.PP
Referenced by AxesObject\&.autoScaleZ(), AxesObject\&.AxesObject(), ColorbarObject\&.ColorbarObject(), LegendObject\&.LegendObject(), AxesObject\&.propertyChanged(), and AxesObject\&.reset()\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Octave from the source code\&.
