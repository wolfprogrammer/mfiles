.TH "/home/caio/mfiles/packages/jhandles-0.3.5/src/gl2ps.c" 3 "Tue Nov 27 2012" "Version 3.0" "Octave" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/caio/mfiles/packages/jhandles-0.3.5/src/gl2ps.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'gl2ps\&.h'\fP
.br
\fC#include <math\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <stdarg\&.h>\fP
.br
\fC#include <time\&.h>\fP
.br
\fC#include <float\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB_GL2PSbsptree2d\fP"
.br
.ti -1c
.RI "struct \fBGL2PSlist\fP"
.br
.ti -1c
.RI "struct \fB_GL2PSbsptree\fP"
.br
.ti -1c
.RI "struct \fBGL2PSvertex\fP"
.br
.ti -1c
.RI "struct \fBGL2PStriangle\fP"
.br
.ti -1c
.RI "struct \fBGL2PSstring\fP"
.br
.ti -1c
.RI "struct \fBGL2PSimage\fP"
.br
.ti -1c
.RI "struct \fB_GL2PSimagemap\fP"
.br
.ti -1c
.RI "struct \fBGL2PSprimitive\fP"
.br
.ti -1c
.RI "struct \fBGL2PScompress\fP"
.br
.ti -1c
.RI "struct \fBGL2PSpdfgroup\fP"
.br
.ti -1c
.RI "struct \fBGL2PScontext\fP"
.br
.ti -1c
.RI "struct \fBGL2PSbackend\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBGL2PS_EPSILON\fP   5\&.0e-3F"
.br
.ti -1c
.RI "#define \fBGL2PS_ZSCALE\fP   1000\&.0F"
.br
.ti -1c
.RI "#define \fBGL2PS_ZOFFSET\fP   5\&.0e-2F"
.br
.ti -1c
.RI "#define \fBGL2PS_ZOFFSET_LARGE\fP   20\&.0F"
.br
.ti -1c
.RI "#define \fBGL2PS_ZERO\fP(arg)   (fabs(arg) < 1\&.e-20)"
.br
.ti -1c
.RI "#define \fBGL2PS_NO_TYPE\fP   -1"
.br
.ti -1c
.RI "#define \fBGL2PS_TEXT\fP   1"
.br
.ti -1c
.RI "#define \fBGL2PS_POINT\fP   2"
.br
.ti -1c
.RI "#define \fBGL2PS_LINE\fP   3"
.br
.ti -1c
.RI "#define \fBGL2PS_QUADRANGLE\fP   4"
.br
.ti -1c
.RI "#define \fBGL2PS_TRIANGLE\fP   5"
.br
.ti -1c
.RI "#define \fBGL2PS_PIXMAP\fP   6"
.br
.ti -1c
.RI "#define \fBGL2PS_IMAGEMAP\fP   7"
.br
.ti -1c
.RI "#define \fBGL2PS_IMAGEMAP_WRITTEN\fP   8"
.br
.ti -1c
.RI "#define \fBGL2PS_IMAGEMAP_VISIBLE\fP   9"
.br
.ti -1c
.RI "#define \fBGL2PS_SPECIAL\fP   10"
.br
.ti -1c
.RI "#define \fBGL2PS_COINCIDENT\fP   1"
.br
.ti -1c
.RI "#define \fBGL2PS_IN_FRONT_OF\fP   2"
.br
.ti -1c
.RI "#define \fBGL2PS_IN_BACK_OF\fP   3"
.br
.ti -1c
.RI "#define \fBGL2PS_SPANNING\fP   4"
.br
.ti -1c
.RI "#define \fBGL2PS_POINT_COINCIDENT\fP   0"
.br
.ti -1c
.RI "#define \fBGL2PS_POINT_INFRONT\fP   1"
.br
.ti -1c
.RI "#define \fBGL2PS_POINT_BACK\fP   2"
.br
.ti -1c
.RI "#define \fBGL2PS_BEGIN_OFFSET_TOKEN\fP   1"
.br
.ti -1c
.RI "#define \fBGL2PS_END_OFFSET_TOKEN\fP   2"
.br
.ti -1c
.RI "#define \fBGL2PS_BEGIN_BOUNDARY_TOKEN\fP   3"
.br
.ti -1c
.RI "#define \fBGL2PS_END_BOUNDARY_TOKEN\fP   4"
.br
.ti -1c
.RI "#define \fBGL2PS_BEGIN_STIPPLE_TOKEN\fP   5"
.br
.ti -1c
.RI "#define \fBGL2PS_END_STIPPLE_TOKEN\fP   6"
.br
.ti -1c
.RI "#define \fBGL2PS_POINT_SIZE_TOKEN\fP   7"
.br
.ti -1c
.RI "#define \fBGL2PS_LINE_WIDTH_TOKEN\fP   8"
.br
.ti -1c
.RI "#define \fBGL2PS_BEGIN_BLEND_TOKEN\fP   9"
.br
.ti -1c
.RI "#define \fBGL2PS_END_BLEND_TOKEN\fP   10"
.br
.ti -1c
.RI "#define \fBGL2PS_SRC_BLEND_TOKEN\fP   11"
.br
.ti -1c
.RI "#define \fBGL2PS_DST_BLEND_TOKEN\fP   12"
.br
.ti -1c
.RI "#define \fBGL2PS_IMAGEMAP_TOKEN\fP   13"
.br
.ti -1c
.RI "#define \fBGL2PS_DRAW_PIXELS_TOKEN\fP   14"
.br
.ti -1c
.RI "#define \fBGL2PS_TEXT_TOKEN\fP   15"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef GLfloat \fBGL2PSxyz\fP [3]"
.br
.ti -1c
.RI "typedef GLfloat \fBGL2PSplane\fP [4]"
.br
.ti -1c
.RI "typedef struct \fB_GL2PSbsptree2d\fP \fBGL2PSbsptree2d\fP"
.br
.ti -1c
.RI "typedef struct \fB_GL2PSbsptree\fP \fBGL2PSbsptree\fP"
.br
.ti -1c
.RI "typedef struct \fB_GL2PSimagemap\fP \fBGL2PSimagemap\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBGL2PS_TRIANGLE_PROPERTY\fP { \fBT_UNDEFINED\fP =  -1, \fBT_CONST_COLOR\fP =  1, \fBT_VAR_COLOR\fP =  1<<1, \fBT_ALPHA_1\fP =  1<<2, \fBT_ALPHA_LESS_1\fP =  1<<3, \fBT_VAR_ALPHA\fP =  1<<4 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static GLint \fBgl2psPrintPrimitives\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psMsg\fP (GLint level, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "static void * \fBgl2psMalloc\fP (size_t size)"
.br
.ti -1c
.RI "static void * \fBgl2psRealloc\fP (void *ptr, size_t size)"
.br
.ti -1c
.RI "static void \fBgl2psFree\fP (void *ptr)"
.br
.ti -1c
.RI "static size_t \fBgl2psWriteBigEndian\fP (unsigned long data, size_t bytes)"
.br
.ti -1c
.RI "static int \fBgl2psPrintf\fP (const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "static void \fBgl2psPrintGzipHeader\fP ()"
.br
.ti -1c
.RI "static void \fBgl2psPrintGzipFooter\fP ()"
.br
.ti -1c
.RI "static void \fBgl2psListRealloc\fP (\fBGL2PSlist\fP *list, GLint \fBn\fP)"
.br
.ti -1c
.RI "static \fBGL2PSlist\fP * \fBgl2psListCreate\fP (GLint \fBn\fP, GLint incr, GLint size)"
.br
.ti -1c
.RI "static void \fBgl2psListReset\fP (\fBGL2PSlist\fP *list)"
.br
.ti -1c
.RI "static void \fBgl2psListDelete\fP (\fBGL2PSlist\fP *list)"
.br
.ti -1c
.RI "static void \fBgl2psListAdd\fP (\fBGL2PSlist\fP *list, void *data)"
.br
.ti -1c
.RI "static int \fBgl2psListNbr\fP (\fBGL2PSlist\fP *list)"
.br
.ti -1c
.RI "static void * \fBgl2psListPointer\fP (\fBGL2PSlist\fP *list, GLint index)"
.br
.ti -1c
.RI "static void \fBgl2psListSort\fP (\fBGL2PSlist\fP *list, int(*fcmp)(const void *\fBa\fP, const void *b))"
.br
.ti -1c
.RI "static void \fBgl2psListAction\fP (\fBGL2PSlist\fP *list, void(*action)(void *data))"
.br
.ti -1c
.RI "static void \fBgl2psListActionInverse\fP (\fBGL2PSlist\fP *list, void(*action)(void *data))"
.br
.ti -1c
.RI "static GLboolean \fBgl2psSameColor\fP (\fBGL2PSrgba\fP rgba1, \fBGL2PSrgba\fP rgba2)"
.br
.ti -1c
.RI "static GLboolean \fBgl2psVertsSameColor\fP (const \fBGL2PSprimitive\fP *prim)"
.br
.ti -1c
.RI "static GLboolean \fBgl2psSameColorThreshold\fP (int \fBn\fP, \fBGL2PSrgba\fP rgba[], \fBGL2PSrgba\fP threshold)"
.br
.ti -1c
.RI "static void \fBgl2psSetLastColor\fP (\fBGL2PSrgba\fP rgba)"
.br
.ti -1c
.RI "static GLfloat \fBgl2psGetRGB\fP (\fBGL2PSimage\fP *im, GLuint \fBx\fP, GLuint \fBy\fP, GLfloat *red, GLfloat *green, GLfloat *blue)"
.br
.ti -1c
.RI "static \fBGL2PSimage\fP * \fBgl2psCopyPixmap\fP (\fBGL2PSimage\fP *im)"
.br
.ti -1c
.RI "static void \fBgl2psFreePixmap\fP (\fBGL2PSimage\fP *im)"
.br
.ti -1c
.RI "static GLint \fBgl2psAddText\fP (GLint \fBtype\fP, const char *str, const char *fontname, GLshort fontsize, GLint alignment, GLfloat \fBangle\fP, GLfloat margin, GLboolean offsetmargin, GLfloat lwidth, \fBGL2PSrgba\fP \fBlc\fP, GLushort lpattern, GLint lfactor, \fBGL2PSrgba\fP fc)"
.br
.ti -1c
.RI "static \fBGL2PSstring\fP * \fBgl2psCopyText\fP (\fBGL2PSstring\fP *\fBt\fP)"
.br
.ti -1c
.RI "static void \fBgl2psFreeText\fP (\fBGL2PSstring\fP *text)"
.br
.ti -1c
.RI "static GLboolean \fBgl2psSupportedBlendMode\fP (GLenum sfactor, GLenum dfactor)"
.br
.ti -1c
.RI "static void \fBgl2psAdaptVertexForBlending\fP (\fBGL2PSvertex\fP *v)"
.br
.ti -1c
.RI "static void \fBgl2psAssignTriangleProperties\fP (\fBGL2PStriangle\fP *\fBt\fP)"
.br
.ti -1c
.RI "static void \fBgl2psFillTriangleFromPrimitive\fP (\fBGL2PStriangle\fP *\fBt\fP, \fBGL2PSprimitive\fP *\fBp\fP, GLboolean assignprops)"
.br
.ti -1c
.RI "static void \fBgl2psInitTriangle\fP (\fBGL2PStriangle\fP *\fBt\fP)"
.br
.ti -1c
.RI "static \fBGL2PSprimitive\fP * \fBgl2psCopyPrimitive\fP (\fBGL2PSprimitive\fP *\fBp\fP)"
.br
.ti -1c
.RI "static GLboolean \fBgl2psSamePosition\fP (\fBGL2PSxyz\fP p1, \fBGL2PSxyz\fP p2)"
.br
.ti -1c
.RI "static GLfloat \fBgl2psComparePointPlane\fP (\fBGL2PSxyz\fP point, \fBGL2PSplane\fP plane)"
.br
.ti -1c
.RI "static GLfloat \fBgl2psPsca\fP (GLfloat *\fBa\fP, GLfloat *b)"
.br
.ti -1c
.RI "static void \fBgl2psPvec\fP (GLfloat *\fBa\fP, GLfloat *b, GLfloat *\fBc\fP)"
.br
.ti -1c
.RI "static GLfloat \fBgl2psNorm\fP (GLfloat *\fBa\fP)"
.br
.ti -1c
.RI "static void \fBgl2psGetNormal\fP (GLfloat *\fBa\fP, GLfloat *b, GLfloat *\fBc\fP)"
.br
.ti -1c
.RI "static void \fBgl2psGetPlane\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fP plane)"
.br
.ti -1c
.RI "static void \fBgl2psCutEdge\fP (\fBGL2PSvertex\fP *\fBa\fP, \fBGL2PSvertex\fP *b, \fBGL2PSplane\fP plane, \fBGL2PSvertex\fP *\fBc\fP)"
.br
.ti -1c
.RI "static void \fBgl2psCreateSplitPrimitive\fP (\fBGL2PSprimitive\fP *\fBparent\fP, \fBGL2PSplane\fP plane, \fBGL2PSprimitive\fP *child, GLshort numverts, GLshort *index0, GLshort *index1)"
.br
.ti -1c
.RI "static void \fBgl2psAddIndex\fP (GLshort *index0, GLshort *index1, GLshort *nb, GLshort \fBi\fP, GLshort j)"
.br
.ti -1c
.RI "static GLshort \fBgl2psGetIndex\fP (GLshort \fBi\fP, GLshort \fBnum\fP)"
.br
.ti -1c
.RI "static GLint \fBgl2psTestSplitPrimitive\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fP plane)"
.br
.ti -1c
.RI "static GLint \fBgl2psSplitPrimitive\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fP plane, \fBGL2PSprimitive\fP **front, \fBGL2PSprimitive\fP **back)"
.br
.ti -1c
.RI "static void \fBgl2psDivideQuad\fP (\fBGL2PSprimitive\fP *quad, \fBGL2PSprimitive\fP **t1, \fBGL2PSprimitive\fP **t2)"
.br
.ti -1c
.RI "static int \fBgl2psCompareDepth\fP (const void *\fBa\fP, const void *b)"
.br
.ti -1c
.RI "static int \fBgl2psTrianglesFirst\fP (const void *\fBa\fP, const void *b)"
.br
.ti -1c
.RI "static GLint \fBgl2psFindRoot\fP (\fBGL2PSlist\fP *primitives, \fBGL2PSprimitive\fP **root)"
.br
.ti -1c
.RI "static void \fBgl2psFreeImagemap\fP (\fBGL2PSimagemap\fP *list)"
.br
.ti -1c
.RI "static void \fBgl2psFreePrimitive\fP (void *data)"
.br
.ti -1c
.RI "static void \fBgl2psAddPrimitiveInList\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSlist\fP *list)"
.br
.ti -1c
.RI "static void \fBgl2psFreeBspTree\fP (\fBGL2PSbsptree\fP **tree)"
.br
.ti -1c
.RI "static GLboolean \fBgl2psGreater\fP (GLfloat f1, GLfloat f2)"
.br
.ti -1c
.RI "static GLboolean \fBgl2psLess\fP (GLfloat f1, GLfloat f2)"
.br
.ti -1c
.RI "static void \fBgl2psBuildBspTree\fP (\fBGL2PSbsptree\fP *tree, \fBGL2PSlist\fP *primitives)"
.br
.ti -1c
.RI "static void \fBgl2psTraverseBspTree\fP (\fBGL2PSbsptree\fP *tree, \fBGL2PSxyz\fP eye, GLfloat epsilon, GLboolean(*compare)(GLfloat f1, GLfloat f2), void(*action)(void *data), int inverse)"
.br
.ti -1c
.RI "static void \fBgl2psRescaleAndOffset\fP ()"
.br
.ti -1c
.RI "static GLint \fBgl2psGetPlaneFromPoints\fP (\fBGL2PSxyz\fP \fBa\fP, \fBGL2PSxyz\fP b, \fBGL2PSplane\fP plane)"
.br
.ti -1c
.RI "static void \fBgl2psFreeBspImageTree\fP (\fBGL2PSbsptree2d\fP **tree)"
.br
.ti -1c
.RI "static GLint \fBgl2psCheckPoint\fP (\fBGL2PSxyz\fP point, \fBGL2PSplane\fP plane)"
.br
.ti -1c
.RI "static void \fBgl2psAddPlanesInBspTreeImage\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSbsptree2d\fP **tree)"
.br
.ti -1c
.RI "static GLint \fBgl2psCheckPrimitive\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fP plane)"
.br
.ti -1c
.RI "static \fBGL2PSprimitive\fP * \fBgl2psCreateSplitPrimitive2D\fP (\fBGL2PSprimitive\fP *\fBparent\fP, GLshort numverts, \fBGL2PSvertex\fP *vertx)"
.br
.ti -1c
.RI "static void \fBgl2psSplitPrimitive2D\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fP plane, \fBGL2PSprimitive\fP **front, \fBGL2PSprimitive\fP **back)"
.br
.ti -1c
.RI "static GLint \fBgl2psAddInBspImageTree\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSbsptree2d\fP **tree)"
.br
.ti -1c
.RI "static void \fBgl2psAddInImageTree\fP (void *data)"
.br
.ti -1c
.RI "static void \fBgl2psAddBoundaryInList\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSlist\fP *list)"
.br
.ti -1c
.RI "static void \fBgl2psBuildPolygonBoundary\fP (\fBGL2PSbsptree\fP *tree)"
.br
.ti -1c
.RI "static void \fBgl2psAddPolyPrimitive\fP (GLshort \fBtype\fP, GLshort numverts, \fBGL2PSvertex\fP *verts, GLint offset, GLushort pattern, GLint factor, GLfloat \fBwidth\fP, char boundary)"
.br
.ti -1c
.RI "static GLint \fBgl2psGetVertex\fP (\fBGL2PSvertex\fP *v, GLfloat *\fBp\fP)"
.br
.ti -1c
.RI "static void \fBgl2psParseFeedbackBuffer\fP (GLint used)"
.br
.ti -1c
.RI "static void \fBgl2psWriteByte\fP (unsigned char byte)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptPixmap\fP (GLfloat \fBx\fP, GLfloat \fBy\fP, \fBGL2PSimage\fP *im)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptImagemap\fP (GLfloat \fBx\fP, GLfloat \fBy\fP, GLsizei \fBwidth\fP, GLsizei height, const unsigned char *imagemap)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptHeader\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptColor\fP (\fBGL2PSrgba\fP rgba)"
.br
.ti -1c
.RI "static void \fBgl2psResetPostScriptColor\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psEndPostScriptLine\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psParseStipplePattern\fP (GLushort pattern, GLint factor, int *nb, int array[10])"
.br
.ti -1c
.RI "static int \fBgl2psPrintPostScriptDash\fP (GLushort pattern, GLint factor, char *str)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptPrimitive\fP (void *data)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptFooter\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptBeginViewport\fP (GLint viewport[4])"
.br
.ti -1c
.RI "static GLint \fBgl2psPrintPostScriptEndViewport\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPostScriptFinalPrimitive\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintTeXHeader\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintTeXPrimitive\fP (void *data)"
.br
.ti -1c
.RI "static void \fBgl2psPrintTeXFooter\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintTeXBeginViewport\fP (GLint viewport[4])"
.br
.ti -1c
.RI "static GLint \fBgl2psPrintTeXEndViewport\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintTeXFinalPrimitive\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFCompressorType\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFStrokeColor\fP (\fBGL2PSrgba\fP rgba)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFFillColor\fP (\fBGL2PSrgba\fP rgba)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFLineWidth\fP (GLfloat lw)"
.br
.ti -1c
.RI "static void \fBgl2psPutPDFText\fP (\fBGL2PSstring\fP *text, int cnt, GLfloat \fBx\fP, GLfloat \fBy\fP)"
.br
.ti -1c
.RI "static void \fBgl2psPutPDFImage\fP (\fBGL2PSimage\fP *image, int cnt, GLfloat \fBx\fP, GLfloat \fBy\fP)"
.br
.ti -1c
.RI "static void \fBgl2psPDFstacksInit\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPDFgroupObjectInit\fP (\fBGL2PSpdfgroup\fP *gro)"
.br
.ti -1c
.RI "static void \fBgl2psPDFgroupListInit\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psSortOutTrianglePDFgroup\fP (\fBGL2PSpdfgroup\fP *gro)"
.br
.ti -1c
.RI "static void \fBgl2psPDFgroupListWriteMainStream\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPDFgroupListWriteGStateResources\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPDFgroupListWriteShaderResources\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPDFgroupListWriteXObjectResources\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPDFgroupListWriteFontResources\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPDFgroupListDelete\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFInfo\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFCatalog\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFPages\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psOpenPDFDataStream\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psOpenPDFDataStreamWritePreface\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPDFHeader\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPDFPrimitive\fP (void *data)"
.br
.ti -1c
.RI "static int \fBgl2psClosePDFDataStream\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFDataStreamLength\fP (int \fBval\fP)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFOpenPage\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPDFgroupListWriteVariableResources\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFGSObject\fP (void)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShaderStreamDataCoord\fP (\fBGL2PSvertex\fP *vertex, size_t(*action)(unsigned long data, size_t size), GLfloat \fBdx\fP, GLfloat \fBdy\fP, GLfloat xmin, GLfloat ymin)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShaderStreamDataRGB\fP (\fBGL2PSvertex\fP *vertex, size_t(*action)(unsigned long data, size_t size))"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShaderStreamDataAlpha\fP (\fBGL2PSvertex\fP *vertex, size_t(*action)(unsigned long data, size_t size), int sigbyte)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShaderStreamData\fP (\fBGL2PStriangle\fP *triangle, GLfloat \fBdx\fP, GLfloat \fBdy\fP, GLfloat xmin, GLfloat ymin, size_t(*action)(unsigned long data, size_t size), int gray)"
.br
.ti -1c
.RI "static void \fBgl2psPDFRectHull\fP (GLfloat *xmin, GLfloat *xmax, GLfloat *ymin, GLfloat *ymax, \fBGL2PStriangle\fP *triangles, int cnt)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShader\fP (int \fBobj\fP, \fBGL2PStriangle\fP *triangles, int size, int gray)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShaderMask\fP (int \fBobj\fP, int childobj)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShaderExtGS\fP (int \fBobj\fP, int childobj)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFShaderSimpleExtGS\fP (int \fBobj\fP, GLfloat \fBalpha\fP)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFPixmapStreamData\fP (\fBGL2PSimage\fP *im, size_t(*action)(unsigned long data, size_t size), int gray)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFPixmap\fP (int \fBobj\fP, int childobj, \fBGL2PSimage\fP *im, int gray)"
.br
.ti -1c
.RI "static int \fBgl2psPrintPDFText\fP (int \fBobj\fP, \fBGL2PSstring\fP *\fBs\fP, int fontnumber)"
.br
.ti -1c
.RI "static int \fBgl2psPDFgroupListWriteObjects\fP (int entryoffs)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPDFFooter\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPDFBeginViewport\fP (GLint viewport[4])"
.br
.ti -1c
.RI "static GLint \fBgl2psPrintPDFEndViewport\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPDFFinalPrimitive\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psSVGGetCoordsAndColors\fP (int \fBn\fP, \fBGL2PSvertex\fP *verts, \fBGL2PSxyz\fP *xyz, \fBGL2PSrgba\fP *rgba)"
.br
.ti -1c
.RI "static void \fBgl2psSVGGetColorString\fP (\fBGL2PSrgba\fP rgba, char str[32])"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGHeader\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGSmoothTriangle\fP (\fBGL2PSxyz\fP xyz[3], \fBGL2PSrgba\fP rgba[3])"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGDash\fP (GLushort pattern, GLint factor)"
.br
.ti -1c
.RI "static void \fBgl2psEndSVGLine\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGPixmap\fP (GLfloat \fBx\fP, GLfloat \fBy\fP, \fBGL2PSimage\fP *pixmap)"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGPrimitive\fP (void *data)"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGFooter\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGBeginViewport\fP (GLint viewport[4])"
.br
.ti -1c
.RI "static GLint \fBgl2psPrintSVGEndViewport\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintSVGFinalPrimitive\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPGFColor\fP (\fBGL2PSrgba\fP rgba)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPGFHeader\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPGFDash\fP (GLushort pattern, GLint factor)"
.br
.ti -1c
.RI "static const char * \fBgl2psPGFTextAlignment\fP (int align)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPGFPrimitive\fP (void *data)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPGFFooter\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPGFBeginViewport\fP (GLint viewport[4])"
.br
.ti -1c
.RI "static GLint \fBgl2psPrintPGFEndViewport\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psPrintPGFFinalPrimitive\fP (void)"
.br
.ti -1c
.RI "static void \fBgl2psComputeTightBoundingBox\fP (void *data)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psBeginPage\fP (const char *title, const char *producer, GLint viewport[4], GLint format, GLint sort, GLint options, GLint colormode, GLint colorsize, \fBGL2PSrgba\fP *colormap, GLint \fBnr\fP, GLint ng, GLint nb, GLint buffersize, FILE *\fBstream\fP, const char *filename)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psEndPage\fP (void)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psBeginViewport\fP (GLint viewport[4])"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psEndViewport\fP (void)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psTextOpt\fP (const char *str, const char *fontname, GLshort fontsize, GLint alignment, GLfloat \fBangle\fP, GLfloat margin, GLboolean offsetmargin, GLfloat lwidth, \fBGL2PSrgba\fP \fBlc\fP, GLushort lpattern, GLint lfactor, \fBGL2PSrgba\fP fc)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psText\fP (const char *str, const char *fontname, GLshort fontsize)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psSpecial\fP (GLint format, const char *str, int moveTo)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psDrawPixels\fP (GLsizei \fBwidth\fP, GLsizei height, GLint xorig, GLint yorig, GLenum format, GLenum \fBtype\fP, const void *pixels)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psDrawImageMap\fP (GLsizei \fBwidth\fP, GLsizei height, const GLfloat \fBposition\fP[3], const unsigned char *imagemap)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psEnable\fP (GLint \fBmode\fP)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psDisable\fP (GLint \fBmode\fP)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psPointSize\fP (GLfloat value)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psLineWidth\fP (GLfloat value)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psBlendFunc\fP (GLenum sfactor, GLenum dfactor)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP GLint \fBgl2psSetOptions\fP (GLint options)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP const char * \fBgl2psGetFileExtension\fP (GLint format)"
.br
.ti -1c
.RI "\fBGL2PSDLL_API\fP const char * \fBgl2psGetFormatDescription\fP (GLint format)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBGL2PScontext\fP * \fBgl2ps\fP = NULL"
.br
.ti -1c
.RI "static \fBGL2PSbackend\fP \fBgl2psPS\fP"
.br
.ti -1c
.RI "static \fBGL2PSbackend\fP \fBgl2psEPS\fP"
.br
.ti -1c
.RI "static \fBGL2PSbackend\fP \fBgl2psTEX\fP"
.br
.ti -1c
.RI "static \fBGL2PSbackend\fP \fBgl2psPDF\fP"
.br
.ti -1c
.RI "static \fBGL2PSbackend\fP \fBgl2psSVG\fP"
.br
.ti -1c
.RI "static \fBGL2PSbackend\fP \fBgl2psPGF\fP"
.br
.ti -1c
.RI "static \fBGL2PSbackend\fP * \fBgl2psbackends\fP []"
.br
.in -1c
.SH "Define Documentation"
.PP 
.SS "#define \fBGL2PS_BEGIN_BLEND_TOKEN\fP   9"
.PP
Definition at line 128 of file gl2ps\&.c\&.
.PP
Referenced by gl2psEnable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_BEGIN_BOUNDARY_TOKEN\fP   3"
.PP
Definition at line 122 of file gl2ps\&.c\&.
.PP
Referenced by gl2psEnable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_BEGIN_OFFSET_TOKEN\fP   1"
.PP
Definition at line 120 of file gl2ps\&.c\&.
.PP
Referenced by gl2psEnable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_BEGIN_STIPPLE_TOKEN\fP   5"
.PP
Definition at line 124 of file gl2ps\&.c\&.
.PP
Referenced by gl2psEnable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_COINCIDENT\fP   1"
.PP
Definition at line 107 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psBuildBspTree(), gl2psCheckPrimitive(), gl2psSplitPrimitive(), and gl2psTestSplitPrimitive()\&.
.SS "#define \fBGL2PS_DRAW_PIXELS_TOKEN\fP   14"
.PP
Definition at line 133 of file gl2ps\&.c\&.
.PP
Referenced by gl2psDrawPixels(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_DST_BLEND_TOKEN\fP   12"
.PP
Definition at line 131 of file gl2ps\&.c\&.
.PP
Referenced by gl2psBlendFunc(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_END_BLEND_TOKEN\fP   10"
.PP
Definition at line 129 of file gl2ps\&.c\&.
.PP
Referenced by gl2psDisable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_END_BOUNDARY_TOKEN\fP   4"
.PP
Definition at line 123 of file gl2ps\&.c\&.
.PP
Referenced by gl2psDisable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_END_OFFSET_TOKEN\fP   2"
.PP
Definition at line 121 of file gl2ps\&.c\&.
.PP
Referenced by gl2psDisable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_END_STIPPLE_TOKEN\fP   6"
.PP
Definition at line 125 of file gl2ps\&.c\&.
.PP
Referenced by gl2psDisable(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_EPSILON\fP   5\&.0e-3F"
.PP
Definition at line 85 of file gl2ps\&.c\&.
.PP
Referenced by gl2psCheckPoint(), gl2psPrintPrimitives(), gl2psSplitPrimitive(), and gl2psTestSplitPrimitive()\&.
.SS "#define \fBGL2PS_IMAGEMAP\fP   7"
.PP
Definition at line 100 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psAddInImageTree(), gl2psCreateSplitPrimitive(), gl2psCreateSplitPrimitive2D(), gl2psGetPlane(), gl2psParseFeedbackBuffer(), and gl2psPrintPostScriptPrimitive()\&.
.SS "#define \fBGL2PS_IMAGEMAP_TOKEN\fP   13"
.PP
Definition at line 132 of file gl2ps\&.c\&.
.PP
Referenced by gl2psDrawImageMap(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_IMAGEMAP_VISIBLE\fP   9"
.PP
Definition at line 102 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInImageTree()\&.
.SS "#define \fBGL2PS_IMAGEMAP_WRITTEN\fP   8"
.PP
Definition at line 101 of file gl2ps\&.c\&.
.PP
Referenced by gl2psPrintPostScriptPrimitive()\&.
.SS "#define \fBGL2PS_IN_BACK_OF\fP   3"
.PP
Definition at line 109 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psBuildBspTree(), gl2psCheckPrimitive(), gl2psSplitPrimitive(), and gl2psTestSplitPrimitive()\&.
.SS "#define \fBGL2PS_IN_FRONT_OF\fP   2"
.PP
Definition at line 108 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psBuildBspTree(), gl2psCheckPrimitive(), gl2psSplitPrimitive(), and gl2psTestSplitPrimitive()\&.
.SS "#define \fBGL2PS_LINE\fP   3"
.PP
Definition at line 96 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddBoundaryInList(), gl2psAddInBspImageTree(), gl2psCreateSplitPrimitive(), gl2psCreateSplitPrimitive2D(), gl2psGetPlane(), gl2psParseFeedbackBuffer(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPrintPGFPrimitive(), gl2psPrintPostScriptPrimitive(), gl2psPrintSVGPrimitive(), and gl2psRescaleAndOffset()\&.
.SS "#define \fBGL2PS_LINE_WIDTH_TOKEN\fP   8"
.PP
Definition at line 127 of file gl2ps\&.c\&.
.PP
Referenced by gl2psLineWidth(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_NO_TYPE\fP   -1"
.PP
Definition at line 93 of file gl2ps\&.c\&.
.PP
Referenced by gl2psCreateSplitPrimitive(), gl2psCreateSplitPrimitive2D(), and gl2psPDFgroupListInit()\&.
.SS "#define \fBGL2PS_PIXMAP\fP   6"
.PP
Definition at line 99 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psCopyPrimitive(), gl2psDrawPixels(), gl2psFreePrimitive(), gl2psGetPlane(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPDFgroupListWriteXObjectResources(), gl2psPrintPostScriptPrimitive(), and gl2psPrintSVGPrimitive()\&.
.SS "#define \fBGL2PS_POINT\fP   2"
.PP
Definition at line 95 of file gl2ps\&.c\&.
.PP
Referenced by gl2psCreateSplitPrimitive(), gl2psCreateSplitPrimitive2D(), gl2psGetPlane(), gl2psParseFeedbackBuffer(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPrintPGFPrimitive(), gl2psPrintPostScriptPrimitive(), gl2psPrintSVGPrimitive(), and gl2psSplitPrimitive()\&.
.SS "#define \fBGL2PS_POINT_BACK\fP   2"
.PP
Definition at line 116 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddPlanesInBspTreeImage(), gl2psCheckPoint(), gl2psCheckPrimitive(), and gl2psSplitPrimitive2D()\&.
.SS "#define \fBGL2PS_POINT_COINCIDENT\fP   0"
.PP
Definition at line 114 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddPlanesInBspTreeImage(), and gl2psCheckPoint()\&.
.SS "#define \fBGL2PS_POINT_INFRONT\fP   1"
.PP
Definition at line 115 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddPlanesInBspTreeImage(), gl2psCheckPoint(), gl2psCheckPrimitive(), and gl2psSplitPrimitive2D()\&.
.SS "#define \fBGL2PS_POINT_SIZE_TOKEN\fP   7"
.PP
Definition at line 126 of file gl2ps\&.c\&.
.PP
Referenced by gl2psParseFeedbackBuffer(), and gl2psPointSize()\&.
.SS "#define \fBGL2PS_QUADRANGLE\fP   4"
.PP
Definition at line 97 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddPrimitiveInList(), gl2psCreateSplitPrimitive(), gl2psCreateSplitPrimitive2D(), gl2psGetPlane(), gl2psPrintPostScriptPrimitive(), and gl2psPrintSVGPrimitive()\&.
.SS "#define \fBGL2PS_SPANNING\fP   4"
.PP
Definition at line 110 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psBuildBspTree(), gl2psCheckPrimitive(), and gl2psSplitPrimitive()\&.
.SS "#define \fBGL2PS_SPECIAL\fP   10"
.PP
Definition at line 103 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psCopyPrimitive(), gl2psFreePrimitive(), gl2psGetPlane(), gl2psPDFgroupListWriteObjects(), gl2psPrintPGFPrimitive(), gl2psPrintPostScriptPrimitive(), gl2psPrintSVGPrimitive(), gl2psPrintTeXPrimitive(), and gl2psSpecial()\&.
.SS "#define \fBGL2PS_SRC_BLEND_TOKEN\fP   11"
.PP
Definition at line 130 of file gl2ps\&.c\&.
.PP
Referenced by gl2psBlendFunc(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_TEXT\fP   1"
.PP
Definition at line 94 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psBuildBspTree(), gl2psCopyPrimitive(), gl2psFreePrimitive(), gl2psGetPlane(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPrintPGFPrimitive(), gl2psPrintPostScriptPrimitive(), gl2psPrintSVGPrimitive(), gl2psPrintTeXPrimitive(), gl2psText(), and gl2psTextOpt()\&.
.SS "#define \fBGL2PS_TEXT_TOKEN\fP   15"
.PP
Definition at line 134 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddText(), and gl2psParseFeedbackBuffer()\&.
.SS "#define \fBGL2PS_TRIANGLE\fP   5"
.PP
Definition at line 98 of file gl2ps\&.c\&.
.PP
Referenced by gl2psCreateSplitPrimitive(), gl2psCreateSplitPrimitive2D(), gl2psDivideQuad(), gl2psGetPlane(), gl2psParseFeedbackBuffer(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPDFgroupListWriteXObjectResources(), gl2psPrintPGFPrimitive(), gl2psPrintPostScriptPrimitive(), gl2psPrintSVGPrimitive(), gl2psRescaleAndOffset(), and gl2psSortOutTrianglePDFgroup()\&.
.SS "#define \fBGL2PS_ZERO\fP(arg)   (fabs(arg) < 1\&.e-20)"
.PP
Definition at line 89 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAssignTriangleProperties(), gl2psGetNormal(), gl2psGetPlane(), gl2psGetPlaneFromPoints(), gl2psPrintPDFFillColor(), gl2psPrintPDFLineWidth(), gl2psPrintPDFShaderStreamDataCoord(), gl2psPrintPDFStrokeColor(), gl2psRescaleAndOffset(), gl2psSameColor(), and gl2psSamePosition()\&.
.SS "#define \fBGL2PS_ZOFFSET\fP   5\&.0e-2F"
.PP
Definition at line 87 of file gl2ps\&.c\&.
.PP
Referenced by gl2psRescaleAndOffset()\&.
.SS "#define \fBGL2PS_ZOFFSET_LARGE\fP   20\&.0F"
.PP
Definition at line 88 of file gl2ps\&.c\&.
.PP
Referenced by gl2psRescaleAndOffset()\&.
.SS "#define \fBGL2PS_ZSCALE\fP   1000\&.0F"
.PP
Definition at line 86 of file gl2ps\&.c\&.
.PP
Referenced by gl2psPrintPrimitives(), and gl2psRescaleAndOffset()\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_GL2PSbsptree\fP \fBGL2PSbsptree\fP"
.PP
Definition at line 160 of file gl2ps\&.c\&.
.SS "typedef struct \fB_GL2PSbsptree2d\fP \fBGL2PSbsptree2d\fP"
.PP
Definition at line 148 of file gl2ps\&.c\&.
.SS "typedef struct \fB_GL2PSimagemap\fP \fBGL2PSimagemap\fP"
.PP
Definition at line 204 of file gl2ps\&.c\&.
.SS "typedef GLfloat \fBGL2PSplane\fP[4]"
.PP
Definition at line 146 of file gl2ps\&.c\&.
.SS "typedef GLfloat \fBGL2PSxyz\fP[3]"
.PP
Definition at line 145 of file gl2ps\&.c\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBGL2PS_TRIANGLE_PROPERTY\fP"
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIT_UNDEFINED \fP\fP
.TP
\fB\fIT_CONST_COLOR \fP\fP
.TP
\fB\fIT_VAR_COLOR \fP\fP
.TP
\fB\fIT_ALPHA_1 \fP\fP
.TP
\fB\fIT_ALPHA_LESS_1 \fP\fP
.TP
\fB\fIT_VAR_ALPHA \fP\fP

.PP
Definition at line 136 of file gl2ps\&.c\&.
.PP
.nf
             {
  T_UNDEFINED    = -1,
  T_CONST_COLOR  = 1,
  T_VAR_COLOR    = 1<<1,
  T_ALPHA_1      = 1<<2,
  T_ALPHA_LESS_1 = 1<<3,
  T_VAR_ALPHA    = 1<<4
} GL2PS_TRIANGLE_PROPERTY;
.fi
.SH "Function Documentation"
.PP 
.SS "static void \fBgl2psAdaptVertexForBlending\fP (\fBGL2PSvertex\fP *v)\fC [static]\fP"
.PP
Definition at line 991 of file gl2ps\&.c\&.
.PP
References GL2PScontext::blendfunc, GL2PScontext::blending, GL2PS_NO_BLENDING, GL2PScontext::options, and GL2PSvertex::rgba\&.
.PP
Referenced by gl2psParseFeedbackBuffer()\&.
.PP
.nf
{
  /* Transforms vertex depending on the actual blending function -
     currently the vertex v is considered as source vertex and his
     alpha value is changed to 1\&.0 if source blending GL_ONE is
     active\&. This might be extended in the future */

  if(!v || !gl2ps)
    return;

  if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
    v->rgba[3] = 1\&.0F;
    return;
  }
  
  switch(gl2ps->blendfunc[0]){
  case GL_ONE:
    v->rgba[3] = 1\&.0F;
    break;
  default:
    break;
  }
}
.fi
.SS "static void \fBgl2psAddBoundaryInList\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSlist\fP *list)\fC [static]\fP"
.PP
Definition at line 2118 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::boundary, c, GL2PSprimitive::culled, GL2PSprimitive::factor, GL2PS_LINE, gl2psGetIndex(), gl2psListAdd(), gl2psMalloc(), gl2psNorm(), i, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PSprimitive::pattern, GL2PSvertex::rgba, GL2PSprimitive::type, GL2PSprimitive::verts, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psBuildPolygonBoundary()\&.
.PP
.nf
{
  GL2PSprimitive *b;
  GLshort i;
  GL2PSxyz c;

  c[0] = c[1] = c[2] = 0\&.0F;
  for(i = 0; i < prim->numverts; i++){
    c[0] += prim->verts[i]\&.xyz[0];
    c[1] += prim->verts[i]\&.xyz[1];
  }
  c[0] /= prim->numverts;
  c[1] /= prim->numverts;

  for(i = 0; i < prim->numverts; i++){
    if(prim->boundary & (GLint)pow(2\&., i)){
      b = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
      b->type = GL2PS_LINE;
      b->offset = prim->offset;
      b->pattern = prim->pattern;
      b->factor = prim->factor;
      b->culled = prim->culled;
      b->width = prim->width;
      b->boundary = 0;
      b->numverts = 2;
      b->verts = (GL2PSvertex*)gl2psMalloc(2 * sizeof(GL2PSvertex));

#if 0 /* FIXME: need to work on boundary offset\&.\&.\&. */
      v[0] = c[0] - prim->verts[i]\&.xyz[0];
      v[1] = c[1] - prim->verts[i]\&.xyz[1];
      v[2] = 0\&.0F;
      norm = gl2psNorm(v);
      v[0] /= norm;
      v[1] /= norm;
      b->verts[0]\&.xyz[0] = prim->verts[i]\&.xyz[0] +0\&.1*v[0];
      b->verts[0]\&.xyz[1] = prim->verts[i]\&.xyz[1] +0\&.1*v[1];
      b->verts[0]\&.xyz[2] = prim->verts[i]\&.xyz[2];
      v[0] = c[0] - prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[0];
      v[1] = c[1] - prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[1];
      norm = gl2psNorm(v);
      v[0] /= norm;
      v[1] /= norm;
      b->verts[1]\&.xyz[0] = prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[0] +0\&.1*v[0];
      b->verts[1]\&.xyz[1] = prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[1] +0\&.1*v[1];
      b->verts[1]\&.xyz[2] = prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[2];
#else
      b->verts[0]\&.xyz[0] = prim->verts[i]\&.xyz[0];
      b->verts[0]\&.xyz[1] = prim->verts[i]\&.xyz[1];
      b->verts[0]\&.xyz[2] = prim->verts[i]\&.xyz[2];
      b->verts[1]\&.xyz[0] = prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[0];
      b->verts[1]\&.xyz[1] = prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[1];
      b->verts[1]\&.xyz[2] = prim->verts[gl2psGetIndex(i, prim->numverts)]\&.xyz[2];
#endif

      b->verts[0]\&.rgba[0] = 0\&.0F;
      b->verts[0]\&.rgba[1] = 0\&.0F;
      b->verts[0]\&.rgba[2] = 0\&.0F;
      b->verts[0]\&.rgba[3] = 0\&.0F;
      b->verts[1]\&.rgba[0] = 0\&.0F;
      b->verts[1]\&.rgba[1] = 0\&.0F;
      b->verts[1]\&.rgba[2] = 0\&.0F;
      b->verts[1]\&.rgba[3] = 0\&.0F;
      gl2psListAdd(list, &b);
    }
  }

}
.fi
.SS "static GLint \fBgl2psAddInBspImageTree\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSbsptree2d\fP **tree)\fC [static]\fP"
.PP
Definition at line 2042 of file gl2ps\&.c\&.
.PP
References GL2PS_COINCIDENT, GL2PS_IMAGEMAP, GL2PS_IN_BACK_OF, GL2PS_IN_FRONT_OF, GL2PS_LINE, GL2PS_PIXMAP, GL2PS_SPANNING, GL2PS_SPECIAL, GL2PS_TEXT, gl2psAddPlanesInBspTreeImage(), gl2psCheckPrimitive(), gl2psFree(), gl2psSplitPrimitive2D(), GL2PScontext::primitivetoadd, ret, GL2PSprimitive::type, GL2PSprimitive::verts, and GL2PScontext::zerosurfacearea\&.
.PP
Referenced by gl2psAddInImageTree()\&.
.PP
.nf
{
  GLint ret = 0;
  GL2PSprimitive *frontprim = NULL, *backprim = NULL;
  
  /* FIXME: until we consider the actual extent of text strings and
     pixmaps, never cull them\&. Otherwise the whole string/pixmap gets
     culled as soon as the reference point is hidden */
  if(prim->type == GL2PS_PIXMAP || 
     prim->type == GL2PS_TEXT || 
     prim->type == GL2PS_SPECIAL){
    return 1;
  }

  if(*tree == NULL){
    if((prim->type != GL2PS_IMAGEMAP) && (GL_FALSE == gl2ps->zerosurfacearea)){
      gl2psAddPlanesInBspTreeImage(gl2ps->primitivetoadd, tree);
    }
    return 1;
  }
  else{
    switch(gl2psCheckPrimitive(prim, (*tree)->plane)){
    case GL2PS_IN_BACK_OF: return gl2psAddInBspImageTree(prim, &(*tree)->back);
    case GL2PS_IN_FRONT_OF: 
      if((*tree)->front != NULL) return gl2psAddInBspImageTree(prim, &(*tree)->front);
      else                       return 0;
    case GL2PS_SPANNING:
      gl2psSplitPrimitive2D(prim, (*tree)->plane, &frontprim, &backprim);
      ret = gl2psAddInBspImageTree(backprim, &(*tree)->back);
      if((*tree)->front != NULL){
        if(gl2psAddInBspImageTree(frontprim, &(*tree)->front)){
          ret = 1;
        }
      }
      gl2psFree(frontprim->verts);
      gl2psFree(frontprim);
      gl2psFree(backprim->verts);
      gl2psFree(backprim);
      return ret;
    case GL2PS_COINCIDENT:
      if((*tree)->back != NULL){
        gl2ps->zerosurfacearea = GL_TRUE;
        ret = gl2psAddInBspImageTree(prim, &(*tree)->back);
        gl2ps->zerosurfacearea = GL_FALSE;
        if(ret) return ret;
      }
      if((*tree)->front != NULL){
        gl2ps->zerosurfacearea = GL_TRUE;
        ret = gl2psAddInBspImageTree(prim, &(*tree)->front);
        gl2ps->zerosurfacearea = GL_FALSE;
        if(ret) return ret;
      }
      if(prim->type == GL2PS_LINE) return 1;
      else                         return 0;
    }
  }
  return 0;
}
.fi
.SS "static void \fBgl2psAddIndex\fP (GLshort *index0, GLshort *index1, GLshort *nb, GLshorti, GLshortj)\fC [static]\fP"
.PP
Definition at line 1295 of file gl2ps\&.c\&.
.PP
References i, and k\&.
.PP
Referenced by gl2psSplitPrimitive()\&.
.PP
.nf
{
  GLint k;

  for(k = 0; k < *nb; k++){
    if((index0[k] == i && index1[k] == j) ||
       (index1[k] == i && index0[k] == j)) return;
  }
  index0[*nb] = i;
  index1[*nb] = j;
  (*nb)++;
}
.fi
.SS "static void \fBgl2psAddInImageTree\fP (void *data)\fC [static]\fP"
.PP
Definition at line 2101 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSimage::format, GL2PS_IMAGEMAP, GL2PS_IMAGEMAP_VISIBLE, gl2psAddInBspImageTree(), GL2PSprimitive::image, GL2PScontext::imagetree, GL2PScontext::primitivetoadd, and GL2PSprimitive::type\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  GL2PSprimitive *prim = *(GL2PSprimitive **)data;
  gl2ps->primitivetoadd = prim;
  if(prim->type == GL2PS_IMAGEMAP && prim->data\&.image->format == GL2PS_IMAGEMAP_VISIBLE){
    prim->culled = 1;
  }
  else if(!gl2psAddInBspImageTree(prim, &gl2ps->imagetree)){
    prim->culled = 1;
  }
  else if(prim->type == GL2PS_IMAGEMAP){
    prim->data\&.image->format = GL2PS_IMAGEMAP_VISIBLE;
  }
}
.fi
.SS "static void \fBgl2psAddPlanesInBspTreeImage\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSbsptree2d\fP **tree)\fC [static]\fP"
.PP
Definition at line 1809 of file gl2ps\&.c\&.
.PP
References _GL2PSbsptree2d::back, _GL2PSbsptree2d::front, GL2PS_POINT_BACK, GL2PS_POINT_COINCIDENT, GL2PS_POINT_INFRONT, gl2psCheckPoint(), gl2psFree(), gl2psGetPlaneFromPoints(), gl2psMalloc(), i, GL2PSprimitive::numverts, _GL2PSbsptree2d::plane, ret, GL2PSprimitive::verts, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psAddInBspImageTree()\&.
.PP
.nf
{
  GLint ret = 0;
  GLint i;
  GLint offset = 0;
  GL2PSbsptree2d *head = NULL, *cur = NULL;

  if((*tree == NULL) && (prim->numverts > 2)){
    head = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
    for(i = 0; i < prim->numverts-1; i++){
      if(!gl2psGetPlaneFromPoints(prim->verts[i]\&.xyz,
                                  prim->verts[i+1]\&.xyz,
                                  head->plane)){
        if(prim->numverts-i > 3){
          offset++;
        }
        else{
          gl2psFree(head);
          return;
        }
      }
      else{
        break;
      }
    }
    head->back = NULL;
    head->front = NULL;
    for(i = 2+offset; i < prim->numverts; i++){
      ret = gl2psCheckPoint(prim->verts[i]\&.xyz, head->plane);
      if(ret != GL2PS_POINT_COINCIDENT) break;
    }
    switch(ret){
    case GL2PS_POINT_INFRONT :
      cur = head;
      for(i = 1+offset; i < prim->numverts-1; i++){
        if(cur->front == NULL){
          cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
        }
        if(gl2psGetPlaneFromPoints(prim->verts[i]\&.xyz,
                                   prim->verts[i+1]\&.xyz,
                                   cur->front->plane)){
          cur = cur->front;
          cur->front = NULL;
          cur->back = NULL;
        }
      }
      if(cur->front == NULL){
        cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
      }
      if(gl2psGetPlaneFromPoints(prim->verts[i]\&.xyz,
                                 prim->verts[offset]\&.xyz,
                                 cur->front->plane)){
        cur->front->front = NULL;
        cur->front->back = NULL;
      }
      else{
        gl2psFree(cur->front);
        cur->front = NULL;
      }
      break;
    case GL2PS_POINT_BACK :
      for(i = 0; i < 4; i++){
        head->plane[i] = -head->plane[i];
      }
      cur = head;
      for(i = 1+offset; i < prim->numverts-1; i++){
        if(cur->front == NULL){
          cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
        }
        if(gl2psGetPlaneFromPoints(prim->verts[i+1]\&.xyz,
                                   prim->verts[i]\&.xyz,
                                   cur->front->plane)){
          cur = cur->front;
          cur->front = NULL;
          cur->back = NULL;
        }
      }
      if(cur->front == NULL){
        cur->front = (GL2PSbsptree2d*)gl2psMalloc(sizeof(GL2PSbsptree2d));
      }
      if(gl2psGetPlaneFromPoints(prim->verts[offset]\&.xyz,
                                 prim->verts[i]\&.xyz,
                                 cur->front->plane)){
        cur->front->front = NULL;
        cur->front->back = NULL;
      }
      else{
        gl2psFree(cur->front);
        cur->front = NULL;
      }
      break;
    default:
      gl2psFree(head);
      return;
    }
    (*tree) = head;
  }
}
.fi
.SS "static void \fBgl2psAddPolyPrimitive\fP (GLshorttype, GLshortnumverts, \fBGL2PSvertex\fP *verts, GLintoffset, GLushortpattern, GLintfactor, GLfloatwidth, charboundary)\fC [static]\fP"
.PP
Definition at line 2206 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::boundary, GL2PSprimitive::culled, GL2PSprimitive::factor, gl2psListAdd(), gl2psMalloc(), GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PSprimitive::pattern, GL2PScontext::primitives, type, GL2PSprimitive::type, GL2PSprimitive::verts, width, and GL2PSprimitive::width\&.
.PP
Referenced by gl2psParseFeedbackBuffer()\&.
.PP
.nf
{
  GL2PSprimitive *prim;

  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
  prim->type = type;
  prim->numverts = numverts;
  prim->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
  memcpy(prim->verts, verts, numverts * sizeof(GL2PSvertex));
  prim->boundary = boundary;
  prim->offset = offset;
  prim->pattern = pattern;
  prim->factor = factor;
  prim->width = width;
  prim->culled = 0;

  /* FIXME: here we should have an option to split stretched
     tris/quads to enhance SIMPLE_SORT */

  gl2psListAdd(gl2ps->primitives, &prim);
}
.fi
.SS "static void \fBgl2psAddPrimitiveInList\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSlist\fP *list)\fC [static]\fP"
.PP
Definition at line 1540 of file gl2ps\&.c\&.
.PP
References GL2PS_QUADRANGLE, gl2psDivideQuad(), gl2psFreePrimitive(), gl2psListAdd(), and GL2PSprimitive::type\&.
.PP
Referenced by gl2psBuildBspTree()\&.
.PP
.nf
{
  GL2PSprimitive *t1, *t2;

  if(prim->type != GL2PS_QUADRANGLE){
    gl2psListAdd(list, &prim);
  }
  else{
    gl2psDivideQuad(prim, &t1, &t2);
    gl2psListAdd(list, &t1);
    gl2psListAdd(list, &t2);
    gl2psFreePrimitive(&prim);
  }
  
}
.fi
.SS "static GLint \fBgl2psAddText\fP (GLinttype, const char *str, const char *fontname, GLshortfontsize, GLintalignment, GLfloatangle, GLfloatmargin, GLbooleanoffsetmargin, GLfloatlwidth, \fBGL2PSrgba\fPlc, GLushortlpattern, GLintlfactor, \fBGL2PSrgba\fPfc)\fC [static]\fP"
.PP
Definition at line 870 of file gl2ps\&.c\&.
.PP
References GL2PSstring::alignment, angle, GL2PSstring::angle, GL2PScontext::auxprimitives, GL2PSprimitive::boundary, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSstring::depthtest, GL2PSprimitive::factor, GL2PSstring::fillcolor, GL2PSstring::fontname, GL2PSstring::fontsize, GL2PS_NO_TEXT, GL2PS_SUCCESS, GL2PS_TEXT_TOKEN, GL2PS_UNINITIALIZED, gl2psListAdd(), gl2psMalloc(), GL2PSstring::linecolor, GL2PSstring::linefactor, GL2PSstring::linepattern, GL2PSstring::linewidth, GL2PSstring::margin, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PSstring::offsetmargin, GL2PScontext::options, GL2PSprimitive::pattern, GL2PSvertex::rgba, GL2PSstring::str, GL2PSprimitive::text, type, GL2PSprimitive::type, GL2PSprimitive::verts, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psSpecial(), gl2psText(), and gl2psTextOpt()\&.
.PP
.nf
{
  GLfloat pos[4];
  GL2PSprimitive *prim;
  GLboolean valid;

  if(!gl2ps || !str || !fontname) return GL2PS_UNINITIALIZED;

  if(gl2ps->options & GL2PS_NO_TEXT) return GL2PS_SUCCESS;

  glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
  if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */

  glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);

  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
  prim->type = type;
  prim->boundary = 0;
  prim->numverts = 1;
  prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
  prim->verts[0]\&.xyz[0] = pos[0];
  prim->verts[0]\&.xyz[1] = pos[1];
  prim->verts[0]\&.xyz[2] = pos[2];
  prim->culled = 0;
  prim->offset = 0;
  prim->pattern = 0;
  prim->factor = 0;
  prim->width = 1;
  glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0]\&.rgba);
  prim->data\&.text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
  prim->data\&.text->str = (char*)gl2psMalloc((strlen(str)+1)*sizeof(char));
  strcpy(prim->data\&.text->str, str); 
  prim->data\&.text->fontname = (char*)gl2psMalloc((strlen(fontname)+1)*sizeof(char));
  strcpy(prim->data\&.text->fontname, fontname);
  prim->data\&.text->fontsize = fontsize;
  prim->data\&.text->alignment = alignment;
  prim->data\&.text->angle = angle;
  prim->data\&.text->margin = margin;
  prim->data\&.text->offsetmargin = offsetmargin;
  prim->data\&.text->linewidth = lwidth;
  if (lwidth > 0 && lc != NULL)
  {
    prim->data\&.text->linecolor[0] = lc[0];
    prim->data\&.text->linecolor[1] = lc[1];
    prim->data\&.text->linecolor[2] = lc[2];
    prim->data\&.text->linecolor[3] = lc[3];
  }
  else
    prim->data\&.text->linecolor[0] = -1\&.0F;
  prim->data\&.text->linepattern = lpattern;
  prim->data\&.text->linefactor = lfactor;
  if (fc != NULL)
  {
    prim->data\&.text->fillcolor[0] = fc[0];
    prim->data\&.text->fillcolor[1] = fc[1];
    prim->data\&.text->fillcolor[2] = fc[2];
    prim->data\&.text->fillcolor[3] = fc[3];
  }
  else
    prim->data\&.text->fillcolor[0] = -1\&.0F;
  glGetBooleanv(GL_DEPTH_TEST, &(prim->data\&.text->depthtest));

  gl2psListAdd(gl2ps->auxprimitives, &prim);
  glPassThrough(GL2PS_TEXT_TOKEN);
    
  return GL2PS_SUCCESS;
}
.fi
.SS "static void \fBgl2psAssignTriangleProperties\fP (\fBGL2PStriangle\fP *t)\fC [static]\fP"
.PP
Definition at line 1015 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO, GL2PStriangle::prop, GL2PSvertex::rgba, T_ALPHA_1, T_ALPHA_LESS_1, T_VAR_ALPHA, T_VAR_COLOR, and GL2PStriangle::vertex\&.
.PP
Referenced by gl2psFillTriangleFromPrimitive()\&.
.PP
.nf
{
  /* int i; */

  t->prop = T_VAR_COLOR;

  /* Uncommenting the following lines activates an even more fine
     grained distinction between triangle types - please don't delete,
     a remarkable amount of PDF handling code inside this file depends
     on it if activated */
  /*
  t->prop = T_CONST_COLOR;    
  for(i = 0; i < 3; ++i){
    if(!GL2PS_ZERO(t->vertex[0]\&.rgba[i] - t->vertex[1]\&.rgba[i]) || 
       !GL2PS_ZERO(t->vertex[1]\&.rgba[i] - t->vertex[2]\&.rgba[i])){
      t->prop = T_VAR_COLOR;
      break;
    }
  }
  */

  if(!GL2PS_ZERO(t->vertex[0]\&.rgba[3] - t->vertex[1]\&.rgba[3]) || 
     !GL2PS_ZERO(t->vertex[1]\&.rgba[3] - t->vertex[2]\&.rgba[3])){
    t->prop |= T_VAR_ALPHA;
  }
  else{
    if(t->vertex[0]\&.rgba[3] < 1)
      t->prop |= T_ALPHA_LESS_1;
    else
      t->prop |= T_ALPHA_1;
  }
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psBeginPage\fP (const char *title, const char *producer, GLintviewport[4], GLintformat, GLintsort, GLintoptions, GLintcolormode, GLintcolorsize, \fBGL2PSrgba\fP *colormap, GLintnr, GLintng, GLintnb, GLintbuffersize, FILE *stream, const char *filename)"
.PP
Definition at line 5664 of file gl2ps\&.c\&.
.PP
References GL2PScontext::auxprimitives, GL2PScontext::bgcolor, GL2PScontext::blendfunc, GL2PScontext::blending, GL2PScontext::buffersize, GL2PScontext::colormap, GL2PScontext::colormode, GL2PScontext::colorsize, GL2PScontext::compress, GL2PScontext::feedback, GL2PScontext::filename, GL2PScontext::format, GL2PS_BSP_SORT, GL2PS_ERROR, GL2PS_NO_SORT, GL2PS_SIMPLE_SORT, GL2PS_SUCCESS, GL2PS_SVG, GL2PS_USE_CURRENT_VIEWPORT, gl2psbackends, gl2psFree(), gl2psListCreate(), gl2psMalloc(), gl2psMsg(), GL2PScontext::header, i, GL2PScontext::imagemap_head, GL2PScontext::imagemap_tail, GL2PScontext::imagetree, GL2PScontext::lastfactor, GL2PScontext::lastlinewidth, GL2PScontext::lastpattern, GL2PScontext::lastrgba, GL2PScontext::lastvertex, GL2PScontext::maxbestroot, GL2PScontext::options, GL2PScontext::pdfgrouplist, GL2PScontext::pdfprimlist, GL2PScontext::primitives, GL2PScontext::primitivetoadd, GL2PScontext::producer, GL2PSvertex::rgba, GL2PScontext::sort, stream, GL2PScontext::stream, GL2PScontext::threshold, GL2PScontext::title, GL2PScontext::viewport, GL2PScontext::xreflist, GL2PSvertex::xyz, and GL2PScontext::zerosurfacearea\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psBeginPage()\&.
.PP
.nf
{
  GLint index;
  int i;

  if(gl2ps){
    gl2psMsg(GL2PS_ERROR, 'gl2psBeginPage called in wrong program state');
    return GL2PS_ERROR;
  }

  gl2ps = (GL2PScontext*)gl2psMalloc(sizeof(GL2PScontext));

  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends)/sizeof(gl2psbackends[0]))){
    gl2ps->format = format;
  }
  else {
    gl2psMsg(GL2PS_ERROR, 'Unknown output format: %d', format);
    gl2psFree(gl2ps);
    gl2ps = NULL;
    return GL2PS_ERROR;
  }

  switch(sort){
  case GL2PS_NO_SORT :
  case GL2PS_SIMPLE_SORT :
  case GL2PS_BSP_SORT :
    gl2ps->sort = sort;
    break;
  default :
    gl2psMsg(GL2PS_ERROR, 'Unknown sorting algorithm: %d', sort);
    gl2psFree(gl2ps);
    gl2ps = NULL;
    return GL2PS_ERROR;
  }

  if(stream){
    gl2ps->stream = stream;
  }
  else{
    gl2psMsg(GL2PS_ERROR, 'Bad file pointer');
    gl2psFree(gl2ps);
    gl2ps = NULL;
    return GL2PS_ERROR;
  }

  gl2ps->header = GL_TRUE;
  gl2ps->maxbestroot = 10;
  gl2ps->options = options;
  gl2ps->compress = NULL;
  gl2ps->imagemap_head = NULL;
  gl2ps->imagemap_tail = NULL;

  if(gl2ps->options & GL2PS_USE_CURRENT_VIEWPORT){
    glGetIntegerv(GL_VIEWPORT, gl2ps->viewport);
  }
  else{
    for(i = 0; i < 4; i++){
      gl2ps->viewport[i] = viewport[i];
    }
  }

  if(!gl2ps->viewport[2] || !gl2ps->viewport[3]){
    gl2psMsg(GL2PS_ERROR, 'Incorrect viewport (x=%d, y=%d, width=%d, height=%d)',
             gl2ps->viewport[0], gl2ps->viewport[1], 
             gl2ps->viewport[2], gl2ps->viewport[3]);
    gl2psFree(gl2ps);
    gl2ps = NULL;
    return GL2PS_ERROR;
  }

  gl2ps->threshold[0] = nr ? 1\&.0F/(GLfloat)nr : 0\&.064F;
  gl2ps->threshold[1] = ng ? 1\&.0F/(GLfloat)ng : 0\&.034F;
  gl2ps->threshold[2] = nb ? 1\&.0F/(GLfloat)nb : 0\&.100F;
  gl2ps->colormode = colormode;
  gl2ps->buffersize = buffersize > 0 ? buffersize : 2048 * 2048;
  for(i = 0; i < 3; i++){
    gl2ps->lastvertex\&.xyz[i] = -1\&.0F;
  }
  for(i = 0; i < 4; i++){
    gl2ps->lastvertex\&.rgba[i] = -1\&.0F;
    gl2ps->lastrgba[i] = -1\&.0F;
  }
  gl2ps->lastlinewidth = -1\&.0F;
  gl2ps->lastpattern = 0;
  gl2ps->lastfactor = 0;
  gl2ps->imagetree = NULL;
  gl2ps->primitivetoadd = NULL;
  gl2ps->zerosurfacearea = GL_FALSE;  
  gl2ps->pdfprimlist = NULL;
  gl2ps->pdfgrouplist = NULL;
  gl2ps->xreflist = NULL;
  
  /* get default blending mode from current OpenGL state (enabled by
     default for SVG) */
  gl2ps->blending = (gl2ps->format == GL2PS_SVG) ? GL_TRUE : glIsEnabled(GL_BLEND);
  glGetIntegerv(GL_BLEND_SRC, &gl2ps->blendfunc[0]);
  glGetIntegerv(GL_BLEND_DST, &gl2ps->blendfunc[1]);

  if(gl2ps->colormode == GL_RGBA){
    gl2ps->colorsize = 0;
    gl2ps->colormap = NULL;
    glGetFloatv(GL_COLOR_CLEAR_VALUE, gl2ps->bgcolor);
  }
  else if(gl2ps->colormode == GL_COLOR_INDEX){
    if(!colorsize || !colormap){
      gl2psMsg(GL2PS_ERROR, 'Missing colormap for GL_COLOR_INDEX rendering');
      gl2psFree(gl2ps);
      gl2ps = NULL;
      return GL2PS_ERROR;
    }
    gl2ps->colorsize = colorsize;
    gl2ps->colormap = (GL2PSrgba*)gl2psMalloc(gl2ps->colorsize * sizeof(GL2PSrgba));
    memcpy(gl2ps->colormap, colormap, gl2ps->colorsize * sizeof(GL2PSrgba));
    glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
    gl2ps->bgcolor[0] = gl2ps->colormap[index][0];
    gl2ps->bgcolor[1] = gl2ps->colormap[index][1];
    gl2ps->bgcolor[2] = gl2ps->colormap[index][2];
    gl2ps->bgcolor[3] = 1\&.0F;
  }
  else{
    gl2psMsg(GL2PS_ERROR, 'Unknown color mode in gl2psBeginPage');
    gl2psFree(gl2ps);
    gl2ps = NULL;
    return GL2PS_ERROR;
  }

  if(!title){
    gl2ps->title = (char*)gl2psMalloc(sizeof(char));
    gl2ps->title[0] = '\0';
  }
  else{
    gl2ps->title = (char*)gl2psMalloc((strlen(title)+1)*sizeof(char));
    strcpy(gl2ps->title, title);
  }
    
  if(!producer){
    gl2ps->producer = (char*)gl2psMalloc(sizeof(char));
    gl2ps->producer[0] = '\0';
  }
  else{
    gl2ps->producer = (char*)gl2psMalloc((strlen(producer)+1)*sizeof(char));
    strcpy(gl2ps->producer, producer);
  }
  
  if(!filename){
    gl2ps->filename = (char*)gl2psMalloc(sizeof(char));
    gl2ps->filename[0] = '\0';
  }
  else{
    gl2ps->filename = (char*)gl2psMalloc((strlen(filename)+1)*sizeof(char));
    strcpy(gl2ps->filename, filename);
  }

  gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
  gl2ps->auxprimitives = gl2psListCreate(100, 100, sizeof(GL2PSprimitive*));
  gl2ps->feedback = (GLfloat*)gl2psMalloc(gl2ps->buffersize * sizeof(GLfloat));
  glFeedbackBuffer(gl2ps->buffersize, GL_3D_COLOR, gl2ps->feedback);
  glRenderMode(GL_FEEDBACK);  

  return GL2PS_SUCCESS;
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psBeginViewport\fP (GLintviewport[4])"
.PP
Definition at line 5858 of file gl2ps\&.c\&.
.PP
References GL2PSbackend::beginViewport, GL2PScontext::format, GL2PS_SUCCESS, and GL2PS_UNINITIALIZED\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psBeginViewport()\&.
.PP
.nf
{
  if(!gl2ps) return GL2PS_UNINITIALIZED;

  (gl2psbackends[gl2ps->format]->beginViewport)(viewport);
  
  return GL2PS_SUCCESS;
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psBlendFunc\fP (GLenumsfactor, GLenumdfactor)"
.PP
Definition at line 6086 of file gl2ps\&.c\&.
.PP
References GL2PS_DST_BLEND_TOKEN, GL2PS_SRC_BLEND_TOKEN, GL2PS_SUCCESS, GL2PS_UNINITIALIZED, GL2PS_WARNING, and gl2psSupportedBlendMode()\&.
.PP
.nf
{
  if(!gl2ps) return GL2PS_UNINITIALIZED;

  if(GL_FALSE == gl2psSupportedBlendMode(sfactor, dfactor))
    return GL2PS_WARNING;

  glPassThrough(GL2PS_SRC_BLEND_TOKEN);
  glPassThrough((GLfloat)sfactor);
  glPassThrough(GL2PS_DST_BLEND_TOKEN);
  glPassThrough((GLfloat)dfactor);

  return GL2PS_SUCCESS;
}
.fi
.SS "static void \fBgl2psBuildBspTree\fP (\fBGL2PSbsptree\fP *tree, \fBGL2PSlist\fP *primitives)\fC [static]\fP"
.PP
Definition at line 1582 of file gl2ps\&.c\&.
.PP
References _GL2PSbsptree::back, GL2PSprimitive::data, GL2PSstring::depthtest, _GL2PSbsptree::front, GL2PS_COINCIDENT, GL2PS_IN_BACK_OF, GL2PS_IN_FRONT_OF, GL2PS_SPANNING, GL2PS_TEXT, gl2psAddPrimitiveInList(), gl2psFindRoot(), gl2psFreePrimitive(), gl2psGetPlane(), gl2psListCreate(), gl2psListDelete(), gl2psListNbr(), gl2psListPointer(), gl2psListSort(), gl2psMalloc(), gl2psSplitPrimitive(), gl2psTrianglesFirst(), i, _GL2PSbsptree::plane, _GL2PSbsptree::primitives, GL2PSprimitive::text, and GL2PSprimitive::type\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  GL2PSprimitive *prim, *frontprim = NULL, *backprim = NULL;
  GL2PSlist *frontlist, *backlist;
  GLint i, index;

  tree->front = NULL;
  tree->back = NULL;
  tree->primitives = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
  index = gl2psFindRoot(primitives, &prim);
  gl2psGetPlane(prim, tree->plane);
  gl2psAddPrimitiveInList(prim, tree->primitives);

  frontlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
  backlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));

  for(i = 0; i < gl2psListNbr(primitives); i++){
    if(i != index){
      prim = *(GL2PSprimitive**)gl2psListPointer(primitives,i);
      if (prim->type == GL2PS_TEXT && prim->data\&.text->depthtest == GL_FALSE) {
        gl2psAddPrimitiveInList(prim, backlist);
        continue;
      }
      switch(gl2psSplitPrimitive(prim, tree->plane, &frontprim, &backprim)){
      case GL2PS_COINCIDENT:
        gl2psAddPrimitiveInList(prim, tree->primitives);
        break;
      case GL2PS_IN_BACK_OF:
        gl2psAddPrimitiveInList(prim, backlist);
        break;
      case GL2PS_IN_FRONT_OF:
        gl2psAddPrimitiveInList(prim, frontlist);
        break;
      case GL2PS_SPANNING:
        gl2psAddPrimitiveInList(backprim, backlist);
        gl2psAddPrimitiveInList(frontprim, frontlist);
        gl2psFreePrimitive(&prim);
        break;
      }
    }
  }

  if(gl2psListNbr(tree->primitives)){
    gl2psListSort(tree->primitives, gl2psTrianglesFirst);
  }

  if(gl2psListNbr(frontlist)){
    gl2psListSort(frontlist, gl2psTrianglesFirst);
    tree->front = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
    gl2psBuildBspTree(tree->front, frontlist);
  }
  else{
    gl2psListDelete(frontlist);
  }

  if(gl2psListNbr(backlist)){
    gl2psListSort(backlist, gl2psTrianglesFirst);
    tree->back = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
    gl2psBuildBspTree(tree->back, backlist);
  }
  else{
    gl2psListDelete(backlist);
  }

  gl2psListDelete(primitives);
}
.fi
.SS "static void \fBgl2psBuildPolygonBoundary\fP (\fBGL2PSbsptree\fP *tree)\fC [static]\fP"
.PP
Definition at line 2186 of file gl2ps\&.c\&.
.PP
References _GL2PSbsptree::back, GL2PSprimitive::boundary, _GL2PSbsptree::front, gl2psAddBoundaryInList(), gl2psListNbr(), gl2psListPointer(), i, and _GL2PSbsptree::primitives\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  GLint i;
  GL2PSprimitive *prim;

  if(!tree) return;
  gl2psBuildPolygonBoundary(tree->back);
  for(i = 0; i < gl2psListNbr(tree->primitives); i++){
    prim = *(GL2PSprimitive**)gl2psListPointer(tree->primitives, i);
    if(prim->boundary) gl2psAddBoundaryInList(prim, tree->primitives);
  }
  gl2psBuildPolygonBoundary(tree->front);
}
.fi
.SS "static GLint \fBgl2psCheckPoint\fP (\fBGL2PSxyz\fPpoint, \fBGL2PSplane\fPplane)\fC [static]\fP"
.PP
Definition at line 1799 of file gl2ps\&.c\&.
.PP
References GL2PS_EPSILON, GL2PS_POINT_BACK, GL2PS_POINT_COINCIDENT, GL2PS_POINT_INFRONT, and gl2psComparePointPlane()\&.
.PP
Referenced by gl2psAddPlanesInBspTreeImage(), gl2psCheckPrimitive(), and gl2psSplitPrimitive2D()\&.
.PP
.nf
{
  GLfloat pt_dis;

  pt_dis = gl2psComparePointPlane(point, plane);
  if(pt_dis > GL2PS_EPSILON)        return GL2PS_POINT_INFRONT;
  else if(pt_dis < -GL2PS_EPSILON)  return GL2PS_POINT_BACK;
  else                              return GL2PS_POINT_COINCIDENT;
}
.fi
.SS "static GLint \fBgl2psCheckPrimitive\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fPplane)\fC [static]\fP"
.PP
Definition at line 1909 of file gl2ps\&.c\&.
.PP
References GL2PS_COINCIDENT, GL2PS_IN_BACK_OF, GL2PS_IN_FRONT_OF, GL2PS_POINT_BACK, GL2PS_POINT_INFRONT, GL2PS_SPANNING, gl2psCheckPoint(), i, GL2PSprimitive::numverts, GL2PSprimitive::verts, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psAddInBspImageTree()\&.
.PP
.nf
{
  GLint i;
  GLint pos;

  pos = gl2psCheckPoint(prim->verts[0]\&.xyz, plane);
  for(i = 1; i < prim->numverts; i++){
    pos |= gl2psCheckPoint(prim->verts[i]\&.xyz, plane);
    if(pos == (GL2PS_POINT_INFRONT | GL2PS_POINT_BACK)) return GL2PS_SPANNING;
  }
  if(pos & GL2PS_POINT_INFRONT)   return GL2PS_IN_FRONT_OF;
  else if(pos & GL2PS_POINT_BACK) return GL2PS_IN_BACK_OF;
  else                            return GL2PS_COINCIDENT;
}
.fi
.SS "static int \fBgl2psClosePDFDataStream\fP (void)\fC [static]\fP"
.PP
Definition at line 4182 of file gl2ps\&.c\&.
.PP
References GL2PScontext::compress, GL2PS_COMPRESS, GL2PS_ERROR, gl2psMsg(), GL2PScontext::options, GL2PScontext::stream, and GL2PScontext::streamlength\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  int offs = 0;
 
#if defined(GL2PS_HAVE_ZLIB)
  if(gl2ps->options & GL2PS_COMPRESS){
    if(Z_OK != gl2psDeflate())
      gl2psMsg(GL2PS_ERROR, 'Zlib deflate error');
    else
      fwrite(gl2ps->compress->dest, gl2ps->compress->destLen, 1, gl2ps->stream);
    gl2ps->streamlength += gl2ps->compress->destLen;
    
    offs += gl2ps->streamlength;
    gl2psFreeCompress();
  }
#endif 
  
  offs += fprintf(gl2ps->stream, 
                  'endstream\n'
                  'endobj\n');
  return offs;
}
.fi
.SS "static int \fBgl2psCompareDepth\fP (const void *a, const void *b)\fC [static]\fP"
.PP
Definition at line 1429 of file gl2ps\&.c\&.
.PP
References i, GL2PSprimitive::numverts, GL2PSprimitive::verts, w, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  GL2PSprimitive *q, *w;
  GLfloat dq = 0\&.0F, dw = 0\&.0F, diff;
  int i;
  
  q = *(GL2PSprimitive**)a;
  w = *(GL2PSprimitive**)b;

  for(i = 0; i < q->numverts; i++){
    dq += q->verts[i]\&.xyz[2]; 
  }
  dq /= (GLfloat)q->numverts;

  for(i = 0; i < w->numverts; i++){
    dw += w->verts[i]\&.xyz[2]; 
  }
  dw /= (GLfloat)w->numverts;

  diff = dq - dw;
  if(diff > 0\&.){
    return -1;
  }
  else if(diff < 0\&.){
    return 1;
  }
  else{
    return 0;
  }
}
.fi
.SS "static GLfloat \fBgl2psComparePointPlane\fP (\fBGL2PSxyz\fPpoint, \fBGL2PSplane\fPplane)\fC [static]\fP"
.PP
Definition at line 1121 of file gl2ps\&.c\&.
.PP
Referenced by gl2psCheckPoint(), gl2psCutEdge(), gl2psSplitPrimitive(), gl2psTestSplitPrimitive(), and gl2psTraverseBspTree()\&.
.PP
.nf
{
  return(plane[0] * point[0] + 
         plane[1] * point[1] + 
         plane[2] * point[2] + 
         plane[3]);
}
.fi
.SS "static void \fBgl2psComputeTightBoundingBox\fP (void *data)\fC [static]\fP"
.PP
Definition at line 5565 of file gl2ps\&.c\&.
.PP
References i, GL2PSprimitive::numverts, GL2PSprimitive::verts, GL2PScontext::viewport, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  GL2PSprimitive *prim;
  int i;

  prim = *(GL2PSprimitive**)data;

  for(i = 0; i < prim->numverts; i++){
    if(prim->verts[i]\&.xyz[0] < gl2ps->viewport[0])
      gl2ps->viewport[0] = (GLint)prim->verts[i]\&.xyz[0];
    if(prim->verts[i]\&.xyz[0] > gl2ps->viewport[2])
      gl2ps->viewport[2] = (GLint)(prim->verts[i]\&.xyz[0] + 0\&.5F);
    if(prim->verts[i]\&.xyz[1] < gl2ps->viewport[1])
      gl2ps->viewport[1] = (GLint)prim->verts[i]\&.xyz[1];
    if(prim->verts[i]\&.xyz[1] > gl2ps->viewport[3])
      gl2ps->viewport[3] = (GLint)(prim->verts[i]\&.xyz[1] + 0\&.5F);
  }
}  
.fi
.SS "static \fBGL2PSimage\fP* \fBgl2psCopyPixmap\fP (\fBGL2PSimage\fP *im)\fC [static]\fP"
.PP
Definition at line 770 of file gl2ps\&.c\&.
.PP
References GL2PSimage::format, gl2psMalloc(), GL2PSimage::height, GL2PSimage::pixels, GL2PSimage::type, and GL2PSimage::width\&.
.PP
Referenced by gl2psCopyPrimitive()\&.
.PP
.nf
{
  int size;
  GL2PSimage *image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
  
  image->width = im->width;
  image->height = im->height;
  image->format = im->format;
  image->type = im->type;

  switch(image->format){
  case GL_RGBA:
    size = image->height * image->width * 4 * sizeof(GLfloat);
    break;
  case GL_RGB:
  default:
    size = image->height * image->width * 3 * sizeof(GLfloat);
    break;
  }

  image->pixels = (GLfloat*)gl2psMalloc(size);
  memcpy(image->pixels, im->pixels, size);
  
  return image;
}
.fi
.SS "static \fBGL2PSprimitive\fP* \fBgl2psCopyPrimitive\fP (\fBGL2PSprimitive\fP *p)\fC [static]\fP"
.PP
Definition at line 1069 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::boundary, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PS_ERROR, GL2PS_PIXMAP, GL2PS_SPECIAL, GL2PS_TEXT, gl2psCopyPixmap(), gl2psCopyText(), gl2psMalloc(), gl2psMsg(), GL2PSprimitive::image, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PSprimitive::pattern, GL2PSprimitive::text, GL2PSprimitive::type, GL2PSprimitive::verts, and GL2PSprimitive::width\&.
.PP
Referenced by gl2psPrintPDFPrimitive()\&.
.PP
.nf
{
  GL2PSprimitive *prim;

  if(!p){
    gl2psMsg(GL2PS_ERROR, 'Trying to copy an empty primitive');
    return NULL;
  }

  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
  
  prim->type = p->type;
  prim->numverts = p->numverts;
  prim->boundary = p->boundary;
  prim->offset = p->offset;
  prim->pattern = p->pattern;
  prim->factor = p->factor;
  prim->culled = p->culled;
  prim->width = p->width;
  prim->verts = (GL2PSvertex*)gl2psMalloc(p->numverts*sizeof(GL2PSvertex));
  memcpy(prim->verts, p->verts, p->numverts * sizeof(GL2PSvertex));

  switch(prim->type){
  case GL2PS_PIXMAP :
    prim->data\&.image = gl2psCopyPixmap(p->data\&.image);
    break;
  case GL2PS_TEXT :
  case GL2PS_SPECIAL :
    prim->data\&.text = gl2psCopyText(p->data\&.text);
    break;
  default:
    break;
  }

  return prim;
}
.fi
.SS "static \fBGL2PSstring\fP* \fBgl2psCopyText\fP (\fBGL2PSstring\fP *t)\fC [static]\fP"
.PP
Definition at line 941 of file gl2ps\&.c\&.
.PP
References GL2PSstring::alignment, GL2PSstring::angle, GL2PSstring::depthtest, GL2PSstring::fillcolor, GL2PSstring::fontname, GL2PSstring::fontsize, gl2psMalloc(), GL2PSstring::linecolor, GL2PSstring::linefactor, GL2PSstring::linepattern, GL2PSstring::linewidth, GL2PSstring::margin, GL2PSstring::offsetmargin, and GL2PSstring::str\&.
.PP
Referenced by gl2psCopyPrimitive()\&.
.PP
.nf
{
  GL2PSstring *text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
  text->str = (char*)gl2psMalloc((strlen(t->str)+1)*sizeof(char));
  strcpy(text->str, t->str); 
  text->fontname = (char*)gl2psMalloc((strlen(t->fontname)+1)*sizeof(char));
  strcpy(text->fontname, t->fontname);
  text->fontsize = t->fontsize;
  text->alignment = t->alignment;
  text->angle = t->angle;
  text->margin = t->margin;
  text->offsetmargin = t->offsetmargin;
  text->linewidth = t->linewidth;
    text->linecolor[0] = t->linecolor[0];
    text->linecolor[1] = t->linecolor[1];
    text->linecolor[2] = t->linecolor[2];
    text->linecolor[3] = t->linecolor[3];
  text->linepattern = t->linepattern;
  text->linefactor = t->linefactor;
    text->fillcolor[0] = t->fillcolor[0];
    text->fillcolor[1] = t->fillcolor[1];
    text->fillcolor[2] = t->fillcolor[2];
    text->fillcolor[3] = t->fillcolor[3];
  text->depthtest = t->depthtest;
  
  return text;
}
.fi
.SS "static void \fBgl2psCreateSplitPrimitive\fP (\fBGL2PSprimitive\fP *parent, \fBGL2PSplane\fPplane, \fBGL2PSprimitive\fP *child, GLshortnumverts, GLshort *index0, GLshort *index1)\fC [static]\fP"
.PP
Definition at line 1251 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::boundary, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PS_IMAGEMAP, GL2PS_LINE, GL2PS_NO_TYPE, GL2PS_POINT, GL2PS_QUADRANGLE, GL2PS_TRIANGLE, GL2PS_WARNING, gl2psCutEdge(), gl2psMalloc(), gl2psMsg(), i, GL2PSprimitive::image, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PSprimitive::pattern, GL2PSprimitive::type, GL2PSprimitive::verts, and GL2PSprimitive::width\&.
.PP
Referenced by gl2psSplitPrimitive()\&.
.PP
.nf
{
  GLshort i;

  if(parent->type == GL2PS_IMAGEMAP){
    child->type = GL2PS_IMAGEMAP;
    child->data\&.image = parent->data\&.image;
  }
  else{
    if(numverts > 4){
      gl2psMsg(GL2PS_WARNING, '%d vertices in polygon', numverts);
      numverts = 4;
    }
    switch(numverts){
    case 1 : child->type = GL2PS_POINT; break; 
    case 2 : child->type = GL2PS_LINE; break; 
    case 3 : child->type = GL2PS_TRIANGLE; break; 
    case 4 : child->type = GL2PS_QUADRANGLE; break;    
    default: child->type = GL2PS_NO_TYPE; break;
    }
  }

  child->boundary = 0; /* FIXME: not done! */
  child->culled = parent->culled;
  child->offset = parent->offset;
  child->pattern = parent->pattern;
  child->factor = parent->factor;
  child->width = parent->width;
  child->numverts = numverts;
  child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));

  for(i = 0; i < numverts; i++){
    if(index1[i] < 0){
      child->verts[i] = parent->verts[index0[i]];
    }
    else{
      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]], 
                   plane, &child->verts[i]);
    }
  }
}
.fi
.SS "static \fBGL2PSprimitive\fP* \fBgl2psCreateSplitPrimitive2D\fP (\fBGL2PSprimitive\fP *parent, GLshortnumverts, \fBGL2PSvertex\fP *vertx)\fC [static]\fP"
.PP
Definition at line 1924 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::boundary, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PS_IMAGEMAP, GL2PS_LINE, GL2PS_NO_TYPE, GL2PS_POINT, GL2PS_QUADRANGLE, GL2PS_TRIANGLE, gl2psMalloc(), i, GL2PSprimitive::image, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PSprimitive::pattern, GL2PSprimitive::type, GL2PSprimitive::verts, and GL2PSprimitive::width\&.
.PP
Referenced by gl2psSplitPrimitive2D()\&.
.PP
.nf
{
  GLint i;
  GL2PSprimitive *child = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));

  if(parent->type == GL2PS_IMAGEMAP){
    child->type = GL2PS_IMAGEMAP;
    child->data\&.image = parent->data\&.image;
  }
  else {
    switch(numverts){
    case 1 : child->type = GL2PS_POINT; break;
    case 2 : child->type = GL2PS_LINE; break;
    case 3 : child->type = GL2PS_TRIANGLE; break;
    case 4 : child->type = GL2PS_QUADRANGLE; break;
    default: child->type = GL2PS_NO_TYPE; break; /* FIXME */
    }
  }
  child->boundary = 0; /* FIXME: not done! */
  child->culled = parent->culled;
  child->offset = parent->offset;
  child->pattern = parent->pattern;
  child->factor = parent->factor;
  child->width = parent->width;
  child->numverts = numverts;
  child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
  for(i = 0; i < numverts; i++){
    child->verts[i] = vertx[i];
  }
  return child;
}
.fi
.SS "static void \fBgl2psCutEdge\fP (\fBGL2PSvertex\fP *a, \fBGL2PSvertex\fP *b, \fBGL2PSplane\fPplane, \fBGL2PSvertex\fP *c)\fC [static]\fP"
.PP
Definition at line 1229 of file gl2ps\&.c\&.
.PP
References gl2psComparePointPlane(), gl2psPsca(), GL2PSvertex::rgba, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psCreateSplitPrimitive(), and gl2psSplitPrimitive2D()\&.
.PP
.nf
{
  GL2PSxyz v;
  GLfloat sect;

  v[0] = b->xyz[0] - a->xyz[0];
  v[1] = b->xyz[1] - a->xyz[1];
  v[2] = b->xyz[2] - a->xyz[2];

  sect = - gl2psComparePointPlane(a->xyz, plane) / gl2psPsca(plane, v);

  c->xyz[0] = a->xyz[0] + v[0] * sect;
  c->xyz[1] = a->xyz[1] + v[1] * sect;
  c->xyz[2] = a->xyz[2] + v[2] * sect;
  
  c->rgba[0] = (1 - sect) * a->rgba[0] + sect * b->rgba[0];
  c->rgba[1] = (1 - sect) * a->rgba[1] + sect * b->rgba[1];
  c->rgba[2] = (1 - sect) * a->rgba[2] + sect * b->rgba[2];
  c->rgba[3] = (1 - sect) * a->rgba[3] + sect * b->rgba[3];
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psDisable\fP (GLintmode)"
.PP
Definition at line 6041 of file gl2ps\&.c\&.
.PP
References GL2PS_BLEND, GL2PS_END_BLEND_TOKEN, GL2PS_END_BOUNDARY_TOKEN, GL2PS_END_OFFSET_TOKEN, GL2PS_END_STIPPLE_TOKEN, GL2PS_LINE_STIPPLE, GL2PS_POLYGON_BOUNDARY, GL2PS_POLYGON_OFFSET_FILL, GL2PS_SUCCESS, GL2PS_UNINITIALIZED, GL2PS_WARNING, and gl2psMsg()\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psDisable()\&.
.PP
.nf
{
  if(!gl2ps) return GL2PS_UNINITIALIZED;

  switch(mode){
  case GL2PS_POLYGON_OFFSET_FILL :
    glPassThrough(GL2PS_END_OFFSET_TOKEN);
    break;
  case GL2PS_POLYGON_BOUNDARY :
    glPassThrough(GL2PS_END_BOUNDARY_TOKEN);
    break;
  case GL2PS_LINE_STIPPLE :
    glPassThrough(GL2PS_END_STIPPLE_TOKEN);
    break;
  case GL2PS_BLEND :
    glPassThrough(GL2PS_END_BLEND_TOKEN);
    break;
  default :
    gl2psMsg(GL2PS_WARNING, 'Unknown mode in gl2psDisable: %d', mode);
    return GL2PS_WARNING;
  }

  return GL2PS_SUCCESS;
}
.fi
.SS "static void \fBgl2psDivideQuad\fP (\fBGL2PSprimitive\fP *quad, \fBGL2PSprimitive\fP **t1, \fBGL2PSprimitive\fP **t2)\fC [static]\fP"
.PP
Definition at line 1405 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::boundary, GL2PSprimitive::culled, GL2PSprimitive::factor, GL2PS_TRIANGLE, gl2psMalloc(), GL2PSprimitive::offset, GL2PSprimitive::pattern, GL2PSprimitive::verts, and GL2PSprimitive::width\&.
.PP
Referenced by gl2psAddPrimitiveInList()\&.
.PP
.nf
{
  *t1 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
  *t2 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
  (*t1)->type = (*t2)->type = GL2PS_TRIANGLE;
  (*t1)->numverts = (*t2)->numverts = 3;
  (*t1)->culled = (*t2)->culled = quad->culled;
  (*t1)->offset = (*t2)->offset = quad->offset;
  (*t1)->pattern = (*t2)->pattern = quad->pattern;
  (*t1)->factor = (*t2)->factor = quad->factor;
  (*t1)->width = (*t2)->width = quad->width;
  (*t1)->verts = (GL2PSvertex*)gl2psMalloc(3 * sizeof(GL2PSvertex));
  (*t2)->verts = (GL2PSvertex*)gl2psMalloc(3 * sizeof(GL2PSvertex));
  (*t1)->verts[0] = quad->verts[0];
  (*t1)->verts[1] = quad->verts[1];
  (*t1)->verts[2] = quad->verts[2];
  (*t1)->boundary = ((quad->boundary & 1) ? 1 : 0) | ((quad->boundary & 2) ? 2 : 0);
  (*t2)->verts[0] = quad->verts[0];
  (*t2)->verts[1] = quad->verts[2];
  (*t2)->verts[2] = quad->verts[3];
  (*t2)->boundary = ((quad->boundary & 4) ? 2 : 0) | ((quad->boundary & 4) ? 2 : 0);
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psDrawImageMap\fP (GLsizeiwidth, GLsizeiheight, const GLfloatposition[3], const unsigned char *imagemap)"
.PP
Definition at line 5983 of file gl2ps\&.c\&.
.PP
References GL2PS_ERROR, GL2PS_IMAGEMAP_TOKEN, GL2PS_SUCCESS, GL2PS_UNINITIALIZED, and i\&.
.PP
.nf
                                                                   {
  int size, i;
  int sizeoffloat = sizeof(GLfloat);
  
  if(!gl2ps || !imagemap) return GL2PS_UNINITIALIZED;

  if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
  
  size = height + height * ((width-1)/8);
  glPassThrough(GL2PS_IMAGEMAP_TOKEN);
  glBegin(GL_POINTS);
  glVertex3f(position[0], position[1],position[2]);
  glEnd();
  glPassThrough((GLfloat)width);
  glPassThrough((GLfloat)height);
  for(i = 0; i < size; i += sizeoffloat){
    float *value = (float*)imagemap;
    glPassThrough(*value);
    imagemap += sizeoffloat;
  }
  return GL2PS_SUCCESS;
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psDrawPixels\fP (GLsizeiwidth, GLsizeiheight, GLintxorig, GLintyorig, GLenumformat, GLenumtype, const void *pixels)"
.PP
Definition at line 5902 of file gl2ps\&.c\&.
.PP
References GL2PScontext::auxprimitives, GL2PScontext::blending, GL2PSprimitive::boundary, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PSimage::format, GL2PS_DRAW_PIXELS_TOKEN, GL2PS_ERROR, GL2PS_NO_BLENDING, GL2PS_NO_PIXMAP, GL2PS_PIXMAP, GL2PS_SUCCESS, GL2PS_UNINITIALIZED, gl2psListAdd(), gl2psMalloc(), gl2psMsg(), GL2PSimage::height, i, GL2PSprimitive::image, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PScontext::options, GL2PSprimitive::pattern, GL2PSimage::pixels, GL2PSvertex::rgba, type, GL2PSimage::type, GL2PSprimitive::type, GL2PSprimitive::verts, width, GL2PSimage::width, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
.nf
{
  int size, i;
  GLfloat pos[4], *piv;
  GL2PSprimitive *prim;
  GLboolean valid;

  if(!gl2ps || !pixels) return GL2PS_UNINITIALIZED;

  if((width <= 0) || (height <= 0)) return GL2PS_ERROR;

  if(gl2ps->options & GL2PS_NO_PIXMAP) return GL2PS_SUCCESS;

  if((format != GL_RGB && format != GL_RGBA) || type != GL_FLOAT){
    gl2psMsg(GL2PS_ERROR, 'gl2psDrawPixels only implemented for '
             'GL_RGB/GL_RGBA, GL_FLOAT pixels');
    return GL2PS_ERROR;
  }

  glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
  if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */

  glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);

  prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
  prim->type = GL2PS_PIXMAP;
  prim->boundary = 0;
  prim->numverts = 1;
  prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
  prim->verts[0]\&.xyz[0] = pos[0] + xorig;
  prim->verts[0]\&.xyz[1] = pos[1] + yorig;
  prim->verts[0]\&.xyz[2] = pos[2];
  prim->culled = 0;
  prim->offset = 0;
  prim->pattern = 0;
  prim->factor = 0;
  prim->width = 1;
  glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0]\&.rgba);
  prim->data\&.image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
  prim->data\&.image->width = width;
  prim->data\&.image->height = height;
  prim->data\&.image->format = format;
  prim->data\&.image->type = type;

  switch(format){
  case GL_RGBA:
    if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
      /* special case: blending turned off */
      prim->data\&.image->format = GL_RGB;
      size = height * width * 3;
      prim->data\&.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
      piv = (GLfloat*)pixels;
      for(i = 0; i < size; ++i, ++piv){
        prim->data\&.image->pixels[i] = *piv;
        if(!((i+1)%3))
          ++piv;
      }   
    }
    else{
      size = height * width * 4;
      prim->data\&.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
      memcpy(prim->data\&.image->pixels, pixels, size * sizeof(GLfloat));
    }
    break;
  case GL_RGB:
  default:
    size = height * width * 3;
    prim->data\&.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
    memcpy(prim->data\&.image->pixels, pixels, size * sizeof(GLfloat));
    break;
  }

  gl2psListAdd(gl2ps->auxprimitives, &prim);
  glPassThrough(GL2PS_DRAW_PIXELS_TOKEN);

  return GL2PS_SUCCESS;
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psEnable\fP (GLintmode)"
.PP
Definition at line 6008 of file gl2ps\&.c\&.
.PP
References GL2PS_BEGIN_BLEND_TOKEN, GL2PS_BEGIN_BOUNDARY_TOKEN, GL2PS_BEGIN_OFFSET_TOKEN, GL2PS_BEGIN_STIPPLE_TOKEN, GL2PS_BLEND, GL2PS_LINE_STIPPLE, GL2PS_POLYGON_BOUNDARY, GL2PS_POLYGON_OFFSET_FILL, GL2PS_SUCCESS, GL2PS_UNINITIALIZED, GL2PS_WARNING, gl2psMsg(), GL2PScontext::offset, and tmp\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psEnable()\&.
.PP
.nf
{
  GLint tmp;

  if(!gl2ps) return GL2PS_UNINITIALIZED;

  switch(mode){
  case GL2PS_POLYGON_OFFSET_FILL :
    glPassThrough(GL2PS_BEGIN_OFFSET_TOKEN);
    glGetFloatv(GL_POLYGON_OFFSET_FACTOR, &gl2ps->offset[0]);
    glGetFloatv(GL_POLYGON_OFFSET_UNITS, &gl2ps->offset[1]);
    break;
  case GL2PS_POLYGON_BOUNDARY :
    glPassThrough(GL2PS_BEGIN_BOUNDARY_TOKEN);
    break;
  case GL2PS_LINE_STIPPLE :
    glPassThrough(GL2PS_BEGIN_STIPPLE_TOKEN);
    glGetIntegerv(GL_LINE_STIPPLE_PATTERN, &tmp);
    glPassThrough((GLfloat)tmp);
    glGetIntegerv(GL_LINE_STIPPLE_REPEAT, &tmp);
    glPassThrough((GLfloat)tmp);
    break;
  case GL2PS_BLEND :
    glPassThrough(GL2PS_BEGIN_BLEND_TOKEN);
    break;
  default :
    gl2psMsg(GL2PS_WARNING, 'Unknown mode in gl2psEnable: %d', mode);
    return GL2PS_WARNING;
  }

  return GL2PS_SUCCESS;
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psEndPage\fP (void)"
.PP
Definition at line 5831 of file gl2ps\&.c\&.
.PP
References GL2PScontext::auxprimitives, GL2PScontext::colormap, GL2PScontext::feedback, GL2PScontext::filename, GL2PScontext::format, GL2PS_OVERFLOW, GL2PS_UNINITIALIZED, gl2psFree(), gl2psFreeImagemap(), gl2psListDelete(), gl2psPrintPrimitives(), GL2PScontext::imagemap_head, GL2PScontext::primitives, GL2PSbackend::printFooter, GL2PScontext::producer, GL2PScontext::stream, and GL2PScontext::title\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psEndPage()\&.
.PP
.nf
{
  GLint res;

  if(!gl2ps) return GL2PS_UNINITIALIZED;

  res = gl2psPrintPrimitives();

  if(res != GL2PS_OVERFLOW)
    (gl2psbackends[gl2ps->format]->printFooter)();
  
  fflush(gl2ps->stream);

  gl2psListDelete(gl2ps->primitives);
  gl2psListDelete(gl2ps->auxprimitives);
  gl2psFreeImagemap(gl2ps->imagemap_head);
  gl2psFree(gl2ps->colormap);
  gl2psFree(gl2ps->title);
  gl2psFree(gl2ps->producer);
  gl2psFree(gl2ps->filename);
  gl2psFree(gl2ps->feedback);
  gl2psFree(gl2ps);
  gl2ps = NULL;

  return res;
}
.fi
.SS "static void \fBgl2psEndPostScriptLine\fP (void)\fC [static]\fP"
.PP
Definition at line 2993 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), i, GL2PScontext::lastvertex, GL2PSvertex::rgba, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPostScriptFinalPrimitive(), and gl2psPrintPostScriptPrimitive()\&.
.PP
.nf
{
  int i;
  if(gl2ps->lastvertex\&.rgba[0] >= 0\&.){
    gl2psPrintf('%g %g LE\n', gl2ps->lastvertex\&.xyz[0], gl2ps->lastvertex\&.xyz[1]);
    for(i = 0; i < 3; i++)
      gl2ps->lastvertex\&.xyz[i] = -1\&.;
    for(i = 0; i < 4; i++)
      gl2ps->lastvertex\&.rgba[i] = -1\&.;
  }
}
.fi
.SS "static void \fBgl2psEndSVGLine\fP (void)\fC [static]\fP"
.PP
Definition at line 5110 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), i, GL2PScontext::lastvertex, GL2PSvertex::rgba, GL2PScontext::viewport, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintSVGFinalPrimitive(), and gl2psPrintSVGPrimitive()\&.
.PP
.nf
{
  int i;
  if(gl2ps->lastvertex\&.rgba[0] >= 0\&.){
    gl2psPrintf('%g,%g\'/>\n', gl2ps->lastvertex\&.xyz[0], 
                gl2ps->viewport[3] - gl2ps->lastvertex\&.xyz[1]);
    for(i = 0; i < 3; i++)
      gl2ps->lastvertex\&.xyz[i] = -1\&.;
    for(i = 0; i < 4; i++)
      gl2ps->lastvertex\&.rgba[i] = -1\&.;
  }
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psEndViewport\fP (void)"
.PP
Definition at line 5867 of file gl2ps\&.c\&.
.PP
References GL2PSbackend::endViewport, GL2PScontext::format, GL2PS_UNINITIALIZED, and GL2PScontext::lastlinewidth\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psEndViewport()\&.
.PP
.nf
{
  GLint res;

  if(!gl2ps) return GL2PS_UNINITIALIZED;

  res = (gl2psbackends[gl2ps->format]->endViewport)();

  /* reset last used line width */
  gl2ps->lastlinewidth = -1\&.0F;

  return res;
}
.fi
.SS "static void \fBgl2psFillTriangleFromPrimitive\fP (\fBGL2PStriangle\fP *t, \fBGL2PSprimitive\fP *p, GLbooleanassignprops)\fC [static]\fP"
.PP
Definition at line 1048 of file gl2ps\&.c\&.
.PP
References gl2psAssignTriangleProperties(), GL2PStriangle::vertex, and GL2PSprimitive::verts\&.
.PP
Referenced by gl2psPDFgroupListInit(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), and gl2psSortOutTrianglePDFgroup()\&.
.PP
.nf
{
  t->vertex[0] = p->verts[0];
  t->vertex[1] = p->verts[1];
  t->vertex[2] = p->verts[2];
  if(GL_TRUE == assignprops)
    gl2psAssignTriangleProperties(t);
}
.fi
.SS "static GLint \fBgl2psFindRoot\fP (\fBGL2PSlist\fP *primitives, \fBGL2PSprimitive\fP **root)\fC [static]\fP"
.PP
Definition at line 1469 of file gl2ps\&.c\&.
.PP
References GL2PS_BEST_ROOT, GL2PS_ERROR, gl2psGetPlane(), gl2psListNbr(), gl2psListPointer(), gl2psMsg(), gl2psTestSplitPrimitive(), i, GL2PScontext::maxbestroot, and GL2PScontext::options\&.
.PP
Referenced by gl2psBuildBspTree()\&.
.PP
.nf
{
  GLint i, j, count, best = 1000000, index = 0;
  GL2PSprimitive *prim1, *prim2;
  GL2PSplane plane;
  GLint maxp;

  if(!gl2psListNbr(primitives)){
    gl2psMsg(GL2PS_ERROR, 'Cannot fint root in empty primitive list');
    return 0;
  }

  *root = *(GL2PSprimitive**)gl2psListPointer(primitives, 0);

  if(gl2ps->options & GL2PS_BEST_ROOT){
    maxp = gl2psListNbr(primitives);
    if(maxp > gl2ps->maxbestroot){
      maxp = gl2ps->maxbestroot;
    }
    for(i = 0; i < maxp; i++){
      prim1 = *(GL2PSprimitive**)gl2psListPointer(primitives, i);
      gl2psGetPlane(prim1, plane);
      count = 0;
      for(j = 0; j < gl2psListNbr(primitives); j++){
        if(j != i){
          prim2 = *(GL2PSprimitive**)gl2psListPointer(primitives, j);
          count += gl2psTestSplitPrimitive(prim2, plane); 
        }
        if(count > best) break;
      }
      if(count < best){
        best = count;
        index = i;
        *root = prim1;
        if(!count) return index;
      }
    }
    /* if(index) gl2psMsg(GL2PS_INFO, 'GL2PS_BEST_ROOT was worth it: %d', index); */
    return index;
  }
  else{
    return 0;
  }
}
.fi
.SS "static void \fBgl2psFree\fP (void *ptr)\fC [static]\fP"
.PP
Definition at line 347 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddInBspImageTree(), gl2psAddPlanesInBspTreeImage(), gl2psBeginPage(), gl2psEndPage(), gl2psFreeBspImageTree(), gl2psFreeBspTree(), gl2psFreeImagemap(), gl2psFreePixmap(), gl2psFreePrimitive(), gl2psFreeText(), gl2psListDelete(), gl2psPDFgroupListWriteObjects(), gl2psPrintGzipFooter(), gl2psPrintPDFFooter(), and gl2psSplitPrimitive2D()\&.
.PP
.nf
{
  if(!ptr) return;
  free(ptr);
}
.fi
.SS "static void \fBgl2psFreeBspImageTree\fP (\fBGL2PSbsptree2d\fP **tree)\fC [static]\fP"
.PP
Definition at line 1789 of file gl2ps\&.c\&.
.PP
References gl2psFree()\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  if(*tree){
    if((*tree)->back)  gl2psFreeBspImageTree(&(*tree)->back);
    if((*tree)->front) gl2psFreeBspImageTree(&(*tree)->front);
    gl2psFree(*tree);
    *tree = NULL;
  }
}
.fi
.SS "static void \fBgl2psFreeBspTree\fP (\fBGL2PSbsptree\fP **tree)\fC [static]\fP"
.PP
Definition at line 1556 of file gl2ps\&.c\&.
.PP
References gl2psFree(), gl2psFreePrimitive(), gl2psListAction(), and gl2psListDelete()\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  if(*tree){
    if((*tree)->back) gl2psFreeBspTree(&(*tree)->back);
    if((*tree)->primitives){
      gl2psListAction((*tree)->primitives, gl2psFreePrimitive);
      gl2psListDelete((*tree)->primitives);
    }
    if((*tree)->front) gl2psFreeBspTree(&(*tree)->front);
    gl2psFree(*tree);
    *tree = NULL;
  }
}
.fi
.SS "static void \fBgl2psFreeImagemap\fP (\fBGL2PSimagemap\fP *list)\fC [static]\fP"
.PP
Definition at line 1514 of file gl2ps\&.c\&.
.PP
References gl2psFree(), _GL2PSimagemap::image, _GL2PSimagemap::next, and GL2PSimage::pixels\&.
.PP
Referenced by gl2psEndPage()\&.
.PP
.nf
                                                  {
  GL2PSimagemap *next;
  while(list != NULL){
    next = list->next;
    gl2psFree(list->image->pixels);
    gl2psFree(list->image);
    gl2psFree(list);
    list = next;
  }
}
.fi
.SS "static void \fBgl2psFreePixmap\fP (\fBGL2PSimage\fP *im)\fC [static]\fP"
.PP
Definition at line 796 of file gl2ps\&.c\&.
.PP
References gl2psFree(), and GL2PSimage::pixels\&.
.PP
Referenced by gl2psFreePrimitive()\&.
.PP
.nf
{
  if(!im)
    return;
  gl2psFree(im->pixels);
  gl2psFree(im);
}
.fi
.SS "static void \fBgl2psFreePrimitive\fP (void *data)\fC [static]\fP"
.PP
Definition at line 1525 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::data, GL2PS_PIXMAP, GL2PS_SPECIAL, GL2PS_TEXT, gl2psFree(), gl2psFreePixmap(), gl2psFreeText(), GL2PSprimitive::image, GL2PSprimitive::text, GL2PSprimitive::type, and GL2PSprimitive::verts\&.
.PP
Referenced by gl2psAddPrimitiveInList(), gl2psBuildBspTree(), gl2psFreeBspTree(), and gl2psPrintPrimitives()\&.
.PP
.nf
{
  GL2PSprimitive *q;
  
  q = *(GL2PSprimitive**)data;
  gl2psFree(q->verts);
  if(q->type == GL2PS_TEXT || q->type == GL2PS_SPECIAL){
    gl2psFreeText(q->data\&.text);
  }
  else if(q->type == GL2PS_PIXMAP){
    gl2psFreePixmap(q->data\&.image);
  }
  gl2psFree(q);
}
.fi
.SS "static void \fBgl2psFreeText\fP (\fBGL2PSstring\fP *text)\fC [static]\fP"
.PP
Definition at line 969 of file gl2ps\&.c\&.
.PP
References GL2PSstring::fontname, gl2psFree(), and GL2PSstring::str\&.
.PP
Referenced by gl2psFreePrimitive()\&.
.PP
.nf
{
  if(!text)
    return;
  gl2psFree(text->str);
  gl2psFree(text->fontname);
  gl2psFree(text);
}
.fi
.SS "\fBGL2PSDLL_API\fP const char* \fBgl2psGetFileExtension\fP (GLintformat)"
.PP
Definition at line 6110 of file gl2ps\&.c\&.
.PP
References GL2PSbackend::file_extension\&.
.PP
.nf
{
  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends)/sizeof(gl2psbackends[0])))
    return gl2psbackends[format]->file_extension;
  else
    return 'Unknown format';
}
.fi
.SS "\fBGL2PSDLL_API\fP const char* \fBgl2psGetFormatDescription\fP (GLintformat)"
.PP
Definition at line 6118 of file gl2ps\&.c\&.
.PP
References GL2PSbackend::description\&.
.PP
.nf
{
  if(format >= 0 && format < (GLint)(sizeof(gl2psbackends)/sizeof(gl2psbackends[0])))
    return gl2psbackends[format]->description;
  else
    return 'Unknown format';
}
.fi
.SS "static GLshort \fBgl2psGetIndex\fP (GLshorti, GLshortnum)\fC [static]\fP"
.PP
Definition at line 1309 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddBoundaryInList(), gl2psSplitPrimitive(), and gl2psTestSplitPrimitive()\&.
.PP
.nf
{
  return (i < num - 1) ? i + 1 : 0;
}
.fi
.SS "static void \fBgl2psGetNormal\fP (GLfloat *a, GLfloat *b, GLfloat *c)\fC [static]\fP"
.PP
Definition at line 1146 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO, gl2psNorm(), and gl2psPvec()\&.
.PP
Referenced by gl2psGetPlane()\&.
.PP
.nf
{
  GLfloat norm;

  gl2psPvec(a, b, c);
  if(!GL2PS_ZERO(norm = gl2psNorm(c))){
    c[0] = c[0] / norm;
    c[1] = c[1] / norm;
    c[2] = c[2] / norm;
  }
  else{
    /* The plane is still wrong despite our tests in gl2psGetPlane\&.
       Let's return a dummy value for now (this is a hack: we should
       do more intelligent tests in GetPlane) */
    c[0] = c[1] = 0\&.0F;
    c[2] = 1\&.0F;
  }
}
.fi
.SS "static void \fBgl2psGetPlane\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fPplane)\fC [static]\fP"
.PP
Definition at line 1165 of file gl2ps\&.c\&.
.PP
References GL2PS_ERROR, GL2PS_IMAGEMAP, GL2PS_LINE, GL2PS_PIXMAP, GL2PS_POINT, GL2PS_QUADRANGLE, GL2PS_SPECIAL, GL2PS_TEXT, GL2PS_TRIANGLE, GL2PS_ZERO, gl2psGetNormal(), gl2psMsg(), GL2PSprimitive::type, GL2PSprimitive::verts, w, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psBuildBspTree(), and gl2psFindRoot()\&.
.PP
.nf
{
  GL2PSxyz v = {0\&.0F, 0\&.0F, 0\&.0F}, w = {0\&.0F, 0\&.0F, 0\&.0F};

  switch(prim->type){
  case GL2PS_TRIANGLE :
  case GL2PS_QUADRANGLE :
    v[0] = prim->verts[1]\&.xyz[0] - prim->verts[0]\&.xyz[0]; 
    v[1] = prim->verts[1]\&.xyz[1] - prim->verts[0]\&.xyz[1]; 
    v[2] = prim->verts[1]\&.xyz[2] - prim->verts[0]\&.xyz[2]; 
    w[0] = prim->verts[2]\&.xyz[0] - prim->verts[0]\&.xyz[0]; 
    w[1] = prim->verts[2]\&.xyz[1] - prim->verts[0]\&.xyz[1]; 
    w[2] = prim->verts[2]\&.xyz[2] - prim->verts[0]\&.xyz[2]; 
    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) || 
       (GL2PS_ZERO(w[0]) && GL2PS_ZERO(w[1]) && GL2PS_ZERO(w[2]))){
      plane[0] = plane[1] = 0\&.0F;
      plane[2] = 1\&.0F;
      plane[3] = -prim->verts[0]\&.xyz[2];
    }
    else{
      gl2psGetNormal(v, w, plane);
      plane[3] = 
        - plane[0] * prim->verts[0]\&.xyz[0] 
        - plane[1] * prim->verts[0]\&.xyz[1] 
        - plane[2] * prim->verts[0]\&.xyz[2];
    }
    break;
  case GL2PS_LINE :
    v[0] = prim->verts[1]\&.xyz[0] - prim->verts[0]\&.xyz[0]; 
    v[1] = prim->verts[1]\&.xyz[1] - prim->verts[0]\&.xyz[1]; 
    v[2] = prim->verts[1]\&.xyz[2] - prim->verts[0]\&.xyz[2]; 
    if(GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])){
      plane[0] = plane[1] = 0\&.0F;
      plane[2] = 1\&.0F;
      plane[3] = -prim->verts[0]\&.xyz[2];
    }
    else{
      if(GL2PS_ZERO(v[0]))      w[0] = 1\&.0F;
      else if(GL2PS_ZERO(v[1])) w[1] = 1\&.0F;
      else                      w[2] = 1\&.0F;
      gl2psGetNormal(v, w, plane);
      plane[3] = 
        - plane[0] * prim->verts[0]\&.xyz[0] 
        - plane[1] * prim->verts[0]\&.xyz[1] 
        - plane[2] * prim->verts[0]\&.xyz[2];
    }
    break;
  case GL2PS_POINT :
  case GL2PS_PIXMAP :
  case GL2PS_TEXT :
  case GL2PS_SPECIAL :
  case GL2PS_IMAGEMAP:
    plane[0] = plane[1] = 0\&.0F;
    plane[2] = 1\&.0F;
    plane[3] = -prim->verts[0]\&.xyz[2];
    break;
  default :
    gl2psMsg(GL2PS_ERROR, 'Unknown primitive type in BSP tree');
    plane[0] = plane[1] = plane[3] = 0\&.0F;
    plane[2] = 1\&.0F;
    break;
  }
}
.fi
.SS "static GLint \fBgl2psGetPlaneFromPoints\fP (\fBGL2PSxyz\fPa, \fBGL2PSxyz\fPb, \fBGL2PSplane\fPplane)\fC [static]\fP"
.PP
Definition at line 1767 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO, and n\&.
.PP
Referenced by gl2psAddPlanesInBspTreeImage()\&.
.PP
.nf
{
  GLfloat n; 

  plane[0] = b[1] - a[1];
  plane[1] = a[0] - b[0];
  n = (GLfloat)sqrt(plane[0]*plane[0] + plane[1]*plane[1]);
  plane[2] = 0\&.0F;
  if(!GL2PS_ZERO(n)){
    plane[0] /= n;
    plane[1] /= n;
    plane[3] = -plane[0]*a[0]-plane[1]*a[1]; 
    return 1;
  }
  else{
    plane[0] = -1\&.0F;
    plane[1] = 0\&.0F;
    plane[3] = a[0];
    return 0;
  }
}
.fi
.SS "static GLfloat \fBgl2psGetRGB\fP (\fBGL2PSimage\fP *im, GLuintx, GLuinty, GLfloat *red, GLfloat *green, GLfloat *blue)\fC [static]\fP"
.PP
Definition at line 742 of file gl2ps\&.c\&.
.PP
References GL2PSimage::format, GL2PSimage::height, GL2PSimage::pixels, width, GL2PSimage::width, and y\&.
.PP
Referenced by gl2psPrintPDFPixmapStreamData(), and gl2psPrintPostScriptPixmap()\&.
.PP
.nf
{
  
  GLsizei width = im->width;
  GLsizei height = im->height;
  GLfloat *pixels = im->pixels;
  GLfloat *pimag;

  /* OpenGL image is from down to up, PS image is up to down */  
  switch(im->format){
  case GL_RGBA:
    pimag = pixels + 4 * (width * (height - 1 - y) + x);
    break;
  case GL_RGB:
  default:
    pimag = pixels + 3 * (width * (height - 1 - y) + x);
    break;
  }
  *red = *pimag; pimag++;
  *green = *pimag; pimag++;
  *blue = *pimag; pimag++;

  return (im->format == GL_RGBA) ? *pimag : 1\&.0F;
}
.fi
.SS "static GLint \fBgl2psGetVertex\fP (\fBGL2PSvertex\fP *v, GLfloat *p)\fC [static]\fP"
.PP
Definition at line 2231 of file gl2ps\&.c\&.
.PP
References GL2PScontext::colormap, GL2PScontext::colormode, GL2PScontext::colorsize, i, GL2PSvertex::rgba, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psParseFeedbackBuffer()\&.
.PP
.nf
{
  GLint i;

  v->xyz[0] = p[0];
  v->xyz[1] = p[1];
  v->xyz[2] = p[2];

  if(gl2ps->colormode == GL_COLOR_INDEX && gl2ps->colorsize > 0){
    i = (GLint)(p[3] + 0\&.5);
    v->rgba[0] = gl2ps->colormap[i][0];
    v->rgba[1] = gl2ps->colormap[i][1];
    v->rgba[2] = gl2ps->colormap[i][2];
    v->rgba[3] = gl2ps->colormap[i][3];
    return 4;
  }
  else{
    v->rgba[0] = p[3];
    v->rgba[1] = p[4];
    v->rgba[2] = p[5];
    v->rgba[3] = p[6];
    return 7;
  }
}
.fi
.SS "static GLboolean \fBgl2psGreater\fP (GLfloatf1, GLfloatf2)\fC [static]\fP"
.PP
Definition at line 1570 of file gl2ps\&.c\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  if(f1 > f2) return GL_TRUE;
  else return GL_FALSE;
}
.fi
.SS "static void \fBgl2psInitTriangle\fP (\fBGL2PStriangle\fP *t)\fC [static]\fP"
.PP
Definition at line 1058 of file gl2ps\&.c\&.
.PP
References i, GL2PStriangle::prop, T_UNDEFINED, and GL2PStriangle::vertex\&.
.PP
Referenced by gl2psPDFgroupListInit()\&.
.PP
.nf
{
  int i;
  GL2PSvertex vertex = { {-1\&.0F, -1\&.0F, -1\&.0F}, {-1\&.0F, -1\&.0F, -1\&.0F, -1\&.0F} };
  for(i = 0; i < 3; i++)
    t->vertex[i] = vertex;
  t->prop = T_UNDEFINED;
}
.fi
.SS "static GLboolean \fBgl2psLess\fP (GLfloatf1, GLfloatf2)\fC [static]\fP"
.PP
Definition at line 1576 of file gl2ps\&.c\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  if(f1 < f2) return GL_TRUE;
  else return GL_FALSE;
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psLineWidth\fP (GLfloatvalue)"
.PP
Definition at line 6076 of file gl2ps\&.c\&.
.PP
References GL2PS_LINE_WIDTH_TOKEN, GL2PS_SUCCESS, and GL2PS_UNINITIALIZED\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psLineWidth()\&.
.PP
.nf
{
  if(!gl2ps) return GL2PS_UNINITIALIZED;

  glPassThrough(GL2PS_LINE_WIDTH_TOKEN);
  glPassThrough(value);

  return GL2PS_SUCCESS;
}
.fi
.SS "static void \fBgl2psListAction\fP (\fBGL2PSlist\fP *list, void(*)(void *data)action)\fC [static]\fP"
.PP
Definition at line 622 of file gl2ps\&.c\&.
.PP
References gl2psListNbr(), gl2psListPointer(), and i\&.
.PP
Referenced by gl2psFreeBspTree(), gl2psPrintPrimitives(), and gl2psTraverseBspTree()\&.
.PP
.nf
{
  GLint i;

  for(i = 0; i < gl2psListNbr(list); i++){
    (*action)(gl2psListPointer(list, i));
  }
}
.fi
.SS "static void \fBgl2psListActionInverse\fP (\fBGL2PSlist\fP *list, void(*)(void *data)action)\fC [static]\fP"
.PP
Definition at line 631 of file gl2ps\&.c\&.
.PP
References gl2psListNbr(), gl2psListPointer(), and i\&.
.PP
Referenced by gl2psPrintPrimitives(), and gl2psTraverseBspTree()\&.
.PP
.nf
{
  GLint i;

  for(i = gl2psListNbr(list); i > 0; i--){
    (*action)(gl2psListPointer(list, i-1));
  }
}
.fi
.SS "static void \fBgl2psListAdd\fP (\fBGL2PSlist\fP *list, void *data)\fC [static]\fP"
.PP
Definition at line 583 of file gl2ps\&.c\&.
.PP
References GL2PSlist::array, GL2PS_ERROR, gl2psListRealloc(), gl2psMsg(), GL2PSlist::n, and GL2PSlist::size\&.
.PP
Referenced by gl2psAddBoundaryInList(), gl2psAddPolyPrimitive(), gl2psAddPrimitiveInList(), gl2psAddText(), gl2psDrawPixels(), gl2psParseFeedbackBuffer(), gl2psPDFgroupListInit(), and gl2psPrintPDFPrimitive()\&.
.PP
.nf
{
  if(!list){
    gl2psMsg(GL2PS_ERROR, 'Cannot add into unallocated list');
    return;
  }
  list->n++;
  gl2psListRealloc(list, list->n);
  memcpy(&list->array[(list->n - 1) * list->size], data, list->size);
}
.fi
.SS "static \fBGL2PSlist\fP* \fBgl2psListCreate\fP (GLintn, GLintincr, GLintsize)\fC [static]\fP"
.PP
Definition at line 554 of file gl2ps\&.c\&.
.PP
References GL2PSlist::array, gl2psListRealloc(), gl2psMalloc(), GL2PSlist::incr, GL2PSlist::n, GL2PSlist::nmax, and GL2PSlist::size\&.
.PP
Referenced by gl2psBeginPage(), gl2psBuildBspTree(), gl2psPDFgroupListInit(), gl2psPrintPDFHeader(), gl2psPrintPrimitives(), and gl2psPrintSVGPixmap()\&.
.PP
.nf
{
  GL2PSlist *list;

  if(n < 0) n = 0;
  if(incr <= 0) incr = 1;
  list = (GL2PSlist*)gl2psMalloc(sizeof(GL2PSlist));
  list->nmax = 0;
  list->incr = incr;
  list->size = size;
  list->n = 0;
  list->array = NULL;
  gl2psListRealloc(list, n);
  return(list);
}
.fi
.SS "static void \fBgl2psListDelete\fP (\fBGL2PSlist\fP *list)\fC [static]\fP"
.PP
Definition at line 576 of file gl2ps\&.c\&.
.PP
References GL2PSlist::array, and gl2psFree()\&.
.PP
Referenced by gl2psBuildBspTree(), gl2psEndPage(), gl2psFreeBspTree(), gl2psPDFgroupListDelete(), gl2psPrintPDFFooter(), and gl2psPrintSVGPixmap()\&.
.PP
.nf
{
  if(!list) return;  
  gl2psFree(list->array);
  gl2psFree(list);
}
.fi
.SS "static int \fBgl2psListNbr\fP (\fBGL2PSlist\fP *list)\fC [static]\fP"
.PP
Definition at line 594 of file gl2ps\&.c\&.
.PP
References GL2PSlist::n\&.
.PP
Referenced by gl2psBuildBspTree(), gl2psBuildPolygonBoundary(), gl2psFindRoot(), gl2psListAction(), gl2psListActionInverse(), gl2psParseFeedbackBuffer(), gl2psPDFgroupListDelete(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteFontResources(), gl2psPDFgroupListWriteGStateResources(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPDFgroupListWriteShaderResources(), gl2psPDFgroupListWriteXObjectResources(), gl2psPrintPrimitives(), gl2psPrintSVGPixmap(), gl2psRescaleAndOffset(), and gl2psSortOutTrianglePDFgroup()\&.
.PP
.nf
{
  if(!list)
    return 0;
  return(list->n);
}
.fi
.SS "static void* \fBgl2psListPointer\fP (\fBGL2PSlist\fP *list, GLintindex)\fC [static]\fP"
.PP
Definition at line 601 of file gl2ps\&.c\&.
.PP
References GL2PSlist::array, GL2PS_ERROR, gl2psMsg(), GL2PSlist::n, and GL2PSlist::size\&.
.PP
Referenced by gl2psBuildBspTree(), gl2psBuildPolygonBoundary(), gl2psFindRoot(), gl2psListAction(), gl2psListActionInverse(), gl2psParseFeedbackBuffer(), gl2psPDFgroupListDelete(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteFontResources(), gl2psPDFgroupListWriteGStateResources(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPDFgroupListWriteShaderResources(), gl2psPDFgroupListWriteXObjectResources(), gl2psRescaleAndOffset(), and gl2psSortOutTrianglePDFgroup()\&.
.PP
.nf
{
  if(!list){
    gl2psMsg(GL2PS_ERROR, 'Cannot point into unallocated list');
    return NULL;
  }
  if((index < 0) || (index >= list->n)){
    gl2psMsg(GL2PS_ERROR, 'Wrong list index in gl2psListPointer');
    return NULL;
  }
  return(&list->array[index * list->size]);
}
.fi
.SS "static void \fBgl2psListRealloc\fP (\fBGL2PSlist\fP *list, GLintn)\fC [static]\fP"
.PP
Definition at line 534 of file gl2ps\&.c\&.
.PP
References GL2PSlist::array, GL2PS_ERROR, gl2psMalloc(), gl2psMsg(), gl2psRealloc(), GL2PSlist::incr, n, GL2PSlist::nmax, and GL2PSlist::size\&.
.PP
Referenced by gl2psListAdd(), and gl2psListCreate()\&.
.PP
.nf
{
  if(!list){
    gl2psMsg(GL2PS_ERROR, 'Cannot reallocate NULL list');
    return;
  }
  if(n <= 0) return;
  if(!list->array){
    list->nmax = n;
    list->array = (char*)gl2psMalloc(list->nmax * list->size);
  }
  else{
    if(n > list->nmax){
      list->nmax = ((n - 1) / list->incr + 1) * list->incr;
      list->array = (char*)gl2psRealloc(list->array,
                                        list->nmax * list->size);
    }
  }
}
.fi
.SS "static void \fBgl2psListReset\fP (\fBGL2PSlist\fP *list)\fC [static]\fP"
.PP
Definition at line 570 of file gl2ps\&.c\&.
.PP
References GL2PSlist::n\&.
.PP
Referenced by gl2psParseFeedbackBuffer(), and gl2psPrintPrimitives()\&.
.PP
.nf
{
  if(!list) return;
  list->n = 0;
}
.fi
.SS "static void \fBgl2psListSort\fP (\fBGL2PSlist\fP *list, int(*)(const void *\fBa\fP, const void *b)fcmp)\fC [static]\fP"
.PP
Definition at line 614 of file gl2ps\&.c\&.
.PP
References GL2PSlist::array, GL2PSlist::n, and GL2PSlist::size\&.
.PP
Referenced by gl2psBuildBspTree(), and gl2psPrintPrimitives()\&.
.PP
.nf
{
  if(!list)
    return;
  qsort(list->array, list->n, list->size, fcmp);
}
.fi
.SS "static void* \fBgl2psMalloc\fP (size_tsize)\fC [static]\fP"
.PP
Definition at line 323 of file gl2ps\&.c\&.
.PP
References GL2PS_ERROR, and gl2psMsg()\&.
.PP
Referenced by gl2psAddBoundaryInList(), gl2psAddPlanesInBspTreeImage(), gl2psAddPolyPrimitive(), gl2psAddText(), gl2psBeginPage(), gl2psBuildBspTree(), gl2psCopyPixmap(), gl2psCopyPrimitive(), gl2psCopyText(), gl2psCreateSplitPrimitive(), gl2psCreateSplitPrimitive2D(), gl2psDivideQuad(), gl2psDrawPixels(), gl2psListCreate(), gl2psListRealloc(), gl2psParseFeedbackBuffer(), gl2psPDFgroupListWriteObjects(), gl2psPrintPDFHeader(), gl2psPrintPrimitives(), and gl2psSplitPrimitive()\&.
.PP
.nf
{
  void *ptr;

  if(!size) return(NULL);
  ptr = malloc(size);
  if(!ptr){
    gl2psMsg(GL2PS_ERROR, 'Couldn't allocate requested memory');
    exit(1);
  }
  return(ptr);
}
.fi
.SS "static void \fBgl2psMsg\fP (GLintlevel, const char *fmt, \&.\&.\&.)\fC [static]\fP"
.PP
Definition at line 305 of file gl2ps\&.c\&.
.PP
References args, GL2PS_ERROR, GL2PS_INFO, GL2PS_SILENT, GL2PS_WARNING, and GL2PScontext::options\&.
.PP
Referenced by gl2psBeginPage(), gl2psClosePDFDataStream(), gl2psCopyPrimitive(), gl2psCreateSplitPrimitive(), gl2psDisable(), gl2psDrawPixels(), gl2psEnable(), gl2psFindRoot(), gl2psGetPlane(), gl2psListAdd(), gl2psListPointer(), gl2psListRealloc(), gl2psMalloc(), gl2psParseFeedbackBuffer(), gl2psPrintGzipFooter(), gl2psPrintPostScriptPrimitive(), gl2psPrintPrimitives(), gl2psPrintSVGPixmap(), gl2psPrintSVGPrimitive(), and gl2psRealloc()\&.
.PP
.nf
{
  va_list args;

  if(1 || !(gl2ps->options & GL2PS_SILENT)){
    switch(level){
    case GL2PS_INFO : fprintf(stderr, 'GL2PS info: '); break;
    case GL2PS_WARNING : fprintf(stderr, 'GL2PS warning: '); break;
    case GL2PS_ERROR : fprintf(stderr, 'GL2PS error: '); break;
    }
    va_start(args, fmt);
    vfprintf(stderr, fmt, args); 
    va_end(args);
    fprintf(stderr, '\n');
  }
  /* if(level == GL2PS_ERROR) exit(1); */
}
.fi
.SS "static GLfloat \fBgl2psNorm\fP (GLfloat *a)\fC [static]\fP"
.PP
Definition at line 1141 of file gl2ps\&.c\&.
.PP
Referenced by gl2psAddBoundaryInList(), and gl2psGetNormal()\&.
.PP
.nf
{
  return (GLfloat)sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);
}
.fi
.SS "static int \fBgl2psOpenPDFDataStream\fP (void)\fC [static]\fP"
.PP
Definition at line 4101 of file gl2ps\&.c\&.
.PP
References gl2psPrintPDFCompressorType(), and GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPDFHeader()\&.
.PP
.nf
{
  int offs = 0;
  
  offs += fprintf(gl2ps->stream, 
                  '4 0 obj\n'
                  '<<\n' 
                  '/Length 5 0 R\n' );
  offs += gl2psPrintPDFCompressorType();
  offs += fprintf(gl2ps->stream, 
                  '>>\n'
                  'stream\n');
  return offs;
}
.fi
.SS "static int \fBgl2psOpenPDFDataStreamWritePreface\fP (void)\fC [static]\fP"
.PP
Definition at line 4118 of file gl2ps\&.c\&.
.PP
References GL2PScontext::bgcolor, GL2PS_DRAW_BACKGROUND, gl2psPrintf(), gl2psPrintPDFFillColor(), GL2PScontext::options, and GL2PScontext::viewport\&.
.PP
Referenced by gl2psPrintPDFHeader()\&.
.PP
.nf
{
  int offs;

  offs = gl2psPrintf('/GSa gs\n');
  
  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    offs += gl2psPrintPDFFillColor(gl2ps->bgcolor);
    offs += gl2psPrintf('%d %d %d %d re\n',
                        (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                        (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
    offs += gl2psPrintf('f\n');  
  }
  return offs;
}
.fi
.SS "static void \fBgl2psParseFeedbackBuffer\fP (GLintused)\fC [static]\fP"
.PP
Definition at line 2256 of file gl2ps\&.c\&.
.PP
References GL2PScontext::auxprimitives, GL2PScontext::blendfunc, GL2PScontext::blending, GL2PSprimitive::boundary, GL2PScontext::boundary, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PScontext::feedback, GL2PSimage::format, GL2PS_BEGIN_BLEND_TOKEN, GL2PS_BEGIN_BOUNDARY_TOKEN, GL2PS_BEGIN_OFFSET_TOKEN, GL2PS_BEGIN_STIPPLE_TOKEN, GL2PS_DRAW_PIXELS_TOKEN, GL2PS_DST_BLEND_TOKEN, GL2PS_END_BLEND_TOKEN, GL2PS_END_BOUNDARY_TOKEN, GL2PS_END_OFFSET_TOKEN, GL2PS_END_STIPPLE_TOKEN, GL2PS_ERROR, GL2PS_IMAGEMAP, GL2PS_IMAGEMAP_TOKEN, GL2PS_LINE, GL2PS_LINE_WIDTH_TOKEN, GL2PS_POINT, GL2PS_POINT_SIZE_TOKEN, GL2PS_SRC_BLEND_TOKEN, GL2PS_TEXT_TOKEN, GL2PS_TRIANGLE, GL2PS_WARNING, gl2psAdaptVertexForBlending(), gl2psAddPolyPrimitive(), gl2psGetVertex(), gl2psListAdd(), gl2psListNbr(), gl2psListPointer(), gl2psListReset(), gl2psMalloc(), gl2psMsg(), GL2PSimage::height, i, _GL2PSimagemap::image, GL2PSprimitive::image, GL2PScontext::imagemap_head, GL2PScontext::imagemap_tail, _GL2PSimagemap::next, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PSprimitive::pattern, GL2PSimage::pixels, GL2PScontext::primitives, GL2PSvertex::rgba, GL2PSimage::type, GL2PSprimitive::type, GL2PSprimitive::verts, GL2PSimage::width, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  char flag;
  GLushort pattern = 0;
  GLboolean boundary;
  GLint i, sizeoffloat, count, v, vtot, offset = 0, factor = 0, auxindex = 0;
  GLfloat lwidth = 1\&.0F, psize = 1\&.0F;
  GLfloat *current;
  GL2PSvertex vertices[3];
  GL2PSprimitive *prim;
  GL2PSimagemap *node;

  current = gl2ps->feedback;
  boundary = gl2ps->boundary = GL_FALSE;

  while(used > 0){

    if(GL_TRUE == boundary) gl2ps->boundary = GL_TRUE;
    
    switch((GLint)*current){
    case GL_POINT_TOKEN :
      current ++;
      used --;
      i = gl2psGetVertex(&vertices[0], current);
      current += i;
      used    -= i;
      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0, 
                            pattern, factor, psize, 0);
      break;
    case GL_LINE_TOKEN :
    case GL_LINE_RESET_TOKEN :
      current ++;
      used --;
      i = gl2psGetVertex(&vertices[0], current);
      current += i;
      used    -= i;
      i = gl2psGetVertex(&vertices[1], current);
      current += i;
      used    -= i;
      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0, 
                            pattern, factor, lwidth, 0);
      break;
    case GL_POLYGON_TOKEN :
      count = (GLint)current[1];
      current += 2;
      used -= 2;
      v = vtot = 0;
      while(count > 0 && used > 0){
        i = gl2psGetVertex(&vertices[v], current);
        gl2psAdaptVertexForBlending(&vertices[v]);
        current += i;
        used    -= i;
        count --;
        vtot++;
        if(v == 2){
          if(GL_TRUE == boundary){
            if(!count && vtot == 2) flag = 1|2|4;
            else if(!count) flag = 2|4;
            else if(vtot == 2) flag = 1|2;
            else flag = 2;
          }
          else
            flag = 0;
          gl2psAddPolyPrimitive(GL2PS_TRIANGLE, 3, vertices, offset,
                                pattern, factor, 1, flag);
          vertices[1] = vertices[2];
        }
        else
          v ++;
      }
      break;      
    case GL_BITMAP_TOKEN :
    case GL_DRAW_PIXEL_TOKEN :
    case GL_COPY_PIXEL_TOKEN :
      current ++;
      used --;
      i = gl2psGetVertex(&vertices[0], current);
      current += i;
      used    -= i;
      break;      
    case GL_PASS_THROUGH_TOKEN :
      switch((GLint)current[1]){
      case GL2PS_BEGIN_OFFSET_TOKEN : offset = 1; break;
      case GL2PS_END_OFFSET_TOKEN : offset = 0; break;
      case GL2PS_BEGIN_BOUNDARY_TOKEN : boundary = GL_TRUE; break;
      case GL2PS_END_BOUNDARY_TOKEN : boundary = GL_FALSE; break;
      case GL2PS_END_STIPPLE_TOKEN : pattern = factor = 0; break;
      case GL2PS_BEGIN_BLEND_TOKEN : gl2ps->blending = GL_TRUE; break;
      case GL2PS_END_BLEND_TOKEN : gl2ps->blending = GL_FALSE; break;
      case GL2PS_BEGIN_STIPPLE_TOKEN : 
        current += 2;
        used -= 2; 
        pattern = (GLushort)current[1]; 
        current += 2;
        used -= 2; 
        factor = (GLint)current[1]; 
        break;
      case GL2PS_SRC_BLEND_TOKEN : 
        current += 2; 
        used -= 2; 
        gl2ps->blendfunc[0] = (GLint)current[1];
        break;
      case GL2PS_DST_BLEND_TOKEN : 
        current += 2; 
        used -= 2; 
        gl2ps->blendfunc[1] = (GLint)current[1];
        break;
      case GL2PS_POINT_SIZE_TOKEN : 
        current += 2; 
        used -= 2; 
        psize = current[1];
        break;
      case GL2PS_LINE_WIDTH_TOKEN : 
        current += 2; 
        used -= 2; 
        lwidth = current[1];
        break;
      case GL2PS_IMAGEMAP_TOKEN :
        prim = (GL2PSprimitive *)gl2psMalloc(sizeof(GL2PSprimitive));
        prim->type = GL2PS_IMAGEMAP;
        prim->boundary = 0;
        prim->numverts = 4;
        prim->verts = (GL2PSvertex *)gl2psMalloc(4 * sizeof(GL2PSvertex));
        prim->culled = 0;
        prim->offset = 0;
        prim->pattern = 0;
        prim->factor = 0;
        prim->width = 1;
        
        node = (GL2PSimagemap*)gl2psMalloc(sizeof(GL2PSimagemap));
        node->image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
        node->image->type = 0;
        node->image->format = 0;
        node->next = NULL;
        
        if(gl2ps->imagemap_head == NULL)
          gl2ps->imagemap_head = node;
        else
          gl2ps->imagemap_tail->next = node;
        gl2ps->imagemap_tail = node;
        prim->data\&.image = node->image;
        
        current += 2; used -= 2;
        i = gl2psGetVertex(&prim->verts[0], &current[1]);
        current += i; used -= i;
        
        node->image->width = (GLint)current[2];
        current += 2; used -= 2;
        node->image->height = (GLint)current[2];
        prim->verts[0]\&.xyz[0] = prim->verts[0]\&.xyz[0] - (int)(node->image->width / 2) + 0\&.5;
        prim->verts[0]\&.xyz[1] = prim->verts[0]\&.xyz[1] - (int)(node->image->height / 2) + 0\&.5;
        for(i = 1; i < 4; i++){
          for(v = 0; v < 3; v++){
            prim->verts[i]\&.xyz[v] = prim->verts[0]\&.xyz[v];
            prim->verts[i]\&.rgba[v] = prim->verts[0]\&.rgba[v];
          }
          prim->verts[i]\&.rgba[v] = prim->verts[0]\&.rgba[v];
        }
        prim->verts[1]\&.xyz[0] = prim->verts[1]\&.xyz[0] + node->image->width;
        prim->verts[2]\&.xyz[0] = prim->verts[1]\&.xyz[0];
        prim->verts[2]\&.xyz[1] = prim->verts[2]\&.xyz[1] + node->image->height;
        prim->verts[3]\&.xyz[1] = prim->verts[2]\&.xyz[1];

        sizeoffloat = sizeof(GLfloat);
        v = 2 * sizeoffloat;
        vtot = node->image->height + node->image->height * 
          ((node->image->width-1)/8);
        node->image->pixels = (GLfloat*)gl2psMalloc(v + vtot);
        node->image->pixels[0] = prim->verts[0]\&.xyz[0];
        node->image->pixels[1] = prim->verts[0]\&.xyz[1];
        
        for(i = 0; i < vtot; i += sizeoffloat){
          current += 2; used -= 2;
          if((vtot - i) >= 4)
            memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), sizeoffloat);
          else
            memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), vtot - i);
        }
        current++; used--;
        gl2psListAdd(gl2ps->primitives, &prim);
        break;
      case GL2PS_DRAW_PIXELS_TOKEN :
      case GL2PS_TEXT_TOKEN :
        if(auxindex < gl2psListNbr(gl2ps->auxprimitives))
          gl2psListAdd(gl2ps->primitives, 
                       gl2psListPointer(gl2ps->auxprimitives, auxindex++));
        else
          gl2psMsg(GL2PS_ERROR, 'Wrong number of auxiliary tokens in buffer');
        break;
      }
      current += 2; 
      used -= 2; 
      break;      
    default :
      gl2psMsg(GL2PS_WARNING, 'Unknown token in buffer');
      current ++;
      used --;
      break;
    }
  }

  gl2psListReset(gl2ps->auxprimitives);
}
.fi
.SS "static void \fBgl2psParseStipplePattern\fP (GLushortpattern, GLintfactor, int *nb, intarray[10])\fC [static]\fP"
.PP
Definition at line 3005 of file gl2ps\&.c\&.
.PP
References i, n, off, on, and tmp\&.
.PP
Referenced by gl2psPrintPGFDash(), gl2psPrintPostScriptDash(), and gl2psPrintSVGDash()\&.
.PP
.nf
{
  int i, n;
  int on[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  int off[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  char tmp[16];

  /* extract the 16 bits from the OpenGL stipple pattern */
  for(n = 15; n >= 0; n--){
    tmp[n] = (char)(pattern & 0x01);
    pattern >>= 1;
  }
  /* compute the on/off pixel sequence */
  n = 0;
  for(i = 0; i < 8; i++){
    while(n < 16 && !tmp[n]){ off[i]++; n++; }
    while(n < 16 && tmp[n]){ on[i]++; n++; }
    if(n >= 15){ i++; break; }
  }

  /* store the on/off array from right to left, starting with off
     pixels\&. The PostScript specification allows for at most 11
     elements in the on/off array, so we limit ourselves to 5 on/off
     couples (our longest possible array is thus [on4 off4 on3 off3
     on2 off2 on1 off1 on0 off0]) */
  *nb = 0;
  for(n = i - 1; n >= 0; n--){
    array[(*nb)++] = factor * on[n];
    array[(*nb)++] = factor * off[n];
    if(*nb == 10) break;
  }
}
.fi
.SS "static void \fBgl2psPDFgroupListDelete\fP (void)\fC [static]\fP"
.PP
Definition at line 4016 of file gl2ps\&.c\&.
.PP
References gl2psListDelete(), gl2psListNbr(), gl2psListPointer(), i, GL2PScontext::pdfgrouplist, and GL2PSpdfgroup::ptrlist\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  int i;
  GL2PSpdfgroup *gro = NULL;
  
  if(!gl2ps->pdfgrouplist)
    return;

  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){ 
    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist,i);
    gl2psListDelete(gro->ptrlist);
  }

  gl2psListDelete(gl2ps->pdfgrouplist);
  gl2ps->pdfgrouplist = NULL;
}
.fi
.SS "static void \fBgl2psPDFgroupListInit\fP (void)\fC [static]\fP"
.PP
Definition at line 3579 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::factor, GL2PScontext::font_stack, GL2PSpdfgroup::fontno, GL2PS_LINE, GL2PS_NO_TYPE, GL2PS_PIXMAP, GL2PS_POINT, GL2PS_TEXT, GL2PS_TRIANGLE, gl2psFillTriangleFromPrimitive(), gl2psInitTriangle(), gl2psListAdd(), gl2psListCreate(), gl2psListNbr(), gl2psListPointer(), gl2psPDFgroupObjectInit(), gl2psSameColor(), i, GL2PScontext::im_stack, GL2PSpdfgroup::imno, p, GL2PSprimitive::pattern, GL2PScontext::pdfgrouplist, GL2PScontext::pdfprimlist, GL2PStriangle::prop, GL2PSpdfgroup::ptrlist, GL2PSvertex::rgba, T_ALPHA_1, T_CONST_COLOR, GL2PSprimitive::type, GL2PStriangle::vertex, GL2PSprimitive::verts, and GL2PSprimitive::width\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  int i;
  GL2PSprimitive *p = NULL;
  GL2PSpdfgroup gro;
  int lasttype = GL2PS_NO_TYPE;
  GL2PSrgba lastrgba = {-1\&.0F, -1\&.0F, -1\&.0F, -1\&.0F};
  GLushort lastpattern = 0;
  GLint lastfactor = 0;
  GLfloat lastwidth = 1;
  GL2PStriangle lastt, tmpt;
  int lastTriangleWasNotSimpleWithSameColor = 0;

  if(!gl2ps->pdfprimlist)
    return;

  gl2ps->pdfgrouplist = gl2psListCreate(500, 500, sizeof(GL2PSpdfgroup));
  gl2psInitTriangle(&lastt);

  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){  
    p = *(GL2PSprimitive**)gl2psListPointer(gl2ps->pdfprimlist, i);
    switch(p->type){
    case GL2PS_PIXMAP:
      gl2psPDFgroupObjectInit(&gro);
      gro\&.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
      gro\&.imno = gl2ps->im_stack++;
      gl2psListAdd(gro\&.ptrlist, &p);
      gl2psListAdd(gl2ps->pdfgrouplist, &gro);
      break;
    case GL2PS_TEXT:
      gl2psPDFgroupObjectInit(&gro);
      gro\&.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
      gro\&.fontno = gl2ps->font_stack++;
      gl2psListAdd(gro\&.ptrlist, &p);
      gl2psListAdd(gl2ps->pdfgrouplist, &gro);
      break;
    case GL2PS_LINE:
      if(lasttype != p->type || lastwidth != p->width || 
         lastpattern != p->pattern || lastfactor != p->factor ||
         !gl2psSameColor(p->verts[0]\&.rgba, lastrgba)){
        gl2psPDFgroupObjectInit(&gro);
        gro\&.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
        gl2psListAdd(gro\&.ptrlist, &p);
        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
      }
      else{
        gl2psListAdd(gro\&.ptrlist, &p);
      }
      lastpattern = p->pattern;
      lastfactor = p->factor;
      lastwidth = p->width;
      lastrgba[0] = p->verts[0]\&.rgba[0];
      lastrgba[1] = p->verts[0]\&.rgba[1];
      lastrgba[2] = p->verts[0]\&.rgba[2];
      break;
    case GL2PS_POINT:
      if(lasttype != p->type || lastwidth != p->width || 
         !gl2psSameColor(p->verts[0]\&.rgba, lastrgba)){
        gl2psPDFgroupObjectInit(&gro);
        gro\&.ptrlist = gl2psListCreate(1,2,sizeof(GL2PSprimitive*));
        gl2psListAdd(gro\&.ptrlist, &p);
        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
      }
      else{
        gl2psListAdd(gro\&.ptrlist, &p);
      }
      lastwidth = p->width;
      lastrgba[0] = p->verts[0]\&.rgba[0];
      lastrgba[1] = p->verts[0]\&.rgba[1];
      lastrgba[2] = p->verts[0]\&.rgba[2];
      break;
    case GL2PS_TRIANGLE:
      gl2psFillTriangleFromPrimitive(&tmpt, p, GL_TRUE);
      lastTriangleWasNotSimpleWithSameColor = 
        !(tmpt\&.prop & T_CONST_COLOR && tmpt\&.prop & T_ALPHA_1) ||
        !gl2psSameColor(tmpt\&.vertex[0]\&.rgba, lastt\&.vertex[0]\&.rgba);
      if(lasttype == p->type && tmpt\&.prop == lastt\&.prop && 
         lastTriangleWasNotSimpleWithSameColor){
        /* TODO Check here for last alpha */
        gl2psListAdd(gro\&.ptrlist, &p);
      }
      else{
        gl2psPDFgroupObjectInit(&gro);
        gro\&.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
        gl2psListAdd(gro\&.ptrlist, &p);
        gl2psListAdd(gl2ps->pdfgrouplist, &gro);
      }
      lastt = tmpt;
      break;
    default:
      break;
    } 
    lasttype = p->type;
  }
}
.fi
.SS "static int \fBgl2psPDFgroupListWriteFontResources\fP (void)\fC [static]\fP"
.PP
Definition at line 3996 of file gl2ps\&.c\&.
.PP
References GL2PSpdfgroup::fontno, GL2PSpdfgroup::fontobjno, gl2psListNbr(), gl2psListPointer(), i, GL2PScontext::objects_stack, GL2PScontext::pdfgrouplist, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPDFgroupListWriteVariableResources()\&.
.PP
.nf
{
  int i;
  GL2PSpdfgroup *gro;
  int offs = 0;

  offs += fprintf(gl2ps->stream, '/Font\n<<\n');

  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
    if(gro->fontno < 0)
      continue;
    gro->fontobjno = gl2ps->objects_stack++;
    offs += fprintf(gl2ps->stream, '/F%d %d 0 R\n', gro->fontno, gro->fontobjno);
  }
  offs += fprintf(gl2ps->stream, '>>\n');

  return offs;
}
.fi
.SS "static int \fBgl2psPDFgroupListWriteGStateResources\fP (void)\fC [static]\fP"
.PP
Definition at line 3917 of file gl2ps\&.c\&.
.PP
References gl2psListNbr(), gl2psListPointer(), GL2PSpdfgroup::gsno, GL2PSpdfgroup::gsobjno, i, GL2PScontext::pdfgrouplist, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPDFgroupListWriteVariableResources()\&.
.PP
.nf
{
  GL2PSpdfgroup *gro;
  int offs = 0;
  int i;

  offs += fprintf(gl2ps->stream,
                  '/ExtGState\n' 
                  '<<\n'
                  '/GSa 7 0 R\n');
  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
    if(gro->gsno >= 0)
      offs += fprintf(gl2ps->stream, '/GS%d %d 0 R\n', gro->gsno, gro->gsobjno);
  }
  offs += fprintf(gl2ps->stream, '>>\n'); 
  return offs;
}
.fi
.SS "static void \fBgl2psPDFgroupListWriteMainStream\fP (void)\fC [static]\fP"
.PP
Definition at line 3729 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::data, GL2PSprimitive::factor, GL2PSpdfgroup::fontno, GL2PS_LINE, GL2PS_PIXMAP, GL2PS_POINT, GL2PS_TEXT, GL2PS_TRIANGLE, gl2psFillTriangleFromPrimitive(), gl2psListNbr(), gl2psListPointer(), gl2psPrintf(), gl2psPrintPDFFillColor(), gl2psPrintPDFLineWidth(), gl2psPrintPDFStrokeColor(), gl2psPrintPostScriptDash(), gl2psPutPDFImage(), gl2psPutPDFText(), gl2psSamePosition(), gl2psSortOutTrianglePDFgroup(), GL2PSpdfgroup::gsno, i, GL2PSprimitive::image, GL2PSpdfgroup::imno, GL2PSprimitive::pattern, GL2PScontext::pdfgrouplist, GL2PStriangle::prop, GL2PSpdfgroup::ptrlist, GL2PSvertex::rgba, GL2PSpdfgroup::shno, GL2PScontext::streamlength, t, T_ALPHA_1, T_ALPHA_LESS_1, T_CONST_COLOR, T_VAR_ALPHA, T_VAR_COLOR, GL2PSprimitive::text, GL2PSpdfgroup::trgroupno, GL2PSprimitive::type, GL2PStriangle::vertex, GL2PSprimitive::verts, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  int i, j, lastel;
  GL2PSprimitive *prim = NULL, *prev = NULL;
  GL2PSpdfgroup *gro;
  GL2PStriangle t;

  if(!gl2ps->pdfgrouplist)
    return;

  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);

    lastel = gl2psListNbr(gro->ptrlist) - 1;
    if(lastel < 0)
      continue;

    prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);

    switch(prim->type){
    case GL2PS_POINT:
      gl2ps->streamlength += gl2psPrintf('1 J\n');
      gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
      gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0]\&.rgba);
      for(j = 0; j <= lastel; ++j){  
        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
        gl2ps->streamlength +=
          gl2psPrintf('%f %f m %f %f l\n',
                      prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1],
                      prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
      }
      gl2ps->streamlength += gl2psPrintf('S\n'); 
      gl2ps->streamlength += gl2psPrintf('0 J\n');
      break;
    case GL2PS_LINE:
      /* We try to use as few paths as possible to draw lines, in
         order to get nice stippling even when the individual segments
         are smaller than the stipple */
      gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
      gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0]\&.rgba);
      gl2ps->streamlength += gl2psPrintPostScriptDash(prim->pattern, prim->factor, 'd');
      /* start new path */
      gl2ps->streamlength += 
        gl2psPrintf('%f %f m\n', 
                    prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
      
      for(j = 1; j <= lastel; ++j){
        prev = prim;
        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
        if(!gl2psSamePosition(prim->verts[0]\&.xyz, prev->verts[1]\&.xyz)){
          /* the starting point of the new segment does not match the
             end point of the previous line, so we end the current
             path and start a new one */
          gl2ps->streamlength += 
            gl2psPrintf('%f %f l\n', 
                        prev->verts[1]\&.xyz[0], prev->verts[1]\&.xyz[1]);
          gl2ps->streamlength += 
            gl2psPrintf('%f %f m\n', 
                        prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
        }
        else{
          /* the two segements are connected, so we just append to the
             current path */
          gl2ps->streamlength += 
            gl2psPrintf('%f %f l\n',
                        prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
        }
      }
      /* end last path */
      gl2ps->streamlength += 
        gl2psPrintf('%f %f l\n', 
                    prim->verts[1]\&.xyz[0], prim->verts[1]\&.xyz[1]);
      gl2ps->streamlength += gl2psPrintf('S\n');
      break;
    case GL2PS_TRIANGLE:
      gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
      gl2psSortOutTrianglePDFgroup(gro);
      
      /* No alpha and const color: Simple PDF draw orders  */
      if(t\&.prop & T_CONST_COLOR && t\&.prop & T_ALPHA_1){         
        gl2ps->streamlength += gl2psPrintPDFFillColor(t\&.vertex[0]\&.rgba);        
        for(j = 0; j <= lastel; ++j){  
          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
          gl2ps->streamlength 
            += gl2psPrintf('%f %f m\n'
                           '%f %f l\n'
                           '%f %f l\n'
                           'h f\n',
                           t\&.vertex[0]\&.xyz[0], t\&.vertex[0]\&.xyz[1],
                           t\&.vertex[1]\&.xyz[0], t\&.vertex[1]\&.xyz[1],
                           t\&.vertex[2]\&.xyz[0], t\&.vertex[2]\&.xyz[1]);
        }
      }
      /* Const alpha < 1 and const color: Simple PDF draw orders 
         and an extra extended Graphics State for the alpha const */
      else if(t\&.prop & T_CONST_COLOR && t\&.prop & T_ALPHA_LESS_1){               
        gl2ps->streamlength += gl2psPrintf('q\n'
                                           '/GS%d gs\n',
                                           gro->gsno);
        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0]\&.rgba);
        for(j = 0; j <= lastel; ++j){  
          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
          gl2ps->streamlength 
            += gl2psPrintf('%f %f m\n'
                           '%f %f l\n'
                           '%f %f l\n'
                           'h f\n',
                           t\&.vertex[0]\&.xyz[0], t\&.vertex[0]\&.xyz[1],
                           t\&.vertex[1]\&.xyz[0], t\&.vertex[1]\&.xyz[1],
                           t\&.vertex[2]\&.xyz[0], t\&.vertex[2]\&.xyz[1]);
        }
        gl2ps->streamlength += gl2psPrintf('Q\n');
      }
      /* Variable alpha and const color: Simple PDF draw orders 
         and an extra extended Graphics State + Xobject + Shader 
         object for the alpha mask */
      else if(t\&.prop & T_CONST_COLOR && t\&.prop & T_VAR_ALPHA){          
        gl2ps->streamlength += gl2psPrintf('q\n'
                                           '/GS%d gs\n'
                                           '/TrG%d Do\n',
                                           gro->gsno, gro->trgroupno);
        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0]\&.rgba);
        for(j = 0; j <= lastel; ++j){  
          prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
          gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
          gl2ps->streamlength 
            += gl2psPrintf('%f %f m\n'
                           '%f %f l\n'
                           '%f %f l\n'
                           'h f\n',
                           t\&.vertex[0]\&.xyz[0], t\&.vertex[0]\&.xyz[1],
                           t\&.vertex[1]\&.xyz[0], t\&.vertex[1]\&.xyz[1],
                           t\&.vertex[2]\&.xyz[0], t\&.vertex[2]\&.xyz[1]);
        }
        gl2ps->streamlength += gl2psPrintf('Q\n');
      }
      /* Variable color and no alpha: Shader Object for the colored
         triangle(s) */
      else if(t\&.prop & T_VAR_COLOR && t\&.prop & T_ALPHA_1){              
        gl2ps->streamlength += gl2psPrintf('/Sh%d sh\n', gro->shno);
      }
      /* Variable color and const alpha < 1: Shader Object for the 
         colored triangle(s) and an extra extended Graphics State 
         for the alpha const */
      else if(t\&.prop & T_VAR_COLOR && t\&.prop & T_ALPHA_LESS_1){         
        gl2ps->streamlength += gl2psPrintf('q\n'
                                           '/GS%d gs\n'
                                           '/Sh%d sh\n'
                                           'Q\n',
                                           gro->gsno, gro->shno);
      }
      /* Variable alpha and color: Shader Object for the colored 
         triangle(s) and an extra extended Graphics State 
         + Xobject + Shader object for the alpha mask */
      else if(t\&.prop & T_VAR_COLOR && t\&.prop & T_VAR_ALPHA){            
        gl2ps->streamlength += gl2psPrintf('q\n'
                                           '/GS%d gs\n'
                                           '/TrG%d Do\n'
                                           '/Sh%d sh\n'
                                           'Q\n',
                                           gro->gsno, gro->trgroupno, gro->shno);
      }
      break;
    case GL2PS_PIXMAP:
      for(j = 0; j <= lastel; ++j){
        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
        gl2psPutPDFImage(prim->data\&.image, gro->imno, prim->verts[0]\&.xyz[0], 
                         prim->verts[0]\&.xyz[1]);
      }
      break;
    case GL2PS_TEXT:
      for(j = 0; j <= lastel; ++j){  
        prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
        gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0]\&.rgba);
        gl2psPutPDFText(prim->data\&.text, gro->fontno, prim->verts[0]\&.xyz[0],
                        prim->verts[0]\&.xyz[1]);
      }
      break;
    default:
      break;
    } 
  }
}
.fi
.SS "static int \fBgl2psPDFgroupListWriteObjects\fP (intentryoffs)\fC [static]\fP"
.PP
Definition at line 4736 of file gl2ps\&.c\&.
.PP
References GL2PSstring::alignment, GL2PSprimitive::data, GL2PSpdfgroup::fontno, GL2PSpdfgroup::fontobjno, GL2PSimage::format, GL2PS_LINE, GL2PS_PDF, GL2PS_PIXMAP, GL2PS_POINT, GL2PS_SPECIAL, GL2PS_TEXT, GL2PS_TRIANGLE, gl2psFillTriangleFromPrimitive(), gl2psFree(), gl2psListNbr(), gl2psListPointer(), gl2psMalloc(), gl2psPrintPDFPixmap(), gl2psPrintPDFShader(), gl2psPrintPDFShaderExtGS(), gl2psPrintPDFShaderMask(), gl2psPrintPDFShaderSimpleExtGS(), gl2psPrintPDFText(), GL2PSpdfgroup::gsobjno, i, GL2PSprimitive::image, GL2PSpdfgroup::imobjno, GL2PSpdfgroup::maskshno, GL2PSpdfgroup::maskshobjno, p, GL2PScontext::pdfgrouplist, prop, GL2PSpdfgroup::ptrlist, GL2PSvertex::rgba, GL2PSpdfgroup::shobjno, GL2PSstring::str, GL2PScontext::stream, T_ALPHA_LESS_1, T_VAR_ALPHA, T_VAR_COLOR, GL2PSprimitive::text, GL2PSpdfgroup::trgroupobjno, GL2PSprimitive::type, GL2PStriangle::vertex, and GL2PScontext::xreflist\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  int i,j;
  GL2PSprimitive *p = NULL;
  GL2PSpdfgroup *gro;
  int offs = entryoffs;
  GL2PStriangle *triangles;
  int size = 0;

  if(!gl2ps->pdfgrouplist)
    return offs;
  
  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
    if(!gl2psListNbr(gro->ptrlist))
      continue;
    p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
    switch(p->type){
    case GL2PS_POINT:
      break;
    case GL2PS_LINE:
      break;
    case GL2PS_TRIANGLE:
      size = gl2psListNbr(gro->ptrlist);
      triangles = (GL2PStriangle*)gl2psMalloc(sizeof(GL2PStriangle) * size);
      for(j = 0; j < size; ++j){  
        p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
        gl2psFillTriangleFromPrimitive(&triangles[j], p, GL_TRUE);
      }
      if(triangles[0]\&.prop & T_VAR_COLOR){
        gl2ps->xreflist[gro->shobjno] = offs;
        offs += gl2psPrintPDFShader(gro->shobjno, triangles, size, 0);
      }
      if(triangles[0]\&.prop & T_ALPHA_LESS_1){
        gl2ps->xreflist[gro->gsobjno] = offs;
        offs += gl2psPrintPDFShaderSimpleExtGS(gro->gsobjno, triangles[0]\&.vertex[0]\&.rgba[3]);
      }
      if(triangles[0]\&.prop & T_VAR_ALPHA){
        gl2ps->xreflist[gro->gsobjno] = offs;
        offs += gl2psPrintPDFShaderExtGS(gro->gsobjno, gro->trgroupobjno);
        gl2ps->xreflist[gro->trgroupobjno] = offs;
        offs += gl2psPrintPDFShaderMask(gro->trgroupobjno, gro->maskshno);
        gl2ps->xreflist[gro->maskshobjno] = offs;
        offs += gl2psPrintPDFShader(gro->maskshobjno, triangles, size, 8);
      }
      gl2psFree(triangles);
      break;
    case GL2PS_PIXMAP:
      gl2ps->xreflist[gro->imobjno] = offs;
      offs += gl2psPrintPDFPixmap(gro->imobjno, gro->imobjno+1, p->data\&.image, 0);
      if(p->data\&.image->format == GL_RGBA){
        gl2ps->xreflist[gro->imobjno+1] = offs;
        offs += gl2psPrintPDFPixmap(gro->imobjno+1, -1, p->data\&.image, 8);
      }
      break;
    case GL2PS_TEXT:
      gl2ps->xreflist[gro->fontobjno] = offs;
      offs += gl2psPrintPDFText(gro->fontobjno,p->data\&.text,gro->fontno);
      break;
    case GL2PS_SPECIAL :
      /* alignment contains the format for which the special output text
         is intended */
      if(p->data\&.text->alignment == GL2PS_PDF)
        offs += fprintf(gl2ps->stream, '%s\n', p->data\&.text->str);
      break;
    default:
      break;
    } 
  }
  return offs;
}
.fi
.SS "static int \fBgl2psPDFgroupListWriteShaderResources\fP (void)\fC [static]\fP"
.PP
Definition at line 3938 of file gl2ps\&.c\&.
.PP
References gl2psListNbr(), gl2psListPointer(), i, GL2PSpdfgroup::maskshno, GL2PSpdfgroup::maskshobjno, GL2PScontext::pdfgrouplist, GL2PSpdfgroup::shno, GL2PSpdfgroup::shobjno, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPDFgroupListWriteVariableResources()\&.
.PP
.nf
{
  GL2PSpdfgroup *gro;
  int offs = 0;
  int i;

  offs += fprintf(gl2ps->stream,
                  '/Shading\n'
                  '<<\n');
  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
    if(gro->shno >= 0)
      offs += fprintf(gl2ps->stream, '/Sh%d %d 0 R\n', gro->shno, gro->shobjno);
    if(gro->maskshno >= 0)
      offs += fprintf(gl2ps->stream, '/TrSh%d %d 0 R\n', gro->maskshno, gro->maskshobjno);
  }
  offs += fprintf(gl2ps->stream,'>>\n');  
  return offs;
}
.fi
.SS "static int \fBgl2psPDFgroupListWriteVariableResources\fP (void)\fC [static]\fP"
.PP
Definition at line 4246 of file gl2ps\&.c\&.
.PP
References gl2psPDFgroupListWriteFontResources(), gl2psPDFgroupListWriteGStateResources(), gl2psPDFgroupListWriteShaderResources(), gl2psPDFgroupListWriteXObjectResources(), and GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  int offs = 0;
  
  /* a) Graphics States for shader alpha masks*/
  offs += gl2psPDFgroupListWriteGStateResources();  
  
  /* b) Shader and shader masks */ 
  offs += gl2psPDFgroupListWriteShaderResources();  
 
  /* c) XObjects (Images & Shader Masks) */
  offs += gl2psPDFgroupListWriteXObjectResources();
  
  /* d) Fonts */
  offs += gl2psPDFgroupListWriteFontResources();
  
  /* End resources and page */
  offs += fprintf(gl2ps->stream,
                  '>>\n'
                  '>>\n'
                  'endobj\n');
  return offs;
}
.fi
.SS "static int \fBgl2psPDFgroupListWriteXObjectResources\fP (void)\fC [static]\fP"
.PP
Definition at line 3960 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::data, GL2PSimage::format, GL2PS_PIXMAP, GL2PS_TRIANGLE, gl2psListNbr(), gl2psListPointer(), i, GL2PSprimitive::image, GL2PSpdfgroup::imno, GL2PSpdfgroup::imobjno, GL2PScontext::objects_stack, p, GL2PScontext::pdfgrouplist, GL2PSpdfgroup::ptrlist, GL2PScontext::stream, GL2PSpdfgroup::trgroupno, GL2PSpdfgroup::trgroupobjno, and GL2PSprimitive::type\&.
.PP
Referenced by gl2psPDFgroupListWriteVariableResources()\&.
.PP
.nf
{
  int i;
  GL2PSprimitive *p = NULL;
  GL2PSpdfgroup *gro;
  int offs = 0;

  offs += fprintf(gl2ps->stream,
                  '/XObject\n'
                  '<<\n');

  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
    if(!gl2psListNbr(gro->ptrlist))
      continue;
    p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
    switch(p->type){
    case GL2PS_PIXMAP:
      gro->imobjno = gl2ps->objects_stack++;
      if(GL_RGBA == p->data\&.image->format)  /* reserve one object for image mask */
        gl2ps->objects_stack++;
      offs += fprintf(gl2ps->stream, '/Im%d %d 0 R\n', gro->imno, gro->imobjno);
    case GL2PS_TRIANGLE:
      if(gro->trgroupno >=0)
        offs += fprintf(gl2ps->stream, '/TrG%d %d 0 R\n', gro->trgroupno, gro->trgroupobjno);
      break;
    default:
      break;
    }
  }
  offs += fprintf(gl2ps->stream,'>>\n');
  return offs;
}
.fi
.SS "static void \fBgl2psPDFgroupObjectInit\fP (\fBGL2PSpdfgroup\fP *gro)\fC [static]\fP"
.PP
Definition at line 3566 of file gl2ps\&.c\&.
.PP
References GL2PSpdfgroup::fontno, GL2PSpdfgroup::fontobjno, GL2PSpdfgroup::gsno, GL2PSpdfgroup::gsobjno, GL2PSpdfgroup::imno, GL2PSpdfgroup::imobjno, GL2PSpdfgroup::maskshno, GL2PSpdfgroup::maskshobjno, GL2PSpdfgroup::ptrlist, GL2PSpdfgroup::shno, GL2PSpdfgroup::shobjno, GL2PSpdfgroup::trgroupno, and GL2PSpdfgroup::trgroupobjno\&.
.PP
Referenced by gl2psPDFgroupListInit()\&.
.PP
.nf
{
  if(!gro)
    return;
  
  gro->ptrlist = NULL;
  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno 
    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno 
    = gro->maskshobjno = gro->gsobjno = gro->trgroupobjno = -1;
}
.fi
.SS "static void \fBgl2psPDFRectHull\fP (GLfloat *xmin, GLfloat *xmax, GLfloat *ymin, GLfloat *ymax, \fBGL2PStriangle\fP *triangles, intcnt)\fC [static]\fP"
.PP
Definition at line 4418 of file gl2ps\&.c\&.
.PP
References i, GL2PStriangle::vertex, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPDFShader()\&.
.PP
.nf
{
  int i, j;

  *xmin = triangles[0]\&.vertex[0]\&.xyz[0];
  *xmax = triangles[0]\&.vertex[0]\&.xyz[0];
  *ymin = triangles[0]\&.vertex[0]\&.xyz[1];
  *ymax = triangles[0]\&.vertex[0]\&.xyz[1];
  
  for(i = 0; i < cnt; ++i){
    for(j = 0; j < 3; ++j){
      if(*xmin > triangles[i]\&.vertex[j]\&.xyz[0])
        *xmin = triangles[i]\&.vertex[j]\&.xyz[0];
      if(*xmax < triangles[i]\&.vertex[j]\&.xyz[0])
        *xmax = triangles[i]\&.vertex[j]\&.xyz[0];
      if(*ymin > triangles[i]\&.vertex[j]\&.xyz[1])
        *ymin = triangles[i]\&.vertex[j]\&.xyz[1];
      if(*ymax < triangles[i]\&.vertex[j]\&.xyz[1])
        *ymax = triangles[i]\&.vertex[j]\&.xyz[1];
    }
  }
}
.fi
.SS "static void \fBgl2psPDFstacksInit\fP (void)\fC [static]\fP"
.PP
Definition at line 3555 of file gl2ps\&.c\&.
.PP
References GL2PScontext::extgs_stack, GL2PScontext::font_stack, GL2PScontext::im_stack, GL2PScontext::mshader_stack, GL2PScontext::objects_stack, GL2PScontext::shader_stack, and GL2PScontext::trgroupobjects_stack\&.
.PP
Referenced by gl2psPrintPDFHeader()\&.
.PP
.nf
{
  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1; 
  gl2ps->extgs_stack = 0;   
  gl2ps->font_stack = 0;    
  gl2ps->im_stack = 0;      
  gl2ps->trgroupobjects_stack = 0;    
  gl2ps->shader_stack = 0;  
  gl2ps->mshader_stack = 0; 
}
.fi
.SS "static const char* \fBgl2psPGFTextAlignment\fP (intalign)\fC [static]\fP"
.PP
Definition at line 5386 of file gl2ps\&.c\&.
.PP
References GL2PS_TEXT_B, GL2PS_TEXT_BL, GL2PS_TEXT_BR, GL2PS_TEXT_C, GL2PS_TEXT_CL, GL2PS_TEXT_CR, GL2PS_TEXT_T, GL2PS_TEXT_TL, and GL2PS_TEXT_TR\&.
.PP
Referenced by gl2psPrintPGFPrimitive()\&.
.PP
.nf
{
  switch(align){
  case GL2PS_TEXT_C  : return 'center';
  case GL2PS_TEXT_CL : return 'west';
  case GL2PS_TEXT_CR : return 'east';
  case GL2PS_TEXT_B  : return 'south';
  case GL2PS_TEXT_BR : return 'south east';
  case GL2PS_TEXT_T  : return 'north';
  case GL2PS_TEXT_TL : return 'north west';
  case GL2PS_TEXT_TR : return 'north east';
  case GL2PS_TEXT_BL : 
  default            : return 'south west';
  }
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psPointSize\fP (GLfloatvalue)"
.PP
Definition at line 6066 of file gl2ps\&.c\&.
.PP
References GL2PS_POINT_SIZE_TOKEN, GL2PS_SUCCESS, and GL2PS_UNINITIALIZED\&.
.PP
.nf
{
  if(!gl2ps) return GL2PS_UNINITIALIZED;

  glPassThrough(GL2PS_POINT_SIZE_TOKEN);
  glPassThrough(value);
  
  return GL2PS_SUCCESS;
}
.fi
.SS "static int \fBgl2psPrintf\fP (const char *fmt, \&.\&.\&.)\fC [static]\fP"
.PP
Definition at line 446 of file gl2ps\&.c\&.
.PP
References args, GL2PScontext::compress, GL2PS_COMPRESS, GL2PScontext::options, ret, and GL2PScontext::stream\&.
.PP
Referenced by gl2psEndPostScriptLine(), gl2psEndSVGLine(), gl2psOpenPDFDataStreamWritePreface(), gl2psPDFgroupListWriteMainStream(), gl2psPrintPDFBeginViewport(), gl2psPrintPDFEndViewport(), gl2psPrintPDFFillColor(), gl2psPrintPDFLineWidth(), gl2psPrintPDFStrokeColor(), gl2psPrintPostScriptBeginViewport(), gl2psPrintPostScriptColor(), gl2psPrintPostScriptDash(), gl2psPrintPostScriptEndViewport(), gl2psPrintPostScriptFooter(), gl2psPrintPostScriptHeader(), gl2psPrintPostScriptImagemap(), gl2psPrintPostScriptPixmap(), gl2psPrintPostScriptPrimitive(), gl2psPrintSVGBeginViewport(), gl2psPrintSVGDash(), gl2psPrintSVGEndViewport(), gl2psPrintSVGFooter(), gl2psPrintSVGHeader(), gl2psPrintSVGPixmap(), gl2psPrintSVGPrimitive(), gl2psPrintSVGSmoothTriangle(), gl2psPutPDFImage(), gl2psPutPDFText(), and gl2psWriteByte()\&.
.PP
.nf
{
  int ret;
  va_list args;

#if defined(GL2PS_HAVE_ZLIB)
  unsigned int oldsize = 0;
  static char buf[1000];
  if(gl2ps->options & GL2PS_COMPRESS){
    va_start(args, fmt);
    ret = vsprintf(buf, fmt, args);
    va_end(args);
    oldsize = gl2ps->compress->srcLen;
    gl2ps->compress->start = (Bytef*)gl2psReallocCompress(oldsize + ret);
    memcpy(gl2ps->compress->start+oldsize, buf, ret);
    ret = 0;
  }
  else{
#endif
    va_start(args, fmt);
    ret = vfprintf(gl2ps->stream, fmt, args);
    va_end(args);
#if defined(GL2PS_HAVE_ZLIB)
  }
#endif
  return ret;
}
.fi
.SS "static void \fBgl2psPrintGzipFooter\fP ()\fC [static]\fP"
.PP
Definition at line 492 of file gl2ps\&.c\&.
.PP
References GL2PScontext::compress, GL2PS_COMPRESS, GL2PS_ERROR, gl2psFree(), gl2psMsg(), n, GL2PScontext::options, GL2PScontext::stream, and tmp\&.
.PP
Referenced by gl2psPrintPostScriptFooter(), and gl2psPrintSVGFooter()\&.
.PP
.nf
{
#if defined(GL2PS_HAVE_ZLIB)
  int n;
  uLong crc, len;
  char tmp[8];

  if(gl2ps->options & GL2PS_COMPRESS){
    if(Z_OK != gl2psDeflate()){
      gl2psMsg(GL2PS_ERROR, 'Zlib deflate error');
    }
    else{
      /* determine the length of the header in the zlib stream */
      n = 2; /* CMF+FLG */
      if(gl2ps->compress->dest[1] & (1<<5)){
        n += 4; /* DICTID */
      }
      /* write the data, without the zlib header and footer */
      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4), 
             1, gl2ps->stream);
      /* add the gzip file footer */
      crc = crc32(0L, gl2ps->compress->start, gl2ps->compress->srcLen);
      for(n = 0; n < 4; ++n){
        tmp[n] = (char)(crc & 0xff);
        crc >>= 8;
      }
      len = gl2ps->compress->srcLen;
      for(n = 4; n < 8; ++n){
        tmp[n] = (char)(len & 0xff);
        len >>= 8;
      }
      fwrite(tmp, 8, 1, gl2ps->stream);
    }
    gl2psFreeCompress();
    gl2psFree(gl2ps->compress);
    gl2ps->compress = NULL;
  }
#endif 
}
.fi
.SS "static void \fBgl2psPrintGzipHeader\fP ()\fC [static]\fP"
.PP
Definition at line 474 of file gl2ps\&.c\&.
.PP
References GL2PS_COMPRESS, GL2PScontext::options, GL2PScontext::stream, and tmp\&.
.PP
Referenced by gl2psPrintPostScriptHeader(), and gl2psPrintSVGHeader()\&.
.PP
.nf
{
#if defined(GL2PS_HAVE_ZLIB)
  char tmp[10] = {'\x1f', '\x8b', /* magic numbers: 0x1f, 0x8b */
                  8, /* compression method: Z_DEFLATED */
                  0, /* flags */
                  0, 0, 0, 0, /* time */
                  2, /* extra flags: max compression */
                  '\x03'}; /* OS code: 0x03 (Unix) */

  if(gl2ps->options & GL2PS_COMPRESS){
    gl2psSetupCompress();
    /* add the gzip file header */
    fwrite(tmp, 10, 1, gl2ps->stream);
  }
#endif  
}
.fi
.SS "static void \fBgl2psPrintPDFBeginViewport\fP (GLintviewport[4])\fC [static]\fP"
.PP
Definition at line 4876 of file gl2ps\&.c\&.
.PP
References GL2PScontext::colormap, GL2PScontext::colormode, GL2PScontext::colorsize, GL2PS_DRAW_BACKGROUND, gl2psPrintf(), gl2psPrintPDFFillColor(), gl2psPrintPDFHeader(), h, GL2PScontext::header, GL2PScontext::options, GL2PScontext::streamlength, w, x, and y\&.
.PP
.nf
{
  int offs = 0;
  GLint index;
  GLfloat rgba[4];
  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
  
  glRenderMode(GL_FEEDBACK);
  
  if(gl2ps->header){
    gl2psPrintPDFHeader();
    gl2ps->header = GL_FALSE;
  }

  offs += gl2psPrintf('q\n');
  
  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
    }
    else{
      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
      rgba[0] = gl2ps->colormap[index][0];
      rgba[1] = gl2ps->colormap[index][1];
      rgba[2] = gl2ps->colormap[index][2];
      rgba[3] = 1\&.0F;
    }
    offs += gl2psPrintPDFFillColor(rgba);
    offs += gl2psPrintf('%d %d %d %d re\n'
                        'W\n'
                        'f\n',
                        x, y, w, h);
  }
  else{
    offs += gl2psPrintf('%d %d %d %d re\n'
                        'W\n'   
                        'n\n',
                        x, y, w, h);            
  }
  
  gl2ps->streamlength += offs;
}
.fi
.SS "static int \fBgl2psPrintPDFCatalog\fP (void)\fC [static]\fP"
.PP
Definition at line 4076 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPDFHeader()\&.
.PP
.nf
{
  return fprintf(gl2ps->stream, 
                 '2 0 obj\n'
                 '<<\n'
                 '/Type /Catalog\n'
                 '/Pages 3 0 R\n'
                 '>>\n'
                 'endobj\n');
}
.fi
.SS "static int \fBgl2psPrintPDFCompressorType\fP (void)\fC [static]\fP"
.PP
Definition at line 3481 of file gl2ps\&.c\&.
.PP
References GL2PS_COMPRESS, GL2PScontext::options, and GL2PScontext::stream\&.
.PP
Referenced by gl2psOpenPDFDataStream(), gl2psPrintPDFPixmap(), and gl2psPrintPDFShader()\&.
.PP
.nf
{
#if defined(GL2PS_HAVE_ZLIB)
  if(gl2ps->options & GL2PS_COMPRESS){
    return fprintf(gl2ps->stream, '/Filter [/FlateDecode]\n');
  }
#endif
  return 0;
}
.fi
.SS "static int \fBgl2psPrintPDFDataStreamLength\fP (intval)\fC [static]\fP"
.PP
Definition at line 4207 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  return fprintf(gl2ps->stream,
                 '5 0 obj\n'
                 '%d\n'
                 'endobj\n', val);
}
.fi
.SS "static GLint \fBgl2psPrintPDFEndViewport\fP (void)\fC [static]\fP"
.PP
Definition at line 4919 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), gl2psPrintPrimitives(), and GL2PScontext::streamlength\&.
.PP
.nf
{
  GLint res;
  
  res = gl2psPrintPrimitives();
  gl2ps->streamlength += gl2psPrintf('Q\n');
  return res;
}
.fi
.SS "static int \fBgl2psPrintPDFFillColor\fP (\fBGL2PSrgba\fPrgba)\fC [static]\fP"
.PP
Definition at line 3508 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO, gl2psPrintf(), and i\&.
.PP
Referenced by gl2psOpenPDFDataStreamWritePreface(), gl2psPDFgroupListWriteMainStream(), and gl2psPrintPDFBeginViewport()\&.
.PP
.nf
{
  int i, offs = 0;
  
  for(i = 0; i < 3; ++i){
    if(GL2PS_ZERO(rgba[i]))
      offs += gl2psPrintf('%\&.0f ', 0\&.);
    else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
      offs += gl2psPrintf('%f ', rgba[i]);
    else
      offs += gl2psPrintf('%g ', rgba[i]);
  }
  offs += gl2psPrintf('rg\n');
  return offs;
}
.fi
.SS "static void \fBgl2psPrintPDFFinalPrimitive\fP (void)\fC [static]\fP"
.PP
Definition at line 4928 of file gl2ps\&.c\&.
.PP
.nf
{
}
.fi
.SS "static void \fBgl2psPrintPDFFooter\fP (void)\fC [static]\fP"
.PP
Definition at line 4812 of file gl2ps\&.c\&.
.PP
References GL2PScontext::compress, GL2PS_COMPRESS, gl2psClosePDFDataStream(), gl2psFree(), gl2psListDelete(), gl2psPDFgroupListDelete(), gl2psPDFgroupListInit(), gl2psPDFgroupListWriteMainStream(), gl2psPDFgroupListWriteObjects(), gl2psPDFgroupListWriteVariableResources(), gl2psPrintPDFDataStreamLength(), gl2psPrintPDFGSObject(), gl2psPrintPDFOpenPage(), gl2psRealloc(), i, GL2PScontext::objects_stack, GL2PScontext::options, GL2PScontext::pdfprimlist, GL2PScontext::stream, GL2PScontext::streamlength, and GL2PScontext::xreflist\&.
.PP
.nf
{
  int i, offs;  

  gl2psPDFgroupListInit();
  gl2psPDFgroupListWriteMainStream();
 
  offs = gl2ps->xreflist[5] + gl2ps->streamlength; 
  offs += gl2psClosePDFDataStream();
  gl2ps->xreflist[5] = offs;
  
  offs += gl2psPrintPDFDataStreamLength(gl2ps->streamlength);
  gl2ps->xreflist[6] = offs;
  gl2ps->streamlength = 0;
  
  offs += gl2psPrintPDFOpenPage();
  offs += gl2psPDFgroupListWriteVariableResources();
  gl2ps->xreflist = (int*)gl2psRealloc(gl2ps->xreflist,
                                       sizeof(int) * (gl2ps->objects_stack + 1));
  gl2ps->xreflist[7] = offs;
  
  offs += gl2psPrintPDFGSObject();
  gl2ps->xreflist[8] = offs;
  
  gl2ps->xreflist[gl2ps->objects_stack] = 
    gl2psPDFgroupListWriteObjects(gl2ps->xreflist[8]);

  /* Start cross reference table\&. The file has to been opened in
     binary mode to preserve the 20 digit string length! */
  fprintf(gl2ps->stream,
          'xref\n'
          '0 %d\n'
          '%010d 65535 f \n', gl2ps->objects_stack, 0);
  
  for(i = 1; i < gl2ps->objects_stack; ++i)
    fprintf(gl2ps->stream, '%010d 00000 n \n', gl2ps->xreflist[i]);
  
  fprintf(gl2ps->stream,
          'trailer\n'
          '<<\n' 
          '/Size %d\n'
          '/Info 1 0 R\n'
          '/Root 2 0 R\n'
          '>>\n'
          'startxref\n%d\n'
          '%%%%EOF\n',
          gl2ps->objects_stack, gl2ps->xreflist[gl2ps->objects_stack]);
  
  /* Free auxiliary lists and arrays */    
  gl2psFree(gl2ps->xreflist);
  gl2psListDelete(gl2ps->pdfprimlist);
  gl2psPDFgroupListDelete();
  
#if defined(GL2PS_HAVE_ZLIB)
  if(gl2ps->options & GL2PS_COMPRESS){
    gl2psFreeCompress();
    gl2psFree(gl2ps->compress);
    gl2ps->compress = NULL;
  }
#endif
}
.fi
.SS "static int \fBgl2psPrintPDFGSObject\fP (void)\fC [static]\fP"
.PP
Definition at line 4272 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  return fprintf(gl2ps->stream,
                 '7 0 obj\n'
                 '<<\n'
                 '/Type /ExtGState\n'
                 '/SA false\n'
                 '/SM 0\&.02\n'
                 '/OP false\n'
                 '/op false\n'
                 '/OPM 0\n'
                 '/BG2 /Default\n'
                 '/UCR2 /Default\n'
                 '/TR2 /Default\n'
                 '>>\n'
                 'endobj\n');
}
.fi
.SS "static void \fBgl2psPrintPDFHeader\fP (void)\fC [static]\fP"
.PP
Definition at line 4136 of file gl2ps\&.c\&.
.PP
References GL2PS_COMPRESS, gl2psListCreate(), gl2psMalloc(), gl2psOpenPDFDataStream(), gl2psOpenPDFDataStreamWritePreface(), gl2psPDFstacksInit(), gl2psPrintPDFCatalog(), gl2psPrintPDFInfo(), gl2psPrintPDFPages(), GL2PScontext::objects_stack, GL2PScontext::options, GL2PScontext::pdfprimlist, GL2PScontext::stream, GL2PScontext::streamlength, and GL2PScontext::xreflist\&.
.PP
Referenced by gl2psPrintPDFBeginViewport()\&.
.PP
.nf
{
  int offs = 0;
  gl2ps->pdfprimlist = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
  gl2psPDFstacksInit();

  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack); 

#if defined(GL2PS_HAVE_ZLIB)
  if(gl2ps->options & GL2PS_COMPRESS){
    gl2psSetupCompress();
  }
#endif    
  gl2ps->xreflist[0] = 0;
  offs += fprintf(gl2ps->stream, '%%PDF-1\&.4\n');
  gl2ps->xreflist[1] = offs;
  
  offs += gl2psPrintPDFInfo();
  gl2ps->xreflist[2] = offs;
  
  offs += gl2psPrintPDFCatalog();
  gl2ps->xreflist[3] = offs;
  
  offs += gl2psPrintPDFPages();
  gl2ps->xreflist[4] = offs;
  
  offs += gl2psOpenPDFDataStream();
  gl2ps->xreflist[5] = offs; /* finished in gl2psPrintPDFFooter */
  gl2ps->streamlength = gl2psOpenPDFDataStreamWritePreface();
}
.fi
.SS "static int \fBgl2psPrintPDFInfo\fP (void)\fC [static]\fP"
.PP
Definition at line 4035 of file gl2ps\&.c\&.
.PP
References GL2PS_COPYRIGHT, GL2PS_EXTRA_VERSION, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION, GL2PScontext::producer, GL2PScontext::stream, and GL2PScontext::title\&.
.PP
Referenced by gl2psPrintPDFHeader()\&.
.PP
.nf
{
  int offs;
  time_t now;
  struct tm *newtime;
  
  time(&now);
  newtime = gmtime(&now);
  
  offs = fprintf(gl2ps->stream,
                 '1 0 obj\n'
                 '<<\n'
                 '/Title (%s)\n'
                 '/Creator (GL2PS %d\&.%d\&.%d%s, %s)\n'
                 '/Producer (%s)\n',
                 gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
                 GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
                 gl2ps->producer);
  
  if(!newtime){
    offs += fprintf(gl2ps->stream, 
                    '>>\n'
                    'endobj\n');
    return offs;
  }
  
  offs += fprintf(gl2ps->stream, 
                  '/CreationDate (D:%d%02d%02d%02d%02d%02d)\n'
                  '>>\n'
                  'endobj\n',
                  newtime->tm_year+1900, 
                  newtime->tm_mon+1, 
                  newtime->tm_mday,
                  newtime->tm_hour,
                  newtime->tm_min,
                  newtime->tm_sec);
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFLineWidth\fP (GLfloatlw)\fC [static]\fP"
.PP
Definition at line 3524 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO, and gl2psPrintf()\&.
.PP
Referenced by gl2psPDFgroupListWriteMainStream()\&.
.PP
.nf
{
  if(GL2PS_ZERO(lw))
    return gl2psPrintf('%\&.0f w\n', 0\&.);
  else if(lw < 1e-4 || lw > 1e6) /* avoid %e formatting */
    return gl2psPrintf('%f w\n', lw);
  else
    return gl2psPrintf('%g w\n', lw);
}
.fi
.SS "static int \fBgl2psPrintPDFOpenPage\fP (void)\fC [static]\fP"
.PP
Definition at line 4217 of file gl2ps\&.c\&.
.PP
References GL2PS_LANDSCAPE, GL2PScontext::options, GL2PScontext::stream, and GL2PScontext::viewport\&.
.PP
Referenced by gl2psPrintPDFFooter()\&.
.PP
.nf
{
  int offs;
  
  /* Write fixed part */
  
  offs = fprintf(gl2ps->stream, 
                 '6 0 obj\n'
                 '<<\n' 
                 '/Type /Page\n'
                 '/Parent 3 0 R\n'
                 '/MediaBox [%d %d %d %d]\n',
                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                 (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
  
  if(gl2ps->options & GL2PS_LANDSCAPE)
    offs += fprintf(gl2ps->stream, '/Rotate -90\n');
  
  offs += fprintf(gl2ps->stream,
                  '/Contents 4 0 R\n'
                  '/Resources\n' 
                  '<<\n' 
                  '/ProcSet [/PDF /Text /ImageB /ImageC]  %%/ImageI\n');
  
  return offs;

  /* End fixed part, proceeds in gl2psPDFgroupListWriteVariableResources() */
}
.fi
.SS "static int \fBgl2psPrintPDFPages\fP (void)\fC [static]\fP"
.PP
Definition at line 4087 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPDFHeader()\&.
.PP
.nf
{
  return fprintf(gl2ps->stream, 
                 '3 0 obj\n'
                 '<<\n' 
                 '/Type /Pages\n'
                 '/Kids [6 0 R]\n'
                 '/Count 1\n'
                 '>>\n'
                 'endobj\n');
}
.fi
.SS "static int \fBgl2psPrintPDFPixmap\fP (intobj, intchildobj, \fBGL2PSimage\fP *im, intgray)\fC [static]\fP"
.PP
Definition at line 4649 of file gl2ps\&.c\&.
.PP
References GL2PScontext::compress, GL2PSimage::format, GL2PS_COMPRESS, gl2psPrintPDFCompressorType(), gl2psPrintPDFPixmapStreamData(), gl2psWriteBigEndian(), GL2PSimage::height, GL2PScontext::options, GL2PScontext::stream, and GL2PSimage::width\&.
.PP
Referenced by gl2psPDFgroupListWriteObjects()\&.
.PP
.nf
{
  int offs = 0, done = 0, sigbytes = 3;

  if(gray && gray !=8 && gray != 16)
    gray = 8;
  
  if(gray)
    sigbytes = gray / 8; 
  
  offs += fprintf(gl2ps->stream,
                  '%d 0 obj\n'
                  '<<\n'
                  '/Type /XObject\n'
                  '/Subtype /Image\n'
                  '/Width %d\n'
                  '/Height %d\n'
                  '/ColorSpace %s \n'
                  '/BitsPerComponent 8\n',
                  obj,
                  (int)im->width, (int)im->height,
                  (gray) ? '/DeviceGray' : '/DeviceRGB' );
  if(GL_RGBA == im->format && gray == 0){
    offs += fprintf(gl2ps->stream,
                    '/SMask %d 0 R\n',
                    childobj);
  }
  
#if defined(GL2PS_HAVE_ZLIB)
  if(gl2ps->options & GL2PS_COMPRESS){
    gl2psAllocCompress((int)(im->width * im->height * sigbytes));
    
    gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndianCompress, gray);
    
    if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
      offs += gl2psPrintPDFCompressorType();
      offs += fprintf(gl2ps->stream,
                      '/Length %d '
                      '>>\n'
                      'stream\n',
                      (int)gl2ps->compress->destLen);
      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, gl2ps->compress->destLen,
                                                1, gl2ps->stream);
      done = 1;
    }
    gl2psFreeCompress();
  }
#endif
  
  if(!done){
    /* no compression, or too long after compression, or compress error
       -> write non-compressed entry */
    offs += fprintf(gl2ps->stream,
                    '/Length %d '
                    '>>\n'
                    'stream\n',
                    (int)(im->width * im->height * sigbytes));
    offs += gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndian, gray);
  }
  
  offs += fprintf(gl2ps->stream,
                  '\nendstream\n'
                  'endobj\n');
  
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFPixmapStreamData\fP (\fBGL2PSimage\fP *im, size_t(*)(unsigned long data, size_t size)action, intgray)\fC [static]\fP"
.PP
Definition at line 4611 of file gl2ps\&.c\&.
.PP
References a, GL2PSimage::format, gl2psGetRGB(), GL2PSimage::height, GL2PSimage::width, x, and y\&.
.PP
Referenced by gl2psPrintPDFPixmap()\&.
.PP
.nf
{
  int x, y;
  GLfloat r, g, b, a;

  if(im->format != GL_RGBA && gray)
    return 0;

  if(gray && gray !=8 && gray != 16)
    gray = 8;

  gray /= 8;
  
  for(y = 0; y < im->height; ++y){
    for(x = 0; x < im->width; ++x){
      a = gl2psGetRGB(im, x, y, &r, &g, &b);
      if(im->format == GL_RGBA && gray){
        (*action)((unsigned long)(a*255) << 24, gray);
      }
      else{
        (*action)((unsigned long)(r*255) << 24, 1);
        (*action)((unsigned long)(g*255) << 24, 1);
        (*action)((unsigned long)(b*255) << 24, 1);
      }
    }
  }

  switch(gray){
  case 0: return 3 * im->width * im->height;
  case 1: return im->width * im->height;
  case 2: return 2 * im->width * im->height;
  default: return 3 * im->width * im->height;
  }
}
.fi
.SS "static void \fBgl2psPrintPDFPrimitive\fP (void *data)\fC [static]\fP"
.PP
Definition at line 4169 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::culled, GL2PS_OCCLUSION_CULL, gl2psCopyPrimitive(), gl2psListAdd(), GL2PScontext::options, and GL2PScontext::pdfprimlist\&.
.PP
.nf
{
  GL2PSprimitive *prim = *(GL2PSprimitive**)data;

  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) 
    return;

  prim = gl2psCopyPrimitive(prim); /* deep copy */
  gl2psListAdd(gl2ps->pdfprimlist, &prim);
}
.fi
.SS "static int \fBgl2psPrintPDFShader\fP (intobj, \fBGL2PStriangle\fP *triangles, intsize, intgray)\fC [static]\fP"
.PP
Definition at line 4448 of file gl2ps\&.c\&.
.PP
References GL2PScontext::compress, GL2PS_COMPRESS, gl2psPDFRectHull(), gl2psPrintPDFCompressorType(), gl2psPrintPDFShaderStreamData(), gl2psWriteBigEndian(), i, GL2PScontext::options, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPDFgroupListWriteObjects()\&.
.PP
.nf
{
  int i, offs = 0, vertexbytes, done = 0;
  GLfloat xmin, xmax, ymin, ymax;
        
  switch(gray){
  case 0:
    vertexbytes = 1+4+4+1+1+1;
    break;
  case 8:
    vertexbytes = 1+4+4+1;
    break;
  case 16:
    vertexbytes = 1+4+4+2;
    break;
  default:
    gray = 8;
    vertexbytes = 1+4+4+1;
    break;
  }
  
  gl2psPDFRectHull(&xmin, &xmax, &ymin, &ymax, triangles, size);
  
  offs += fprintf(gl2ps->stream,
                  '%d 0 obj\n'
                  '<< '
                  '/ShadingType 4 '
                  '/ColorSpace %s '
                  '/BitsPerCoordinate 32 '
                  '/BitsPerComponent %d '
                  '/BitsPerFlag 8 '
                  '/Decode [%f %f %f %f 0 1 %s] ',
                  obj,
                  (gray) ? '/DeviceGray' : '/DeviceRGB', 
                  (gray) ? gray : 8,
                  xmin, xmax, ymin, ymax,
                  (gray) ? '' : '0 1 0 1');
  
#if defined(GL2PS_HAVE_ZLIB)
  if(gl2ps->options & GL2PS_COMPRESS){
    gl2psAllocCompress(vertexbytes * size * 3);

    for(i = 0; i < size; ++i)
      gl2psPrintPDFShaderStreamData(&triangles[i],
                                    xmax-xmin, ymax-ymin, xmin, ymin, 
                                    gl2psWriteBigEndianCompress, gray);

    if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
      offs += gl2psPrintPDFCompressorType();
      offs += fprintf(gl2ps->stream,
                      '/Length %d '
                      '>>\n'
                      'stream\n',
                      (int)gl2ps->compress->destLen);
      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, 
                                                gl2ps->compress->destLen, 
                                                1, gl2ps->stream);
      done = 1;
    }
    gl2psFreeCompress();
  }
#endif

  if(!done){
    /* no compression, or too long after compression, or compress error
       -> write non-compressed entry */
    offs += fprintf(gl2ps->stream,
                    '/Length %d '
                    '>>\n'
                    'stream\n',
                    vertexbytes * 3 * size);
    for(i = 0; i < size; ++i)
      offs += gl2psPrintPDFShaderStreamData(&triangles[i],
                                            xmax-xmin, ymax-ymin, xmin, ymin,
                                            gl2psWriteBigEndian, gray);
  }
  
  offs += fprintf(gl2ps->stream,
                  '\nendstream\n'
                  'endobj\n');
  
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFShaderExtGS\fP (intobj, intchildobj)\fC [static]\fP"
.PP
Definition at line 4574 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream\&.
.PP
Referenced by gl2psPDFgroupListWriteObjects()\&.
.PP
.nf
{
  int offs = 0;
  
  offs += fprintf(gl2ps->stream,
                  '%d 0 obj\n'
                  '<<\n',
                  obj);
  
  offs += fprintf(gl2ps->stream,
                  '/SMask << /S /Alpha /G %d 0 R >> ',
                  childobj);
  
  offs += fprintf(gl2ps->stream,
                  '>>\n'
                  'endobj\n');
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFShaderMask\fP (intobj, intchildobj)\fC [static]\fP"
.PP
Definition at line 4535 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream, and GL2PScontext::viewport\&.
.PP
Referenced by gl2psPDFgroupListWriteObjects()\&.
.PP
.nf
{
  int offs = 0, len;
  
  offs += fprintf(gl2ps->stream,
                  '%d 0 obj\n'
                  '<<\n'
                  '/Type /XObject\n'
                  '/Subtype /Form\n'
                  '/BBox [ %d %d %d %d ]\n'
                  '/Group \n<<\n/S /Transparency /CS /DeviceRGB\n'
                  '>>\n',
                  obj,
                  (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                  (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
  
  len = (childobj>0) 
    ? strlen('/TrSh sh\n') + (int)log10((double)childobj)+1
    : strlen('/TrSh0 sh\n'); 
  
  offs += fprintf(gl2ps->stream,
                  '/Length %d\n'
                  '>>\n'
                  'stream\n',
                  len);
  offs += fprintf(gl2ps->stream,
                  '/TrSh%d sh\n',
                  childobj);
  offs += fprintf(gl2ps->stream,
                  'endstream\n'
                  'endobj\n');
  
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFShaderSimpleExtGS\fP (intobj, GLfloatalpha)\fC [static]\fP"
.PP
Definition at line 4595 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream\&.
.PP
Referenced by gl2psPDFgroupListWriteObjects()\&.
.PP
.nf
{
  int offs = 0;
  
  offs += fprintf(gl2ps->stream,
                  '%d 0 obj\n'
                  '<<\n'
                  '/ca %g'
                  '>>\n'
                  'endobj\n',
                  obj, alpha);
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFShaderStreamData\fP (\fBGL2PStriangle\fP *triangle, GLfloatdx, GLfloatdy, GLfloatxmin, GLfloatymin, size_t(*)(unsigned long data, size_t size)action, intgray)\fC [static]\fP"
.PP
Definition at line 4390 of file gl2ps\&.c\&.
.PP
References gl2psPrintPDFShaderStreamDataAlpha(), gl2psPrintPDFShaderStreamDataCoord(), gl2psPrintPDFShaderStreamDataRGB(), i, and GL2PStriangle::vertex\&.
.PP
Referenced by gl2psPrintPDFShader()\&.
.PP
.nf
{
  int i, offs = 0;
  GL2PSvertex v;
  
  if(gray && gray != 8 && gray != 16)
    gray = 8;
  
  for(i = 0; i < 3; ++i){
    offs += gl2psPrintPDFShaderStreamDataCoord(&triangle->vertex[i], action,
                                               dx, dy, xmin, ymin);
    if(gray){ 
      v = triangle->vertex[i];
      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray); 
    }
    else{
      offs += gl2psPrintPDFShaderStreamDataRGB(&triangle->vertex[i], action);
    }
  }
  
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFShaderStreamDataAlpha\fP (\fBGL2PSvertex\fP *vertex, size_t(*)(unsigned long data, size_t size)action, intsigbyte)\fC [static]\fP"
.PP
Definition at line 4364 of file gl2ps\&.c\&.
.PP
References GL2PSvertex::rgba\&.
.PP
Referenced by gl2psPrintPDFShaderStreamData()\&.
.PP
.nf
{
  int offs = 0;
  unsigned long imap;
  double dmax = ~1UL;

  /* FIXME: temp bux fix for 64 bit archs: */
  if(sizeof(unsigned long) == 8) dmax = dmax - 2048\&.;

  if(sigbyte != 8 && sigbyte != 16)
    sigbyte = 8;
        
  sigbyte /= 8;
  
  imap = (unsigned long)((vertex->rgba[3]) * dmax);
  
  offs += (*action)(imap, sigbyte);
  
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFShaderStreamDataCoord\fP (\fBGL2PSvertex\fP *vertex, size_t(*)(unsigned long data, size_t size)action, GLfloatdx, GLfloatdy, GLfloatxmin, GLfloatymin)\fC [static]\fP"
.PP
Definition at line 4292 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPDFShaderStreamData()\&.
.PP
.nf
{
  int offs = 0;
  unsigned long imap;
  GLfloat diff;
  double dmax = ~1UL;
  char edgeflag = 0;

  /* FIXME: temp bux fix for 64 bit archs: */
  if(sizeof(unsigned long) == 8) dmax = dmax - 2048\&.;

  offs += (*action)(edgeflag, 1);

  /* The Shader stream in PDF requires to be in a 'big-endian'
     order */
    
  if(GL2PS_ZERO(dx*dy)){
    offs += (*action)(0, 4);
    offs += (*action)(0, 4);
  }
  else{
    diff = (vertex->xyz[0] - xmin) / dx;
    if(diff > 1)
      diff = 1\&.0F;
    else if(diff < 0)
      diff = 0\&.0F;
    imap = (unsigned long)(diff * dmax);
    offs += (*action)(imap, 4);
      
    diff = (vertex->xyz[1] - ymin) / dy;
    if(diff > 1)
      diff = 1\&.0F;
    else if(diff < 0)
      diff = 0\&.0F;
    imap = (unsigned long)(diff * dmax);
    offs += (*action)(imap, 4);
  }
  
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFShaderStreamDataRGB\fP (\fBGL2PSvertex\fP *vertex, size_t(*)(unsigned long data, size_t size)action)\fC [static]\fP"
.PP
Definition at line 4339 of file gl2ps\&.c\&.
.PP
References GL2PSvertex::rgba\&.
.PP
Referenced by gl2psPrintPDFShaderStreamData()\&.
.PP
.nf
{
  int offs = 0;
  unsigned long imap;
  double dmax = ~1UL;

  /* FIXME: temp bux fix for 64 bit archs: */
  if(sizeof(unsigned long) == 8) dmax = dmax - 2048\&.;

  imap = (unsigned long)((vertex->rgba[0]) * dmax);
  offs += (*action)(imap, 1);
    
  imap = (unsigned long)((vertex->rgba[1]) * dmax);
  offs += (*action)(imap, 1);
    
  imap = (unsigned long)((vertex->rgba[2]) * dmax);
  offs += (*action)(imap, 1);
  
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFStrokeColor\fP (\fBGL2PSrgba\fPrgba)\fC [static]\fP"
.PP
Definition at line 3491 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO, gl2psPrintf(), gl2psSetLastColor(), and i\&.
.PP
Referenced by gl2psPDFgroupListWriteMainStream()\&.
.PP
.nf
{
  int i, offs = 0;

  gl2psSetLastColor(rgba);
  for(i = 0; i < 3; ++i){
    if(GL2PS_ZERO(rgba[i]))
      offs += gl2psPrintf('%\&.0f ', 0\&.);
    else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
      offs += gl2psPrintf('%f ', rgba[i]);
    else
      offs += gl2psPrintf('%g ', rgba[i]);
  }
  offs += gl2psPrintf('RG\n');
  return offs;
}
.fi
.SS "static int \fBgl2psPrintPDFText\fP (intobj, \fBGL2PSstring\fP *s, intfontnumber)\fC [static]\fP"
.PP
Definition at line 4716 of file gl2ps\&.c\&.
.PP
References GL2PSstring::fontname, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPDFgroupListWriteObjects()\&.
.PP
.nf
{
  int offs = 0;
  
  offs += fprintf(gl2ps->stream,
                  '%d 0 obj\n'
                  '<<\n'
                  '/Type /Font\n'
                  '/Subtype /Type1\n'
                  '/Name /F%d\n'
                  '/BaseFont /%s\n'
                  '/Encoding /MacRomanEncoding\n'
                  '>>\n'
                  'endobj\n',
                  obj, fontnumber, s->fontname);
  return offs;
}
.fi
.SS "static void \fBgl2psPrintPGFBeginViewport\fP (GLintviewport[4])\fC [static]\fP"
.PP
Definition at line 5482 of file gl2ps\&.c\&.
.PP
References GL2PScontext::colormap, GL2PScontext::colormode, GL2PScontext::colorsize, GL2PS_DRAW_BACKGROUND, gl2psPrintPGFColor(), gl2psPrintPGFHeader(), h, GL2PScontext::header, GL2PScontext::options, GL2PScontext::stream, w, x, and y\&.
.PP
.nf
{
  GLint index;
  GLfloat rgba[4];
  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];

  glRenderMode(GL_FEEDBACK);

  if(gl2ps->header){
    gl2psPrintPGFHeader();
    gl2ps->header = GL_FALSE;
  }

  fprintf(gl2ps->stream, '\\begin{pgfscope}\n');
  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
    }
    else{
      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
      rgba[0] = gl2ps->colormap[index][0];
      rgba[1] = gl2ps->colormap[index][1];
      rgba[2] = gl2ps->colormap[index][2];
      rgba[3] = 1\&.0F;
    }
    gl2psPrintPGFColor(rgba);
    fprintf(gl2ps->stream, 
            '\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}'
            '{\\pgfpoint{%dpt}{%dpt}}\n'
            '\\pgfusepath{fill}\n',
            x, y, w, h);
  }
  
  fprintf(gl2ps->stream, 
          '\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}'
          '{\\pgfpoint{%dpt}{%dpt}}\n'
          '\\pgfusepath{clip}\n',
          x, y, w, h);
}
.fi
.SS "static void \fBgl2psPrintPGFColor\fP (\fBGL2PSrgba\fPrgba)\fC [static]\fP"
.PP
Definition at line 5329 of file gl2ps\&.c\&.
.PP
References gl2psSameColor(), gl2psSetLastColor(), GL2PScontext::lastrgba, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPGFBeginViewport(), gl2psPrintPGFHeader(), and gl2psPrintPGFPrimitive()\&.
.PP
.nf
{
  if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
    gl2psSetLastColor(rgba);
    fprintf(gl2ps->stream, '\\color[rgb]{%f,%f,%f}\n', rgba[0], rgba[1], rgba[2]);
  }
}
.fi
.SS "static void \fBgl2psPrintPGFDash\fP (GLushortpattern, GLintfactor)\fC [static]\fP"
.PP
Definition at line 5364 of file gl2ps\&.c\&.
.PP
References gl2psParseStipplePattern(), i, GL2PScontext::lastfactor, GL2PScontext::lastpattern, n, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPGFPrimitive()\&.
.PP
.nf
{
  int i, n, array[10];

  if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
    return;

  gl2ps->lastpattern = pattern;
  gl2ps->lastfactor = factor;

  if(!pattern || !factor){
    /* solid line */
    fprintf(gl2ps->stream, '\\pgfsetdash{}{0pt}\n');
  }
  else{
    gl2psParseStipplePattern(pattern, factor, &n, array);
    fprintf(gl2ps->stream, '\\pgfsetdash{');
    for(i = 0; i < n; i++) fprintf(gl2ps->stream, '{%dpt}', array[i]);
    fprintf(gl2ps->stream, '}{0pt}\n');
  }
}
.fi
.SS "static GLint \fBgl2psPrintPGFEndViewport\fP (void)\fC [static]\fP"
.PP
Definition at line 5522 of file gl2ps\&.c\&.
.PP
References gl2psPrintPrimitives(), and GL2PScontext::stream\&.
.PP
.nf
{
  GLint res;
  res = gl2psPrintPrimitives();
  fprintf(gl2ps->stream, '\\end{pgfscope}\n');
  return res;
}
.fi
.SS "static void \fBgl2psPrintPGFFinalPrimitive\fP (void)\fC [static]\fP"
.PP
Definition at line 5530 of file gl2ps\&.c\&.
.PP
.nf
{
}
.fi
.SS "static void \fBgl2psPrintPGFFooter\fP (void)\fC [static]\fP"
.PP
Definition at line 5477 of file gl2ps\&.c\&.
.PP
References GL2PScontext::stream\&.
.PP
.nf
{
  fprintf(gl2ps->stream, '\\end{pgfpicture}\n');
}
.fi
.SS "static void \fBgl2psPrintPGFHeader\fP (void)\fC [static]\fP"
.PP
Definition at line 5337 of file gl2ps\&.c\&.
.PP
References GL2PScontext::bgcolor, GL2PS_COPYRIGHT, GL2PS_DRAW_BACKGROUND, GL2PS_EXTRA_VERSION, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION, gl2psPrintPGFColor(), GL2PScontext::options, GL2PScontext::producer, GL2PScontext::stream, GL2PScontext::title, and GL2PScontext::viewport\&.
.PP
Referenced by gl2psPrintPGFBeginViewport()\&.
.PP
.nf
{
  time_t now;

  time(&now);

  fprintf(gl2ps->stream, 
          '%% Title: %s\n'
          '%% Creator: GL2PS %d\&.%d\&.%d%s, %s\n'
          '%% For: %s\n'
          '%% CreationDate: %s',
          gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
          GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
          gl2ps->producer, ctime(&now));

  fprintf(gl2ps->stream, '\\begin{pgfpicture}\n');
  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    gl2psPrintPGFColor(gl2ps->bgcolor);
    fprintf(gl2ps->stream,
            '\\pgfpathrectanglecorners{'
            '\\pgfpoint{%dpt}{%dpt}}{\\pgfpoint{%dpt}{%dpt}}\n'
            '\\pgfusepath{fill}\n',
            (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
            (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
  }
}
.fi
.SS "static void \fBgl2psPrintPGFPrimitive\fP (void *data)\fC [static]\fP"
.PP
Definition at line 5402 of file gl2ps\&.c\&.
.PP
References GL2PSstring::alignment, GL2PSstring::angle, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PSstring::fontsize, GL2PS_LINE, GL2PS_PGF, GL2PS_POINT, GL2PS_SPECIAL, GL2PS_TEXT, GL2PS_TRIANGLE, gl2psPGFTextAlignment(), gl2psPrintPGFColor(), gl2psPrintPGFDash(), GL2PScontext::lastlinewidth, GL2PSprimitive::pattern, GL2PSvertex::rgba, GL2PSstring::str, GL2PScontext::stream, GL2PSprimitive::text, GL2PSprimitive::type, GL2PSprimitive::verts, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
.nf
{
  GL2PSprimitive *prim;

  prim = *(GL2PSprimitive**)data;

  switch(prim->type){
  case GL2PS_POINT :
    /* Points in openGL are rectangular */
    gl2psPrintPGFColor(prim->verts[0]\&.rgba);
    fprintf(gl2ps->stream, 
            '\\pgfpathrectangle{\\pgfpoint{%fpt}{%fpt}}'
            '{\\pgfpoint{%fpt}{%fpt}}\n\\pgfusepath{fill}\n',
            prim->verts[0]\&.xyz[0]-0\&.5*prim->width,
            prim->verts[0]\&.xyz[1]-0\&.5*prim->width,
            prim->width,prim->width);
    break;
  case GL2PS_LINE :
    gl2psPrintPGFColor(prim->verts[0]\&.rgba);
    if(gl2ps->lastlinewidth != prim->width){
      gl2ps->lastlinewidth = prim->width;
      fprintf(gl2ps->stream, '\\pgfsetlinewidth{%fpt}\n', gl2ps->lastlinewidth);
    }
    gl2psPrintPGFDash(prim->pattern, prim->factor);
    fprintf(gl2ps->stream, 
            '\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n'
            '\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n'
            '\\pgfusepath{stroke}\n',
            prim->verts[1]\&.xyz[0], prim->verts[1]\&.xyz[1],
            prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
    break;
  case GL2PS_TRIANGLE :
    if(gl2ps->lastlinewidth != 0){
      gl2ps->lastlinewidth = 0;
      fprintf(gl2ps->stream, '\\pgfsetlinewidth{0\&.01pt}\n');
    }
    gl2psPrintPGFColor(prim->verts[0]\&.rgba);
    fprintf(gl2ps->stream, 
            '\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n'
            '\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n'
            '\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n'
            '\\pgfpathclose\n'
            '\\pgfusepath{fill,stroke}\n',
            prim->verts[2]\&.xyz[0], prim->verts[2]\&.xyz[1],
            prim->verts[1]\&.xyz[0], prim->verts[1]\&.xyz[1],
            prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
    break;
  case GL2PS_TEXT :
    fprintf(gl2ps->stream, '{\n\\pgftransformshift{\\pgfpoint{%fpt}{%fpt}}\n',
            prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);

    if(prim->data\&.text->angle)
      fprintf(gl2ps->stream, '\\pgftransformrotate{%f}{', prim->data\&.text->angle);

    fprintf(gl2ps->stream, '\\pgfnode{rectangle}{%s}{\\fontsize{%d}{0}\\selectfont',
            gl2psPGFTextAlignment(prim->data\&.text->alignment),
            prim->data\&.text->fontsize);

    fprintf(gl2ps->stream, '\\textcolor[rgb]{%g,%g,%g}{{%s}}',
            prim->verts[0]\&.rgba[0], prim->verts[0]\&.rgba[1],
            prim->verts[0]\&.rgba[2], prim->data\&.text->str);

    fprintf(gl2ps->stream, '}{}{\\pgfusepath{discard}}}\n');
    break;
  case GL2PS_SPECIAL :
    /* alignment contains the format for which the special output text
       is intended */
    if (prim->data\&.text->alignment == GL2PS_PGF)
      fprintf(gl2ps->stream, '%s\n', prim->data\&.text->str);
    break;
  default :
    break;
  }
}
.fi
.SS "static void \fBgl2psPrintPostScriptBeginViewport\fP (GLintviewport[4])\fC [static]\fP"
.PP
Definition at line 3249 of file gl2ps\&.c\&.
.PP
References GL2PScontext::colormap, GL2PScontext::colormode, GL2PScontext::colorsize, GL2PS_DRAW_BACKGROUND, gl2psPrintf(), gl2psPrintPostScriptHeader(), h, GL2PScontext::header, GL2PScontext::options, w, x, and y\&.
.PP
.nf
{
  GLint index;
  GLfloat rgba[4];
  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];

  glRenderMode(GL_FEEDBACK);

  if(gl2ps->header){
    gl2psPrintPostScriptHeader();
    gl2ps->header = GL_FALSE;
  }

  gl2psPrintf('gsave\n'
              '1\&.0 1\&.0 scale\n');

  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
    }
    else{
      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
      rgba[0] = gl2ps->colormap[index][0];
      rgba[1] = gl2ps->colormap[index][1];
      rgba[2] = gl2ps->colormap[index][2];
      rgba[3] = 1\&.0F;
    }
    gl2psPrintf('%g %g %g C\n'
                'newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n'
                'closepath fill\n',
                rgba[0], rgba[1], rgba[2], 
                x, y, x+w, y, x+w, y+h, x, y+h);
  }
    
  gl2psPrintf('newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n'
              'closepath clip\n',
              x, y, x+w, y, x+w, y+h, x, y+h);
  
}
.fi
.SS "static void \fBgl2psPrintPostScriptColor\fP (\fBGL2PSrgba\fPrgba)\fC [static]\fP"
.PP
Definition at line 2980 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), gl2psSameColor(), gl2psSetLastColor(), and GL2PScontext::lastrgba\&.
.PP
Referenced by gl2psPrintPostScriptPrimitive()\&.
.PP
.nf
{
  if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
    gl2psSetLastColor(rgba);
    gl2psPrintf('%g %g %g C\n', rgba[0], rgba[1], rgba[2]);
  }
}
.fi
.SS "static int \fBgl2psPrintPostScriptDash\fP (GLushortpattern, GLintfactor, char *str)\fC [static]\fP"
.PP
Definition at line 3039 of file gl2ps\&.c\&.
.PP
References gl2psParseStipplePattern(), gl2psPrintf(), i, GL2PScontext::lastfactor, GL2PScontext::lastpattern, and n\&.
.PP
Referenced by gl2psPDFgroupListWriteMainStream(), and gl2psPrintPostScriptPrimitive()\&.
.PP
.nf
{
  int len = 0, i, n, array[10];

  if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
    return 0;
  
  gl2ps->lastpattern = pattern;
  gl2ps->lastfactor = factor;
  
  if(!pattern || !factor){
    /* solid line */
    len += gl2psPrintf('[] 0 %s\n', str);
  }
  else{
    gl2psParseStipplePattern(pattern, factor, &n, array);
    len += gl2psPrintf('[');
    for(i = 0; i < n; i++){
      if(i) len += gl2psPrintf(' ');
      len += gl2psPrintf('%d', array[i]);
    }
    len += gl2psPrintf('] 0 %s\n', str);
  }
  
  return len;
}
.fi
.SS "static GLint \fBgl2psPrintPostScriptEndViewport\fP (void)\fC [static]\fP"
.PP
Definition at line 3289 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), and gl2psPrintPrimitives()\&.
.PP
.nf
{
  GLint res;

  res = gl2psPrintPrimitives();
  gl2psPrintf('grestore\n');
  return res;
}
.fi
.SS "static void \fBgl2psPrintPostScriptFinalPrimitive\fP (void)\fC [static]\fP"
.PP
Definition at line 3298 of file gl2ps\&.c\&.
.PP
References gl2psEndPostScriptLine()\&.
.PP
.nf
{
  /* End any remaining line, if any */
  gl2psEndPostScriptLine();
}
.fi
.SS "static void \fBgl2psPrintPostScriptFooter\fP (void)\fC [static]\fP"
.PP
Definition at line 3236 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), and gl2psPrintGzipFooter()\&.
.PP
.nf
{
  gl2psPrintf('grestore\n'
              'showpage\n'
              'cleartomark\n'
              '%%%%PageTrailer\n'
              '%%%%Trailer\n'
              'end\n'
              '%%%%EOF\n');

  gl2psPrintGzipFooter();
}
.fi
.SS "static void \fBgl2psPrintPostScriptHeader\fP (void)\fC [static]\fP"
.PP
Definition at line 2694 of file gl2ps\&.c\&.
.PP
References GL2PScontext::bgcolor, GL2PScontext::format, GL2PS_COPYRIGHT, GL2PS_DRAW_BACKGROUND, GL2PS_EXTRA_VERSION, GL2PS_LANDSCAPE, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_NO_PS3_SHADING, GL2PS_PATCH_VERSION, GL2PS_PS, gl2psPrintf(), gl2psPrintGzipHeader(), GL2PScontext::options, GL2PScontext::producer, GL2PScontext::threshold, GL2PScontext::title, and GL2PScontext::viewport\&.
.PP
Referenced by gl2psPrintPostScriptBeginViewport()\&.
.PP
.nf
{
  time_t now;

  /* Since compression is not part of the PostScript standard,
     compressed PostScript files are just gzipped PostScript files
     ('ps\&.gz' or 'eps\&.gz') */
  gl2psPrintGzipHeader();

  time(&now);

  if(gl2ps->format == GL2PS_PS){
    gl2psPrintf('%%!PS-Adobe-3\&.0\n');
  }
  else{
    gl2psPrintf('%%!PS-Adobe-3\&.0 EPSF-3\&.0\n');
  }

  gl2psPrintf('%%%%Title: %s\n'
              '%%%%Creator: GL2PS %d\&.%d\&.%d%s, %s\n'
              '%%%%For: %s\n'
              '%%%%CreationDate: %s'
              '%%%%LanguageLevel: 3\n'
              '%%%%DocumentData: Clean7Bit\n'
              '%%%%Pages: 1\n',
              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, 
              GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
              gl2ps->producer, ctime(&now));

  if(gl2ps->format == GL2PS_PS){
    gl2psPrintf('%%%%Orientation: %s\n'
                '%%%%DocumentMedia: Default %d %d 0 () ()\n',
                (gl2ps->options & GL2PS_LANDSCAPE) ? 'Landscape' : 'Portrait',
                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
                (int)gl2ps->viewport[2], 
                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] : 
                (int)gl2ps->viewport[3]);
  }

  gl2psPrintf('%%%%BoundingBox: %d %d %d %d\n'
              '%%%%EndComments\n',
              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] : 
              (int)gl2ps->viewport[0],
              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[0] :
              (int)gl2ps->viewport[1],
              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] : 
              (int)gl2ps->viewport[2],
              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
              (int)gl2ps->viewport[3]);

  /* RGB color: r g b C (replace C by G in output to change from rgb to gray)
     Grayscale: r g b G
     Font choose: size fontname FC
     Text string: (string) x y size fontname S??
     Rotated text string: (string) angle x y size fontname S??R
     Point primitive: x y size P
     Line width: width W
     Line start: x y LS
     Line joining last point: x y L
     Line end: x y LE
     Flat-shaded triangle: x3 y3 x2 y2 x1 y1 T
     Smooth-shaded triangle: x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 ST */

  gl2psPrintf('%%%%BeginProlog\n'
              '/gl2psdict 64 dict def gl2psdict begin\n'
              '0 setlinecap 0 setlinejoin\n'
              '/tryPS3shading %s def %% set to false to force subdivision\n'
              '/rThreshold %g def %% red component subdivision threshold\n'
              '/gThreshold %g def %% green component subdivision threshold\n'
              '/bThreshold %g def %% blue component subdivision threshold\n',
              (gl2ps->options & GL2PS_NO_PS3_SHADING) ? 'false' : 'true',
              gl2ps->threshold[0], gl2ps->threshold[1], gl2ps->threshold[2]);

  gl2psPrintf('/BD { bind def } bind def\n'
              '/C  { setrgbcolor } BD\n'
              '/G  { 0\&.082 mul exch 0\&.6094 mul add exch 0\&.3086 mul add neg 1\&.0 add setgray } BD\n'
              '/W  { setlinewidth } BD\n');

  /* text decoration (border and fill) */

  gl2psPrintf('/TB { gsave 4 1 roll setrgbcolor fillState not { exch W } if\n'
              '      SM neg dup SD add rmoveto currentpoint newpath moveto\n'
              '      SW SM 2 mul add 0 rlineto\n'
              '      0 SH SM 2 mul add rlineto\n'
              '      SW SM 2 mul add neg 0 rlineto\n'
              '      closepath fillState { fill } { stroke } ifelse grestore } BD\n'
              '/SBX{ exch dup 0 gt { dup 1 and 0 gt { 5 1 roll /fillState true def TB exch } if\n'
              '      2 and 0 gt { /fillState false def TB } if } { pop } ifelse } BD\n'
              '/TS { SBX show } BD\n');

  gl2psPrintf('/FD { gsave newpath 0 0 moveto (p) false charpath flattenpath pathbbox\n'
              '      pop pop exch pop /SD exch def grestore } BD\n'
              '/FC { /SO exch def /SM exch def findfont exch /SH exch def SH scalefont setfont FD } BD\n'
              '/SW { dup stringwidth pop } BD\n'
              '/S  { FC moveto SO { SM 0 rmoveto } if TS } BD\n'
              '/SLC{ FC moveto SW -2 div 0 rmoveto TS } BD\n'
              '/SLR{ FC moveto SO { SM neg 0 rmoveto } if SW neg 0 rmoveto TS } BD\n'
              '/SBL{ FC moveto SO { SM dup rmoveto } if 0 SD neg rmoveto TS } BD\n'
              '/SBC{ FC moveto SO { 0 SM rmoveto } if SW -2 div SD neg rmoveto TS } BD\n'
              '/SBR{ FC moveto SO { SM neg SM rmoveto } if SW neg SD neg rmoveto TS } BD\n'
              '/SCL{ FC moveto SO { SM 0 rmoveto } if 0 SH -2 div SD sub rmoveto TS } BD\n'
              '/SCC{ FC moveto SW -2 div SH -2 div SD sub rmoveto TS } BD\n'
              '/SCR{ FC moveto SO { SM neg 0 rmoveto } if SW neg SH -2 div SD sub rmoveto TS } BD\n'
              '/STL{ FC moveto SO { SM SM neg rmoveto } if 0 SH neg SD sub rmoveto TS } BD\n'
              '/STC{ FC moveto SO { 0 SM neg rmoveto } if SW -2 div SH neg SD sub rmoveto TS } BD\n'
              '/STR{ FC moveto SO { SM neg dup rmoveto } if SW neg SH neg SD sub rmoveto TS } BD\n');

  /* rotated text routines: same nameanem with R appended */

  gl2psPrintf('/FCT { FC translate 0 0 } BD\n'
              '/SR  { gsave FCT moveto rotate SO { SM 0 rmoveto } if TS grestore } BD\n'  
              '/SLCR{ gsave FCT moveto rotate SW -2 div 0 rmoveto TS grestore } BD\n'  
              '/SLRR{ gsave FCT moveto rotate SO { SM neg 0 rmoveto } if SW neg 0 rmoveto TS grestore } BD\n'  
              '/SBLR{ gsave FCT moveto rotate SO { SM dup rmoveto } if 0 SD neg rmoveto TS grestore } BD\n'  
              '/SBCR{ gsave FCT moveto rotate SO { 0 SM rmoveto } if SW -2 div SD neg rmoveto TS grestore } BD\n'
              '/SBRR{ gsave FCT moveto rotate SO { SM neg SM rmoveto } if SW neg SD neg rmoveto TS grestore } BD\n'
              '/SCLR{ gsave FCT moveto rotate SO { SM 0 rmoveto } if 0 SH -2 div SD sub rmoveto TS grestore} BD\n');
  gl2psPrintf('/SCCR{ gsave FCT moveto rotate SW -2 div SH -2 div SD sub rmoveto TS grestore} BD\n'
              '/SCRR{ gsave FCT moveto rotate SO { SM neg 0 rmoveto } if SW neg SH -2 div SD sub rmoveto TS grestore} BD\n'
              '/STLR{ gsave FCT moveto rotate SO { SM SM neg rmoveto } if 0 SH neg SD sub rmoveto TS grestore } BD\n'
              '/STCR{ gsave FCT moveto rotate SO { 0 SM neg rmoveto } if SW -2 div SH neg SD sub rmoveto TS grestore } BD\n'
              '/STRR{ gsave FCT moveto rotate SO { SM neg dup rmoveto } if SW neg SH neg SD sub rmoveto TS grestore } BD\n');

  gl2psPrintf('/P  { newpath 0\&.0 360\&.0 arc closepath fill } BD\n'
              '/LS { newpath moveto } BD\n'
              '/L  { lineto } BD\n'
              '/LE { lineto stroke } BD\n'
              '/T  { newpath moveto lineto lineto closepath fill } BD\n');

  /* enhanced text - octave addon */

  gl2psPrintf('/SP { [ currentpoint ] } BD\n'
              '/RP { aload pop moveto } BD\n'
              '/Tflag false def\n'
                          '/TEshow{dup dup 1 get exch 0 get findfont exch scalefont setfont\n'
                          '        dup 2 get dup 0 exch rmoveto exch 3 get Tflag {false charpath}\n'
                          '        {show} ifelse neg 0 exch rmoveto} BD\n'
                          '/Tshow {{dup xcheck {exec} {TEshow} ifelse} forall} BD\n'
                          '/PTshow{dup length exch SP exch {TEshow currentpoint pop 3 1 roll dup RP}\n'
                          '        forall pop 1 sub {2 copy gt {pop} {exch pop} ifelse} repeat\n'
                          '        currentpoint exch pop moveto} BD\n'
                          '/Tbbox {gsave newpath 0 0 moveto /Tflag true def Tshow /Tflag\n'
              '        false def flattenpath pathbbox grestore} BD\n'
              '/LLshow {SP exch Tshow RP} BD\n'
              '/LCshow {SP exch dup Tbbox pop 2 div neg 0 rmoveto pop pop Tshow RP} BD\n'
              '/LRshow {SP exch dup Tbbox pop neg 0 rmoveto pop pop Tshow SP} BD\n'
              '%%/Pshow {0 exch {dup Tbbox exch pop 3 2 roll pop 4 -1 roll neg add\n'
              '%%        -2 sub neg 0 exch rmoveto currentpoint 4 -1 roll LCshow moveto}\n'
              '%%        forall} BD\n');

  /* Smooth-shaded triangle with PostScript level 3 shfill operator:
        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STshfill */

  gl2psPrintf('/STshfill {\n'
              '      /b1 exch def /g1 exch def /r1 exch def /y1 exch def /x1 exch def\n'
              '      /b2 exch def /g2 exch def /r2 exch def /y2 exch def /x2 exch def\n'
              '      /b3 exch def /g3 exch def /r3 exch def /y3 exch def /x3 exch def\n'
              '      gsave << /ShadingType 4 /ColorSpace [/DeviceRGB]\n'
              '      /DataSource [ 0 x1 y1 r1 g1 b1 0 x2 y2 r2 g2 b2 0 x3 y3 r3 g3 b3 ] >>\n'
              '      shfill grestore } BD\n');

  /* Flat-shaded triangle with middle color:
        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 Tm */

  gl2psPrintf(/* stack : x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 */
              '/Tm { 3 -1 roll 8 -1 roll 13 -1 roll add add 3 div\n' /* r = (r1+r2+r3)/3 */
              /* stack : x3 y3 g3 b3 x2 y2 g2 b2 x1 y1 g1 b1 r */
              '      3 -1 roll 7 -1 roll 11 -1 roll add add 3 div\n' /* g = (g1+g2+g3)/3 */
              /* stack : x3 y3 b3 x2 y2 b2 x1 y1 b1 r g b */
              '      3 -1 roll 6 -1 roll 9 -1 roll add add 3 div' /* b = (b1+b2+b3)/3 */
              /* stack : x3 y3 x2 y2 x1 y1 r g b */
              ' C T } BD\n');

  /* Split triangle in four sub-triangles (at sides middle points) and call the
     STnoshfill procedure on each, interpolating the colors in RGB space:
        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STsplit
     (in procedure comments key: (Vi) = xi yi ri gi bi) */

  gl2psPrintf('/STsplit {\n'
              '      4 index 15 index add 0\&.5 mul\n' /* x13 = (x1+x3)/2 */
              '      4 index 15 index add 0\&.5 mul\n' /* y13 = (y1+y3)/2 */
              '      4 index 15 index add 0\&.5 mul\n' /* r13 = (r1+r3)/2 */
              '      4 index 15 index add 0\&.5 mul\n' /* g13 = (g1+g3)/2 */
              '      4 index 15 index add 0\&.5 mul\n' /* b13 = (b1+b3)/2 */
              '      5 copy 5 copy 25 15 roll\n');

  /* at his point, stack = (V3) (V13) (V13) (V13) (V2) (V1) */

  gl2psPrintf('      9 index 30 index add 0\&.5 mul\n' /* x23 = (x2+x3)/2 */
              '      9 index 30 index add 0\&.5 mul\n' /* y23 = (y2+y3)/2 */
              '      9 index 30 index add 0\&.5 mul\n' /* r23 = (r2+r3)/2 */
              '      9 index 30 index add 0\&.5 mul\n' /* g23 = (g2+g3)/2 */
              '      9 index 30 index add 0\&.5 mul\n' /* b23 = (b2+b3)/2 */
              '      5 copy 5 copy 35 5 roll 25 5 roll 15 5 roll\n');

  /* stack = (V3) (V13) (V23) (V13) (V23) (V13) (V23) (V2) (V1) */

  gl2psPrintf('      4 index 10 index add 0\&.5 mul\n' /* x12 = (x1+x2)/2 */
              '      4 index 10 index add 0\&.5 mul\n' /* y12 = (y1+y2)/2 */
              '      4 index 10 index add 0\&.5 mul\n' /* r12 = (r1+r2)/2 */
              '      4 index 10 index add 0\&.5 mul\n' /* g12 = (g1+g2)/2 */
              '      4 index 10 index add 0\&.5 mul\n' /* b12 = (b1+b2)/2 */
              '      5 copy 5 copy 40 5 roll 25 5 roll 15 5 roll 25 5 roll\n');
  
  /* stack = (V3) (V13) (V23) (V13) (V12) (V23) (V13) (V1) (V12) (V23) (V12) (V2) */

  gl2psPrintf('      STnoshfill STnoshfill STnoshfill STnoshfill } BD\n');
  
  /* Gouraud shaded triangle using recursive subdivision until the difference
     between corner colors does not exceed the thresholds:
        x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STnoshfill  */

  gl2psPrintf('/STnoshfill {\n'
              '      2 index 8 index sub abs rThreshold gt\n' /* |r1-r2|>rth */
              '      { STsplit }\n'
              '      { 1 index 7 index sub abs gThreshold gt\n' /* |g1-g2|>gth */
              '        { STsplit }\n'
              '        { dup 6 index sub abs bThreshold gt\n' /* |b1-b2|>bth */
              '          { STsplit }\n'
              '          { 2 index 13 index sub abs rThreshold gt\n' /* |r1-r3|>rht */
              '            { STsplit }\n'
              '            { 1 index 12 index sub abs gThreshold gt\n' /* |g1-g3|>gth */
              '              { STsplit }\n'
              '              { dup 11 index sub abs bThreshold gt\n' /* |b1-b3|>bth */
              '                { STsplit }\n'
              '                { 7 index 13 index sub abs rThreshold gt\n'); /* |r2-r3|>rht */
  gl2psPrintf('                  { STsplit }\n'
              '                  { 6 index 12 index sub abs gThreshold gt\n' /* |g2-g3|>gth */
              '                    { STsplit }\n'
              '                    { 5 index 11 index sub abs bThreshold gt\n' /* |b2-b3|>bth */
              '                      { STsplit }\n'
              '                      { Tm }\n' /* all colors sufficiently similar */
              '                      ifelse }\n'
              '                    ifelse }\n'
              '                  ifelse }\n'
              '                ifelse }\n'
              '              ifelse }\n'
              '            ifelse }\n'
              '          ifelse }\n'
              '        ifelse }\n'
              '      ifelse } BD\n');
  
  gl2psPrintf('tryPS3shading\n'
              '{ /shfill where\n'
              '  { /ST { STshfill } BD }\n'
              '  { /ST { STnoshfill } BD }\n'
              '  ifelse }\n'
              '{ /ST { STnoshfill } BD }\n'
              'ifelse\n');

  /* add symbol oblique font - octave addon */

  gl2psPrintf('/Symbol-Oblique /Symbol findfont [1 0 \&.167 1 0 0] makefont\n'
              'dup length dict begin {1 index /FID eq {pop pop} {def} ifelse} forall\n'
              'currentdict end definefont pop\n');
                                        
  gl2psPrintf('end\n'
              '%%%%EndProlog\n'
              '%%%%BeginSetup\n'
              '/DeviceRGB setcolorspace\n'
              'gl2psdict begin\n'
              '%%%%EndSetup\n'
              '%%%%Page: 1 1\n'
              '%%%%BeginPageSetup\n');
  
  if(gl2ps->options & GL2PS_LANDSCAPE){
    gl2psPrintf('%d 0 translate 90 rotate\n',
                (int)gl2ps->viewport[3]);
  }

  gl2psPrintf('%%%%EndPageSetup\n'
              'mark\n'
              'gsave\n'
              '1\&.0 1\&.0 scale\n');
          
  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    gl2psPrintf('%g %g %g C\n'
                'newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n'
                'closepath fill\n',
                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2], 
                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], 
                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
                (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
  }
}
.fi
.SS "static void \fBgl2psPrintPostScriptImagemap\fP (GLfloatx, GLfloaty, GLsizeiwidth, GLsizeiheight, const unsigned char *imagemap)\fC [static]\fP"
.PP
Definition at line 2674 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), gl2psWriteByte(), and i\&.
.PP
Referenced by gl2psPrintPostScriptPrimitive()\&.
.PP
.nf
                                                                       {
  int i, size;
  
  if((width <= 0) || (height <= 0)) return;
  
  size = height + height * (width-1)/8;
  
  gl2psPrintf('gsave\n');
  gl2psPrintf('%\&.2f %\&.2f translate\n', x, y);
  gl2psPrintf('%d %d scale\n%d %d\ntrue\n', width, height,width, height); 
  gl2psPrintf('[ %d 0 0 -%d 0 %d ] {<', width, height);
  for(i = 0; i < size; i++){
    gl2psWriteByte(*imagemap);
    imagemap++;
  }
  gl2psPrintf('>} imagemask\ngrestore\n');
}
.fi
.SS "static void \fBgl2psPrintPostScriptPixmap\fP (GLfloatx, GLfloaty, \fBGL2PSimage\fP *im)\fC [static]\fP"
.PP
Definition at line 2473 of file gl2ps\&.c\&.
.PP
References gl2psGetRGB(), gl2psPrintf(), gl2psWriteByte(), GL2PSimage::height, width, and GL2PSimage::width\&.
.PP
Referenced by gl2psPrintPostScriptPrimitive()\&.
.PP
.nf
{
  GLuint nbhex, nbyte, nrgb, nbits;
  GLuint row, col, ibyte, icase;
  GLfloat dr, dg, db, fgrey;
  unsigned char red = 0, green = 0, blue = 0, b, grey;
  GLuint width = (GLuint)im->width;
  GLuint height = (GLuint)im->height;

  /* FIXME: should we define an option for these? Or just keep the
     8-bit per component case? */
  int greyscale = 0; /* set to 1 to output greyscale image */
  int nbit = 8; /* number of bits per color compoment (2, 4 or 8) */

  if((width <= 0) || (height <= 0)) return;

  gl2psPrintf('gsave\n');
  gl2psPrintf('%\&.2f %\&.2f translate\n', x, y); 
  gl2psPrintf('%d %d scale\n', width, height); 

  if(greyscale){ /* greyscale */
    gl2psPrintf('/picstr %d string def\n', width); 
    gl2psPrintf('%d %d %d\n', width, height, 8); 
    gl2psPrintf('[ %d 0 0 -%d 0 %d ]\n', width, height, height); 
    gl2psPrintf('{ currentfile picstr readhexstring pop }\n');
    gl2psPrintf('image\n');
    for(row = 0; row < height; row++){
      for(col = 0; col < width; col++){ 
        gl2psGetRGB(im, col, row, &dr, &dg, &db);
        fgrey = (0\&.30 * dr + 0\&.59 * dg + 0\&.11 * db);
        grey = (unsigned char)(255\&. * fgrey);
        gl2psWriteByte(grey);
      }
      gl2psPrintf('\n');
    }
    nbhex = width * height * 2; 
    gl2psPrintf('%%%% nbhex digit          :%d\n', nbhex); 
  }
  else if(nbit == 2){ /* color, 2 bits for r and g and b; rgbs following each other */
    nrgb = width  * 3;
    nbits = nrgb * nbit;
    nbyte = nbits/8;
    if((nbyte * 8) != nbits) nbyte++;
    gl2psPrintf('/rgbstr %d string def\n', nbyte);
    gl2psPrintf('%d %d %d\n', width, height, nbit);
    gl2psPrintf('[ %d 0 0 -%d 0 %d ]\n', width, height, height);
    gl2psPrintf('{ currentfile rgbstr readhexstring pop }\n');
    gl2psPrintf('false 3\n');
    gl2psPrintf('colorimage\n');
    for(row = 0; row < height; row++){
      icase = 1;
      col = 0;
      b = 0;
      for(ibyte = 0; ibyte < nbyte; ibyte++){
        if(icase == 1) {
          if(col < width) {
            gl2psGetRGB(im, col, row, &dr, &dg, &db);
          } 
          else {
            dr = dg = db = 0;
          }
          col++;
          red = (unsigned char)(3\&. * dr);
          green = (unsigned char)(3\&. * dg);
          blue = (unsigned char)(3\&. * db);
          b = red;
          b = (b<<2) + green;
          b = (b<<2) + blue;
          if(col < width) {
            gl2psGetRGB(im, col, row, &dr, &dg, &db);
          } 
          else {
            dr = dg = db = 0;
          }
          col++;
          red = (unsigned char)(3\&. * dr);
          green = (unsigned char)(3\&. * dg);
          blue = (unsigned char)(3\&. * db);
          b = (b<<2) + red;
          gl2psWriteByte(b);
          b = 0;
          icase++;
        } 
        else if(icase == 2) {
          b = green;
          b = (b<<2) + blue;
          if(col < width) {
            gl2psGetRGB(im, col, row, &dr, &dg, &db);
          }
          else {
            dr = dg = db = 0;
          }
          col++;
          red = (unsigned char)(3\&. * dr);
          green = (unsigned char)(3\&. * dg);
          blue = (unsigned char)(3\&. * db);
          b = (b<<2) + red;
          b = (b<<2) + green;
          gl2psWriteByte(b);
          b = 0;
          icase++;
        } 
        else if(icase == 3) {
          b = blue;
          if(col < width) {
            gl2psGetRGB(im, col, row, &dr, &dg, &db);
          }
          else {
            dr = dg = db = 0;
          }
          col++;
          red = (unsigned char)(3\&. * dr);
          green = (unsigned char)(3\&. * dg);
          blue = (unsigned char)(3\&. * db);
          b = (b<<2) + red;
          b = (b<<2) + green;
          b = (b<<2) + blue;
          gl2psWriteByte(b);
          b = 0;
          icase = 1;
        }
      }
      gl2psPrintf('\n');
    }
  }
  else if(nbit == 4){ /* color, 4 bits for r and g and b; rgbs following each other */
    nrgb = width  * 3;
    nbits = nrgb * nbit;
    nbyte = nbits/8;
    if((nbyte * 8) != nbits) nbyte++; 
    gl2psPrintf('/rgbstr %d string def\n', nbyte);
    gl2psPrintf('%d %d %d\n', width, height, nbit);
    gl2psPrintf('[ %d 0 0 -%d 0 %d ]\n', width, height, height);
    gl2psPrintf('{ currentfile rgbstr readhexstring pop }\n');
    gl2psPrintf('false 3\n');
    gl2psPrintf('colorimage\n');
    for(row = 0; row < height; row++){
      col = 0;
      icase = 1;
      for(ibyte = 0; ibyte < nbyte; ibyte++){
        if(icase == 1) {
          if(col < width) {
            gl2psGetRGB(im, col, row, &dr, &dg, &db);
          } 
          else {
            dr = dg = db = 0;
          }
          col++;
          red = (unsigned char)(15\&. * dr);
          green = (unsigned char)(15\&. * dg);
          gl2psPrintf('%x%x', red, green);
          icase++;
        } 
        else if(icase == 2) {
          blue = (unsigned char)(15\&. * db);
          if(col < width) {
            gl2psGetRGB(im, col, row, &dr, &dg, &db);
          } 
          else {
            dr = dg = db = 0;
          }
          col++;
          red = (unsigned char)(15\&. * dr);
          gl2psPrintf('%x%x', blue, red);
          icase++;
        }
        else if(icase == 3) {
          green = (unsigned char)(15\&. * dg);
          blue = (unsigned char)(15\&. * db);
          gl2psPrintf('%x%x', green, blue);
          icase = 1;
        }
      }
      gl2psPrintf('\n');
    }
  }
  else{ /* 8 bit for r and g and b */
    nbyte = width * 3;
    gl2psPrintf('/rgbstr %d string def\n', nbyte);
    gl2psPrintf('%d %d %d\n', width, height, 8);
    gl2psPrintf('[ %d 0 0 -%d 0 %d ]\n', width, height, height); 
    gl2psPrintf('{ currentfile rgbstr readhexstring pop }\n');
    gl2psPrintf('false 3\n');
    gl2psPrintf('colorimage\n');
    for(row = 0; row < height; row++){
      for(col = 0; col < width; col++){
        gl2psGetRGB(im, col, row, &dr, &dg, &db);
        red = (unsigned char)(255\&. * dr);
        gl2psWriteByte(red);
        green = (unsigned char)(255\&. * dg);
        gl2psWriteByte(green);
        blue = (unsigned char)(255\&. * db);
        gl2psWriteByte(blue);
      }
      gl2psPrintf('\n');
    }
  }
  
  gl2psPrintf('grestore\n');
}
.fi
.SS "static void \fBgl2psPrintPostScriptPrimitive\fP (void *data)\fC [static]\fP"
.PP
Definition at line 3066 of file gl2ps\&.c\&.
.PP
References GL2PSstring::alignment, GL2PSstring::angle, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PSstring::fillcolor, GL2PSstring::fontname, GL2PSstring::fontsize, GL2PS_EPS, GL2PS_IMAGEMAP, GL2PS_IMAGEMAP_WRITTEN, GL2PS_LINE, GL2PS_OCCLUSION_CULL, GL2PS_PIXMAP, GL2PS_POINT, GL2PS_PS, GL2PS_QUADRANGLE, GL2PS_SPECIAL, GL2PS_TEXT, GL2PS_TEXT_B, GL2PS_TEXT_BL, GL2PS_TEXT_BR, GL2PS_TEXT_C, GL2PS_TEXT_CL, GL2PS_TEXT_CR, GL2PS_TEXT_L, GL2PS_TEXT_LL, GL2PS_TEXT_LR, GL2PS_TEXT_T, GL2PS_TEXT_TL, GL2PS_TEXT_TR, GL2PS_TRIANGLE, GL2PS_WARNING, gl2psEndPostScriptLine(), gl2psMsg(), gl2psPrintf(), gl2psPrintPostScriptColor(), gl2psPrintPostScriptDash(), gl2psPrintPostScriptImagemap(), gl2psPrintPostScriptPixmap(), gl2psResetPostScriptColor(), gl2psSameColor(), gl2psSamePosition(), gl2psVertsSameColor(), GL2PSimage::height, GL2PSprimitive::image, GL2PScontext::lastfactor, GL2PScontext::lastlinewidth, GL2PScontext::lastpattern, GL2PScontext::lastrgba, GL2PScontext::lastvertex, GL2PSstring::linecolor, GL2PSstring::linefactor, GL2PSstring::linepattern, GL2PSstring::linewidth, GL2PSstring::margin, GL2PSstring::offsetmargin, GL2PScontext::options, GL2PSprimitive::pattern, GL2PSimage::pixels, GL2PSvertex::rgba, GL2PSstring::str, GL2PSprimitive::text, GL2PSimage::type, GL2PSprimitive::type, GL2PSprimitive::verts, GL2PSimage::width, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
.nf
{
  int newline;
  GL2PSprimitive *prim;

  prim = *(GL2PSprimitive**)data;

  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) return;

  /* Every effort is made to draw lines as connected segments (i\&.e\&.,
     using a single PostScript path): this is the only way to get nice
     line joins and to not restart the stippling for every line
     segment\&. So if the primitive to print is not a line we must first
     finish the current line (if any): */
  if(prim->type != GL2PS_LINE) gl2psEndPostScriptLine();

  switch(prim->type){
  case GL2PS_POINT :
    gl2psPrintPostScriptColor(prim->verts[0]\&.rgba);
    gl2psPrintf('%g %g %g P\n', 
                prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1], 0\&.5 * prim->width);
    break;
  case GL2PS_LINE :
    if(!gl2psSamePosition(gl2ps->lastvertex\&.xyz, prim->verts[0]\&.xyz) ||
       !gl2psSameColor(gl2ps->lastrgba, prim->verts[0]\&.rgba) ||
       gl2ps->lastlinewidth != prim->width ||
       gl2ps->lastpattern != prim->pattern ||
       gl2ps->lastfactor != prim->factor){
      /* End the current line if the new segment does not start where
         the last one ended, or if the color, the width or the
         stippling have changed (multi-stroking lines with changing
         colors is necessary until we use /shfill for lines;
         unfortunately this means that at the moment we can screw up
         line stippling for smooth-shaded lines) */
      gl2psEndPostScriptLine();
      newline = 1;
    }
    else{
      newline = 0;
    }
    if(gl2ps->lastlinewidth != prim->width){
      gl2ps->lastlinewidth = prim->width;
      gl2psPrintf('%g W\n', gl2ps->lastlinewidth);
    }
    gl2psPrintPostScriptDash(prim->pattern, prim->factor, 'setdash');
    gl2psPrintPostScriptColor(prim->verts[0]\&.rgba);
    gl2psPrintf('%g %g %s\n', prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1],
                newline ? 'LS' : 'L');
    gl2ps->lastvertex = prim->verts[1];
    break;
  case GL2PS_TRIANGLE :
    if(!gl2psVertsSameColor(prim)){
      gl2psResetPostScriptColor();
      gl2psPrintf('%g %g %g %g %g %g %g %g %g %g %g %g %g %g %g ST\n',
                  prim->verts[2]\&.xyz[0], prim->verts[2]\&.xyz[1],
                  prim->verts[2]\&.rgba[0], prim->verts[2]\&.rgba[1],
                  prim->verts[2]\&.rgba[2], prim->verts[1]\&.xyz[0],
                  prim->verts[1]\&.xyz[1], prim->verts[1]\&.rgba[0],
                  prim->verts[1]\&.rgba[1], prim->verts[1]\&.rgba[2],
                  prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1],
                  prim->verts[0]\&.rgba[0], prim->verts[0]\&.rgba[1],
                  prim->verts[0]\&.rgba[2]);
    }
    else{
      gl2psPrintPostScriptColor(prim->verts[0]\&.rgba);
      gl2psPrintf('%g %g %g %g %g %g T\n',
                  prim->verts[2]\&.xyz[0], prim->verts[2]\&.xyz[1],
                  prim->verts[1]\&.xyz[0], prim->verts[1]\&.xyz[1],
                  prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
    }
    break;
  case GL2PS_QUADRANGLE :
    gl2psMsg(GL2PS_WARNING, 'There should not be any quad left to print');
    break;
  case GL2PS_PIXMAP :
    gl2psPrintPostScriptPixmap(prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1],
                               prim->data\&.image);
    break;
  case GL2PS_IMAGEMAP :
    if(prim->data\&.image->type != GL2PS_IMAGEMAP_WRITTEN){
      gl2psPrintPostScriptColor(prim->verts[0]\&.rgba);
      gl2psPrintPostScriptImagemap(prim->data\&.image->pixels[0],
                                   prim->data\&.image->pixels[1],
                                   prim->data\&.image->width, prim->data\&.image->height,
                                   (const unsigned char*)(&(prim->data\&.image->pixels[2])));
      prim->data\&.image->type = GL2PS_IMAGEMAP_WRITTEN;
    }
    break;
  case GL2PS_TEXT :
    gl2psPrintPostScriptColor(prim->verts[0]\&.rgba);
    if (prim->data\&.text->linecolor[0] >= 0 || prim->data\&.text->fillcolor[0] >= 0)
    {
      int boxFlag = 0;
      if (prim->data\&.text->linecolor[0] >= 0)
      {
        gl2psPrintPostScriptDash(prim->data\&.text->linepattern, prim->data\&.text->linefactor, 'setdash');
        gl2psPrintf('%g %g %g %g ', prim->data\&.text->linewidth, prim->data\&.text->linecolor[0],
            prim->data\&.text->linecolor[1], prim->data\&.text->linecolor[2]);
        boxFlag |= 2;
      }
      if (prim->data\&.text->fillcolor[0] >= 0)
      {
        gl2psPrintf('%g %g %g ', prim->data\&.text->fillcolor[0], prim->data\&.text->fillcolor[1],
            prim->data\&.text->fillcolor[2]);
        boxFlag |= 1;
      }
      gl2psPrintf('%d ', boxFlag);
    }
    else
      gl2psPrintf('0 ');
    gl2psPrintf('(%s) ', prim->data\&.text->str);
    if(prim->data\&.text->angle)
      gl2psPrintf('%g ', prim->data\&.text->angle);
    gl2psPrintf('%g %g %d /%s %g %s ',
                prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1],
                prim->data\&.text->fontsize, prim->data\&.text->fontname, prim->data\&.text->margin,
                prim->data\&.text->offsetmargin ? 'true' : 'false');
    switch(prim->data\&.text->alignment){
    case GL2PS_TEXT_C:
      gl2psPrintf(prim->data\&.text->angle ? 'SCCR\n' : 'SCC\n');
      break;
    case GL2PS_TEXT_CL:
      gl2psPrintf(prim->data\&.text->angle ? 'SCLR\n' : 'SCL\n');
      break;
    case GL2PS_TEXT_CR:
      gl2psPrintf(prim->data\&.text->angle ? 'SCRR\n' : 'SCR\n');
      break;
    case GL2PS_TEXT_B:
      gl2psPrintf(prim->data\&.text->angle ? 'SBCR\n' : 'SBC\n');
      break;
    case GL2PS_TEXT_BR:
      gl2psPrintf(prim->data\&.text->angle ? 'SBRR\n' : 'SBR\n');
      break;
    case GL2PS_TEXT_T:
      gl2psPrintf(prim->data\&.text->angle ? 'STCR\n' : 'STC\n');
      break;
    case GL2PS_TEXT_TL:
      gl2psPrintf(prim->data\&.text->angle ? 'STLR\n' : 'STL\n');
      break;
    case GL2PS_TEXT_TR:
      gl2psPrintf(prim->data\&.text->angle ? 'STRR\n' : 'STR\n');
      break;
    case GL2PS_TEXT_BL:
      gl2psPrintf(prim->data\&.text->angle ? 'SBLR\n' : 'SBL\n');
      break;
    case GL2PS_TEXT_L:
      gl2psPrintf(prim->data\&.text->angle ? 'SLCR\n' : 'SLC\n');
      break;
    case GL2PS_TEXT_LR:
      gl2psPrintf(prim->data\&.text->angle ? 'SLRR\n' : 'SLR\n');
      break;
    case GL2PS_TEXT_LL:
    default:
      gl2psPrintf(prim->data\&.text->angle ? 'SR\n' : 'S\n');
    }
    break;
  case GL2PS_SPECIAL :
    if (prim->data\&.text->fontsize > 0)
      gl2psPrintf('%g %g moveto\n', prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
    /* alignment contains the format for which the special output text
       is intended */
    if(prim->data\&.text->alignment == GL2PS_PS ||
       prim->data\&.text->alignment == GL2PS_EPS)
      gl2psPrintf('%s\n', prim->data\&.text->str);
    break;
  default :
    break;
  }
}
.fi
.SS "static GLint \fBgl2psPrintPrimitives\fP (void)\fC [static]\fP"
.PP
Definition at line 5584 of file gl2ps\&.c\&.
.PP
References GL2PScontext::boundary, GL2PScontext::format, GL2PS_BSP_SORT, GL2PS_EPSILON, GL2PS_INFO, GL2PS_NO_FEEDBACK, GL2PS_NO_SORT, GL2PS_OCCLUSION_CULL, GL2PS_OVERFLOW, GL2PS_SIMPLE_SORT, GL2PS_SUCCESS, GL2PS_TIGHT_BOUNDING_BOX, GL2PS_ZSCALE, gl2psAddInImageTree(), gl2psBuildBspTree(), gl2psBuildPolygonBoundary(), gl2psCompareDepth(), gl2psComputeTightBoundingBox(), gl2psFreeBspImageTree(), gl2psFreeBspTree(), gl2psFreePrimitive(), gl2psGreater(), gl2psLess(), gl2psListAction(), gl2psListActionInverse(), gl2psListCreate(), gl2psListNbr(), gl2psListReset(), gl2psListSort(), gl2psMalloc(), gl2psMsg(), gl2psParseFeedbackBuffer(), gl2psRescaleAndOffset(), gl2psTraverseBspTree(), GL2PScontext::header, GL2PScontext::imagetree, GL2PScontext::options, GL2PScontext::primitives, GL2PSbackend::printFinalPrimitive, GL2PSbackend::printHeader, GL2PSbackend::printPrimitive, GL2PScontext::sort, and GL2PScontext::viewport\&.
.PP
Referenced by gl2psEndPage(), gl2psPrintPDFEndViewport(), gl2psPrintPGFEndViewport(), gl2psPrintPostScriptEndViewport(), gl2psPrintSVGEndViewport(), and gl2psPrintTeXEndViewport()\&.
.PP
.nf
{
  GL2PSbsptree *root;
  GL2PSxyz eye = {0\&.0F, 0\&.0F, 100\&.0F * GL2PS_ZSCALE};
  GLint used;

  used = glRenderMode(GL_RENDER);

  if(used < 0){
    gl2psMsg(GL2PS_INFO, 'OpenGL feedback buffer overflow');
    return GL2PS_OVERFLOW;
  }

  if(used > 0)
    gl2psParseFeedbackBuffer(used);

  gl2psRescaleAndOffset();

  if(gl2ps->header){
    if(gl2psListNbr(gl2ps->primitives) && 
       (gl2ps->options & GL2PS_TIGHT_BOUNDING_BOX)){
      gl2ps->viewport[0] = gl2ps->viewport[1] = 100000;
      gl2ps->viewport[2] = gl2ps->viewport[3] = -100000;
      gl2psListAction(gl2ps->primitives, gl2psComputeTightBoundingBox);
    }
    (gl2psbackends[gl2ps->format]->printHeader)();
    gl2ps->header = GL_FALSE;
  }

  if(!gl2psListNbr(gl2ps->primitives)){
    /* empty feedback buffer and/or nothing else to print */
    return GL2PS_NO_FEEDBACK;
  }

  switch(gl2ps->sort){
  case GL2PS_NO_SORT :
    gl2psListAction(gl2ps->primitives, gl2psbackends[gl2ps->format]->printPrimitive);
    gl2psListAction(gl2ps->primitives, gl2psFreePrimitive);
    /* reset the primitive list, waiting for the next viewport */
    gl2psListReset(gl2ps->primitives);
    break;
  case GL2PS_SIMPLE_SORT :
    gl2psListSort(gl2ps->primitives, gl2psCompareDepth);
    if(gl2ps->options & GL2PS_OCCLUSION_CULL){
      gl2psListActionInverse(gl2ps->primitives, gl2psAddInImageTree);
      gl2psFreeBspImageTree(&gl2ps->imagetree);
    }
    gl2psListAction(gl2ps->primitives, gl2psbackends[gl2ps->format]->printPrimitive);
    gl2psListAction(gl2ps->primitives, gl2psFreePrimitive);
    /* reset the primitive list, waiting for the next viewport */
    gl2psListReset(gl2ps->primitives);
    break;
  case GL2PS_BSP_SORT :
    root = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
    gl2psBuildBspTree(root, gl2ps->primitives);
    if(GL_TRUE == gl2ps->boundary) gl2psBuildPolygonBoundary(root);
    if(gl2ps->options & GL2PS_OCCLUSION_CULL){
      gl2psTraverseBspTree(root, eye, -GL2PS_EPSILON, gl2psLess,
                           gl2psAddInImageTree, 1);
      gl2psFreeBspImageTree(&gl2ps->imagetree);
    }
    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater, 
                         gl2psbackends[gl2ps->format]->printPrimitive, 0);
    gl2psFreeBspTree(&root);
    /* reallocate the primitive list (it's been deleted by
       gl2psBuildBspTree) in case there is another viewport */
    gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
    break;
  }
  gl2psbackends[gl2ps->format]->printFinalPrimitive();

  return GL2PS_SUCCESS;
}
.fi
.SS "static void \fBgl2psPrintSVGBeginViewport\fP (GLintviewport[4])\fC [static]\fP"
.PP
Definition at line 5252 of file gl2ps\&.c\&.
.PP
References GL2PScontext::colormap, GL2PScontext::colormode, GL2PScontext::colorsize, GL2PS_DRAW_BACKGROUND, gl2psPrintf(), gl2psPrintSVGHeader(), gl2psSVGGetColorString(), h, GL2PScontext::header, GL2PScontext::options, GL2PScontext::viewport, w, x, and y\&.
.PP
.nf
{
  GLint index;
  char col[32];
  GLfloat rgba[4];
  int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];

  glRenderMode(GL_FEEDBACK);
  
  if(gl2ps->header){
    gl2psPrintSVGHeader();
    gl2ps->header = GL_FALSE;
  }

  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
      glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
    }
    else{
      glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
      rgba[0] = gl2ps->colormap[index][0];
      rgba[1] = gl2ps->colormap[index][1];
      rgba[2] = gl2ps->colormap[index][2];
      rgba[3] = 1\&.0F;
    }
    gl2psSVGGetColorString(rgba, col);
    gl2psPrintf('<polygon fill=\'%s\' points=\'%d,%d %d,%d %d,%d %d,%d\'/>\n', col, 
                x, gl2ps->viewport[3] - y, 
                x + w, gl2ps->viewport[3] - y, 
                x + w, gl2ps->viewport[3] - (y + h), 
                x, gl2ps->viewport[3] - (y + h));
  }

  gl2psPrintf('<clipPath id=\'cp%d%d%d%d\'>\n', x, y, w, h);
  gl2psPrintf('  <polygon points=\'%d,%d %d,%d %d,%d %d,%d\'/>\n', 
              x, gl2ps->viewport[3] - y, 
              x + w, gl2ps->viewport[3] - y, 
              x + w, gl2ps->viewport[3] - (y + h), 
              x, gl2ps->viewport[3] - (y + h));
  gl2psPrintf('</clipPath>\n');
  gl2psPrintf('<g clip-path=\'url(#cp%d%d%d%d)\'>\n', x, y, w, h);
}
.fi
.SS "static void \fBgl2psPrintSVGDash\fP (GLushortpattern, GLintfactor)\fC [static]\fP"
.PP
Definition at line 5095 of file gl2ps\&.c\&.
.PP
References gl2psParseStipplePattern(), gl2psPrintf(), i, and n\&.
.PP
Referenced by gl2psPrintSVGPrimitive()\&.
.PP
.nf
{
  int i, n, array[10];

  if(!pattern || !factor) return; /* solid line */

  gl2psParseStipplePattern(pattern, factor, &n, array);
  gl2psPrintf('stroke-dasharray=\'');
  for(i = 0; i < n; i++){
    if(i) gl2psPrintf(',');
    gl2psPrintf('%d', array[i]);
  }
  gl2psPrintf('\' ');
}
.fi
.SS "static GLint \fBgl2psPrintSVGEndViewport\fP (void)\fC [static]\fP"
.PP
Definition at line 5295 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), and gl2psPrintPrimitives()\&.
.PP
.nf
{
  GLint res;

  res = gl2psPrintPrimitives();
  gl2psPrintf('</g>\n');
  return res;
}
.fi
.SS "static void \fBgl2psPrintSVGFinalPrimitive\fP (void)\fC [static]\fP"
.PP
Definition at line 5304 of file gl2ps\&.c\&.
.PP
References gl2psEndSVGLine()\&.
.PP
.nf
{
  /* End any remaining line, if any */
  gl2psEndSVGLine();
}
.fi
.SS "static void \fBgl2psPrintSVGFooter\fP (void)\fC [static]\fP"
.PP
Definition at line 5244 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), and gl2psPrintGzipFooter()\&.
.PP
.nf
{
  gl2psPrintf('</g>\n');
  gl2psPrintf('</svg>\n');  
  
  gl2psPrintGzipFooter();
}
.fi
.SS "static void \fBgl2psPrintSVGHeader\fP (void)\fC [static]\fP"
.PP
Definition at line 4976 of file gl2ps\&.c\&.
.PP
References GL2PScontext::bgcolor, GL2PS_COPYRIGHT, GL2PS_DRAW_BACKGROUND, GL2PS_EXTRA_VERSION, GL2PS_LANDSCAPE, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION, gl2psPrintf(), gl2psPrintGzipHeader(), gl2psSVGGetColorString(), GL2PScontext::options, GL2PScontext::producer, GL2PScontext::title, GL2PScontext::viewport, width, x, and y\&.
.PP
Referenced by gl2psPrintSVGBeginViewport()\&.
.PP
.nf
{
  int x, y, width, height;
  char col[32];
  time_t now;
  
  time(&now);
  
  if (gl2ps->options & GL2PS_LANDSCAPE){
    x = (int)gl2ps->viewport[1];
    y = (int)gl2ps->viewport[0];
    width = (int)gl2ps->viewport[3];
    height = (int)gl2ps->viewport[2];
  }
  else{
    x = (int)gl2ps->viewport[0];
    y = (int)gl2ps->viewport[1];
    width = (int)gl2ps->viewport[2];
    height = (int)gl2ps->viewport[3];
  }
  
  /* Compressed SVG files (\&.svgz) are simply gzipped SVG files */
  gl2psPrintGzipHeader();
  
  gl2psPrintf('<?xml version=\'1\&.0\' encoding=\'UTF-8\' standalone=\'no\'?>\n');
  gl2psPrintf('<svg xmlns=\'http://www\&.w3\&.org/2000/svg\'\n');
  gl2psPrintf('     xmlns:xlink=\'http://www\&.w3\&.org/1999/xlink\'\n'
              '     width=\'%dpx\' height=\'%dpx\' viewBox=\'%d %d %d %d\'>\n',
              width, height, x, y, width, height);
  gl2psPrintf('<title>%s</title>\n', gl2ps->title);
  gl2psPrintf('<desc>\n');
  gl2psPrintf('Creator: GL2PS %d\&.%d\&.%d%s, %s\n'
              'For: %s\n'
              'CreationDate: %s',
              GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION,
              GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT, gl2ps->producer, ctime(&now));
  gl2psPrintf('</desc>\n');
  gl2psPrintf('<defs>\n');
  gl2psPrintf('</defs>\n');

  if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
    gl2psSVGGetColorString(gl2ps->bgcolor, col);
    gl2psPrintf('<polygon fill=\'%s\' points=\'%d,%d %d,%d %d,%d %d,%d\'/>\n', col,
                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], 
                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1], 
                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
                (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
  }

  gl2psPrintf('<g>\n');
}
.fi
.SS "static void \fBgl2psPrintSVGPixmap\fP (GLfloatx, GLfloaty, \fBGL2PSimage\fP *pixmap)\fC [static]\fP"
.PP
Definition at line 5123 of file gl2ps\&.c\&.
.PP
References c, GL2PS_WARNING, gl2psListCreate(), gl2psListDelete(), gl2psListNbr(), gl2psMsg(), gl2psPrintf(), GL2PSimage::height, i, and GL2PSimage::width\&.
.PP
Referenced by gl2psPrintSVGPrimitive()\&.
.PP
.nf
{
#if defined(GL2PS_HAVE_LIBPNG)
  GL2PSlist *png;
  unsigned char c;
  int i;

  /* The only image types supported by the SVG standard are JPEG, PNG
     and SVG\&. Here we choose PNG, and since we want to embed the image
     directly in the SVG stream (and not link to an external image
     file), we need to encode the pixmap into PNG in memory, then
     encode it into base64\&. */

  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000, 
                        sizeof(unsigned char));
  gl2psConvertPixmapToPNG(pixmap, png);
  gl2psListEncodeBase64(png);
  gl2psPrintf('<image x=\'%g\' y=\'%g\' width=\'%d\' height=\'%d\'\n',
              x, y - pixmap->height, pixmap->width, pixmap->height);
  gl2psPrintf('xlink:href=\'data:image/png;base64,');
  for(i = 0; i < gl2psListNbr(png); i++){
    gl2psListRead(png, i, &c);
    gl2psPrintf('%c', c);
  }
  gl2psPrintf('\'/>\n');
  gl2psListDelete(png);
#else
  gl2psMsg(GL2PS_WARNING, 'GL2PS has to be compiled with PNG support in '
           'order to embed images in SVG streams');
#endif
}
.fi
.SS "static void \fBgl2psPrintSVGPrimitive\fP (void *data)\fC [static]\fP"
.PP
Definition at line 5155 of file gl2ps\&.c\&.
.PP
References GL2PSstring::alignment, GL2PSprimitive::culled, GL2PSprimitive::data, GL2PSprimitive::factor, GL2PSstring::fontname, GL2PSstring::fontsize, GL2PS_LINE, GL2PS_OCCLUSION_CULL, GL2PS_PIXMAP, GL2PS_POINT, GL2PS_QUADRANGLE, GL2PS_SPECIAL, GL2PS_SVG, GL2PS_TEXT, GL2PS_TRIANGLE, GL2PS_WARNING, gl2psEndSVGLine(), gl2psMsg(), gl2psPrintf(), gl2psPrintSVGDash(), gl2psPrintSVGPixmap(), gl2psPrintSVGSmoothTriangle(), gl2psSameColor(), gl2psSamePosition(), gl2psSetLastColor(), gl2psSVGGetColorString(), gl2psSVGGetCoordsAndColors(), GL2PSprimitive::image, GL2PScontext::lastfactor, GL2PScontext::lastlinewidth, GL2PScontext::lastpattern, GL2PScontext::lastrgba, GL2PScontext::lastvertex, GL2PSprimitive::numverts, GL2PScontext::options, GL2PSprimitive::pattern, GL2PSvertex::rgba, GL2PSstring::str, GL2PSprimitive::text, GL2PSprimitive::type, GL2PSprimitive::verts, GL2PSprimitive::width, and GL2PSvertex::xyz\&.
.PP
.nf
{
  GL2PSprimitive *prim;
  GL2PSxyz xyz[4];
  GL2PSrgba rgba[4];
  char col[32];
  int newline;

  prim = *(GL2PSprimitive**)data;

  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) return;

  /* We try to draw connected lines as a single path to get nice line
     joins and correct stippling\&. So if the primitive to print is not
     a line we must first finish the current line (if any): */
  if(prim->type != GL2PS_LINE) gl2psEndSVGLine();

  gl2psSVGGetCoordsAndColors(prim->numverts, prim->verts, xyz, rgba);

  switch(prim->type){
  case GL2PS_POINT :
    gl2psSVGGetColorString(rgba[0], col);
    gl2psPrintf('<circle fill=\'%s\' ', col);
    if(rgba[0][3] < 1\&.0F) gl2psPrintf('fill-opacity=\'%g\' ', rgba[0][3]);
    gl2psPrintf('cx=\'%g\' cy=\'%g\' r=\'%g\'/>\n',
                xyz[0][0], xyz[0][1], 0\&.5 * prim->width);
    break;
  case GL2PS_LINE :
    if(!gl2psSamePosition(gl2ps->lastvertex\&.xyz, prim->verts[0]\&.xyz) ||
       !gl2psSameColor(gl2ps->lastrgba, prim->verts[0]\&.rgba) ||
       gl2ps->lastlinewidth != prim->width ||
       gl2ps->lastpattern != prim->pattern ||
       gl2ps->lastfactor != prim->factor){
      /* End the current line if the new segment does not start where
         the last one ended, or if the color, the width or the
         stippling have changed (we will need to use multi-point
         gradients for smooth-shaded lines) */
      gl2psEndSVGLine();
      newline = 1;
    }
    else{
      newline = 0;
    }
    gl2ps->lastvertex = prim->verts[1];
    gl2psSetLastColor(prim->verts[0]\&.rgba);
    gl2ps->lastlinewidth = prim->width;
    gl2ps->lastpattern = prim->pattern;
    gl2ps->lastfactor = prim->factor;
    if(newline){
      gl2psSVGGetColorString(rgba[0], col);
      gl2psPrintf('<polyline fill=\'none\' stroke=\'%s\' stroke-width=\'%g\' ', 
                  col, prim->width);
      if(rgba[0][3] < 1\&.0F) gl2psPrintf('stroke-opacity=\'%g\' ', rgba[0][3]);
      gl2psPrintSVGDash(prim->pattern, prim->factor);
      gl2psPrintf('points=\'%g,%g ', xyz[0][0], xyz[0][1]);
    }
    else{
      gl2psPrintf('%g,%g ', xyz[0][0], xyz[0][1]);
    }
    break;
  case GL2PS_TRIANGLE :
    gl2psPrintSVGSmoothTriangle(xyz, rgba);
    break;
  case GL2PS_QUADRANGLE :
    gl2psMsg(GL2PS_WARNING, 'There should not be any quad left to print');
    break;
  case GL2PS_PIXMAP :
    gl2psPrintSVGPixmap(xyz[0][0], xyz[0][1], prim->data\&.image);
    break;
  case GL2PS_TEXT :
    gl2psSVGGetColorString(prim->verts[0]\&.rgba, col);
    gl2psPrintf('<text fill=\'%s\' x=\'%g\' y=\'%g\' '
                'font-size=\'%d\' font-family=\'%s\'>%s</text>\n',
                col, xyz[0][0], xyz[0][1],
                prim->data\&.text->fontsize,
                prim->data\&.text->fontname,
                prim->data\&.text->str);
    break;
  case GL2PS_SPECIAL :
    /* alignment contains the format for which the special output text
       is intended */
    if(prim->data\&.text->alignment == GL2PS_SVG)
      gl2psPrintf('%s\n', prim->data\&.text->str);
    break;
  default :
    break;
  }
}
.fi
.SS "static void \fBgl2psPrintSVGSmoothTriangle\fP (\fBGL2PSxyz\fPxyz[3], \fBGL2PSrgba\fPrgba[3])\fC [static]\fP"
.PP
Definition at line 5028 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), gl2psSameColorThreshold(), gl2psSVGGetColorString(), i, and GL2PScontext::threshold\&.
.PP
Referenced by gl2psPrintSVGPrimitive()\&.
.PP
.nf
{
  int i;
  GL2PSxyz xyz2[3];
  GL2PSrgba rgba2[3];
  char col[32];

  /* Apparently there is no easy way to do Gouraud shading in SVG
     without explicitly pre-defining gradients, so for now we just do
     recursive subdivision */

  if(gl2psSameColorThreshold(3, rgba, gl2ps->threshold)){
    gl2psSVGGetColorString(rgba[0], col);
    gl2psPrintf('<polygon fill=\'%s\' ', col);
    if(rgba[0][3] < 1\&.0F) gl2psPrintf('fill-opacity=\'%g\' ', rgba[0][3]);
    gl2psPrintf('points=\'%g,%g %g,%g %g,%g\'/>\n', xyz[0][0], xyz[0][1], 
                xyz[1][0], xyz[1][1], xyz[2][0], xyz[2][1]);
  }
  else{
    /* subdivide into 4 subtriangles */
    for(i = 0; i < 3; i++){
      xyz2[0][i] = xyz[0][i]; 
      xyz2[1][i] = 0\&.5 * (xyz[0][i] + xyz[1][i]);
      xyz2[2][i] = 0\&.5 * (xyz[0][i] + xyz[2][i]);
    }
    for(i = 0; i < 4; i++){
      rgba2[0][i] = rgba[0][i]; 
      rgba2[1][i] = 0\&.5 * (rgba[0][i] + rgba[1][i]);
      rgba2[2][i] = 0\&.5 * (rgba[0][i] + rgba[2][i]);
    }
    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
    for(i = 0; i < 3; i++){
      xyz2[0][i] = 0\&.5 * (xyz[0][i] + xyz[1][i]);
      xyz2[1][i] = xyz[1][i]; 
      xyz2[2][i] = 0\&.5 * (xyz[1][i] + xyz[2][i]);
    }
    for(i = 0; i < 4; i++){
      rgba2[0][i] = 0\&.5 * (rgba[0][i] + rgba[1][i]);
      rgba2[1][i] = rgba[1][i]; 
      rgba2[2][i] = 0\&.5 * (rgba[1][i] + rgba[2][i]);
    }
    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
    for(i = 0; i < 3; i++){
      xyz2[0][i] = 0\&.5 * (xyz[0][i] + xyz[2][i]);
      xyz2[1][i] = xyz[2][i]; 
      xyz2[2][i] = 0\&.5 * (xyz[1][i] + xyz[2][i]);
    }
    for(i = 0; i < 4; i++){
      rgba2[0][i] = 0\&.5 * (rgba[0][i] + rgba[2][i]);
      rgba2[1][i] = rgba[2][i]; 
      rgba2[2][i] = 0\&.5 * (rgba[1][i] + rgba[2][i]);
    }
    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
    for(i = 0; i < 3; i++){
      xyz2[0][i] = 0\&.5 * (xyz[0][i] + xyz[1][i]);
      xyz2[1][i] = 0\&.5 * (xyz[1][i] + xyz[2][i]); 
      xyz2[2][i] = 0\&.5 * (xyz[0][i] + xyz[2][i]);
    }
    for(i = 0; i < 4; i++){
      rgba2[0][i] = 0\&.5 * (rgba[0][i] + rgba[1][i]);
      rgba2[1][i] = 0\&.5 * (rgba[1][i] + rgba[2][i]); 
      rgba2[2][i] = 0\&.5 * (rgba[0][i] + rgba[2][i]);
    }
    gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
  }
}
.fi
.SS "static void \fBgl2psPrintTeXBeginViewport\fP (GLintviewport[4])\fC [static]\fP"
.PP
Definition at line 3443 of file gl2ps\&.c\&.
.PP
References gl2psPrintTeXHeader(), and GL2PScontext::header\&.
.PP
.nf
{
  glRenderMode(GL_FEEDBACK);
  
  if(gl2ps->header){
    gl2psPrintTeXHeader();
    gl2ps->header = GL_FALSE;
  }
}
.fi
.SS "static GLint \fBgl2psPrintTeXEndViewport\fP (void)\fC [static]\fP"
.PP
Definition at line 3453 of file gl2ps\&.c\&.
.PP
References gl2psPrintPrimitives()\&.
.PP
.nf
{
  return gl2psPrintPrimitives();
}
.fi
.SS "static void \fBgl2psPrintTeXFinalPrimitive\fP (void)\fC [static]\fP"
.PP
Definition at line 3458 of file gl2ps\&.c\&.
.PP
.nf
{
}
.fi
.SS "static void \fBgl2psPrintTeXFooter\fP (void)\fC [static]\fP"
.PP
Definition at line 3437 of file gl2ps\&.c\&.
.PP
References GL2PS_LANDSCAPE, GL2PScontext::options, and GL2PScontext::stream\&.
.PP
.nf
{
  fprintf(gl2ps->stream, '\\end{picture}%s\n',
          (gl2ps->options & GL2PS_LANDSCAPE) ? '}' : '');
}
.fi
.SS "static void \fBgl2psPrintTeXHeader\fP (void)\fC [static]\fP"
.PP
Definition at line 3334 of file gl2ps\&.c\&.
.PP
References GL2PScontext::filename, GL2PS_COPYRIGHT, GL2PS_EXTRA_VERSION, GL2PS_LANDSCAPE, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, GL2PS_PATCH_VERSION, i, GL2PScontext::options, GL2PScontext::producer, GL2PScontext::stream, GL2PScontext::title, and GL2PScontext::viewport\&.
.PP
Referenced by gl2psPrintTeXBeginViewport()\&.
.PP
.nf
{
  char name[256];
  time_t now;
  int i;

  if(gl2ps->filename && strlen(gl2ps->filename) < 256){
    for(i = strlen(gl2ps->filename)-1; i >= 0; i--){
      if(gl2ps->filename[i] == '\&.'){
        strncpy(name, gl2ps->filename, i);
        name[i] = '\0';
        break;
      }
    }
    if(i <= 0) strcpy(name, gl2ps->filename);
  }
  else{
    strcpy(name, 'untitled');
  }

  time(&now);

  fprintf(gl2ps->stream, 
          '%% Title: %s\n'
          '%% Creator: GL2PS %d\&.%d\&.%d%s, %s\n'
          '%% For: %s\n'
          '%% CreationDate: %s',
          gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
          GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
          gl2ps->producer, ctime(&now));

  fprintf(gl2ps->stream, 
          '\\setlength{\\unitlength}{1pt}\n'
          '\\begin{picture}(0,0)\n'
          '\\includegraphics{%s}\n'
          '\\end{picture}%%\n'
          '%s\\begin{picture}(%d,%d)(0,0)\n',
          name, (gl2ps->options & GL2PS_LANDSCAPE) ? '\\rotatebox{90}{' : '',
          (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
}
.fi
.SS "static void \fBgl2psPrintTeXPrimitive\fP (void *data)\fC [static]\fP"
.PP
Definition at line 3375 of file gl2ps\&.c\&.
.PP
References GL2PSstring::alignment, GL2PSstring::angle, GL2PSprimitive::data, GL2PSstring::fontsize, GL2PS_SPECIAL, GL2PS_TEX, GL2PS_TEXT, GL2PS_TEXT_B, GL2PS_TEXT_BL, GL2PS_TEXT_BR, GL2PS_TEXT_C, GL2PS_TEXT_CL, GL2PS_TEXT_CR, GL2PS_TEXT_T, GL2PS_TEXT_TL, GL2PS_TEXT_TR, GL2PSvertex::rgba, GL2PSstring::str, GL2PScontext::stream, GL2PSprimitive::text, GL2PSprimitive::type, GL2PSprimitive::verts, and GL2PSvertex::xyz\&.
.PP
.nf
{
  GL2PSprimitive *prim;

  prim = *(GL2PSprimitive**)data;

  switch(prim->type){
  case GL2PS_TEXT :
    fprintf(gl2ps->stream, '\\fontsize{%d}{0}\n\\selectfont', 
            prim->data\&.text->fontsize);
    fprintf(gl2ps->stream, '\\put(%g,%g){\\makebox(0,0)',
            prim->verts[0]\&.xyz[0], prim->verts[0]\&.xyz[1]);
    switch(prim->data\&.text->alignment){
    case GL2PS_TEXT_C:
      fprintf(gl2ps->stream, '{');
      break;
    case GL2PS_TEXT_CL:
      fprintf(gl2ps->stream, '[l]{');
      break;
    case GL2PS_TEXT_CR:
      fprintf(gl2ps->stream, '[r]{');
      break;
    case GL2PS_TEXT_B:
      fprintf(gl2ps->stream, '[b]{');
      break;
    case GL2PS_TEXT_BR:
      fprintf(gl2ps->stream, '[br]{');
      break;
    case GL2PS_TEXT_T:
      fprintf(gl2ps->stream, '[t]{');
      break;
    case GL2PS_TEXT_TL:
      fprintf(gl2ps->stream, '[tl]{');
      break;
    case GL2PS_TEXT_TR:
      fprintf(gl2ps->stream, '[tr]{');
      break;
    case GL2PS_TEXT_BL:
    default:
      fprintf(gl2ps->stream, '[bl]{');
      break;
    }
    if(prim->data\&.text->angle)
      fprintf(gl2ps->stream, '\\rotatebox{%g}{', prim->data\&.text->angle);
    fprintf(gl2ps->stream, '\\textcolor[rgb]{%g,%g,%g}{{%s}}',
            prim->verts[0]\&.rgba[0], prim->verts[0]\&.rgba[1], prim->verts[0]\&.rgba[2],
            prim->data\&.text->str);
    if(prim->data\&.text->angle)
      fprintf(gl2ps->stream, '}');
    fprintf(gl2ps->stream, '}}\n');
    break;
  case GL2PS_SPECIAL :
    /* alignment contains the format for which the special output text
       is intended */
    if (prim->data\&.text->alignment == GL2PS_TEX)
      fprintf(gl2ps->stream, '%s\n', prim->data\&.text->str);
    break;
  default :
    break;
  }
}
.fi
.SS "static GLfloat \fBgl2psPsca\fP (GLfloat *a, GLfloat *b)\fC [static]\fP"
.PP
Definition at line 1129 of file gl2ps\&.c\&.
.PP
Referenced by gl2psCutEdge()\&.
.PP
.nf
{
  return(a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
}
.fi
.SS "static void \fBgl2psPutPDFImage\fP (\fBGL2PSimage\fP *image, intcnt, GLfloatx, GLfloaty)\fC [static]\fP"
.PP
Definition at line 3545 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), GL2PSimage::height, GL2PScontext::streamlength, and GL2PSimage::width\&.
.PP
Referenced by gl2psPDFgroupListWriteMainStream()\&.
.PP
.nf
{
  gl2ps->streamlength += 
    gl2psPrintf('q\n'
                '%d 0 0 %d %f %f cm\n'
                '/Im%d Do\n'
                'Q\n',
                (int)image->width, (int)image->height, x, y, cnt);
}
.fi
.SS "static void \fBgl2psPutPDFText\fP (\fBGL2PSstring\fP *text, intcnt, GLfloatx, GLfloaty)\fC [static]\fP"
.PP
Definition at line 3534 of file gl2ps\&.c\&.
.PP
References GL2PSstring::fontsize, gl2psPrintf(), GL2PSstring::str, and GL2PScontext::streamlength\&.
.PP
Referenced by gl2psPDFgroupListWriteMainStream()\&.
.PP
.nf
{
  gl2ps->streamlength += 
    gl2psPrintf('BT\n'
                '/F%d %d Tf\n'
                '%f %f Td\n'
                '(%s) Tj\n'
                'ET\n', 
                cnt, text->fontsize, x, y, text->str);  
}
.fi
.SS "static void \fBgl2psPvec\fP (GLfloat *a, GLfloat *b, GLfloat *c)\fC [static]\fP"
.PP
Definition at line 1134 of file gl2ps\&.c\&.
.PP
Referenced by gl2psGetNormal()\&.
.PP
.nf
{
  c[0] = a[1]*b[2] - a[2]*b[1];
  c[1] = a[2]*b[0] - a[0]*b[2];
  c[2] = a[0]*b[1] - a[1]*b[0];
}
.fi
.SS "static void* \fBgl2psRealloc\fP (void *ptr, size_tsize)\fC [static]\fP"
.PP
Definition at line 336 of file gl2ps\&.c\&.
.PP
References GL2PS_ERROR, and gl2psMsg()\&.
.PP
Referenced by gl2psListRealloc(), gl2psPrintPDFFooter(), and gl2psSplitPrimitive2D()\&.
.PP
.nf
{
  if(!size) return(NULL);
  ptr = realloc(ptr, size);
  if(!ptr){
    gl2psMsg(GL2PS_ERROR, 'Couldn't reallocate requested memory');
    exit(1);
  }
  return(ptr);
}
.fi
.SS "static void \fBgl2psRescaleAndOffset\fP ()\fC [static]\fP"
.PP
Definition at line 1685 of file gl2ps\&.c\&.
.PP
References GL2PS_LINE, GL2PS_SIMPLE_LINE_OFFSET, GL2PS_SIMPLE_SORT, GL2PS_TRIANGLE, GL2PS_ZERO, GL2PS_ZOFFSET, GL2PS_ZOFFSET_LARGE, GL2PS_ZSCALE, gl2psListNbr(), gl2psListPointer(), i, GL2PSprimitive::numverts, GL2PSprimitive::offset, GL2PScontext::offset, GL2PScontext::options, GL2PScontext::primitives, GL2PScontext::sort, GL2PSprimitive::type, GL2PSprimitive::verts, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  GL2PSprimitive *prim;
  GLfloat minZ, maxZ, rangeZ, scaleZ;
  GLfloat factor, units, area, dZ, dZdX, dZdY, maxdZ;
  int i, j;

  if(!gl2psListNbr(gl2ps->primitives))
    return;

  /* get z-buffer range */
  prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, 0);
  minZ = maxZ = prim->verts[0]\&.xyz[2];
  for(i = 1; i < prim->numverts; i++){
    if(prim->verts[i]\&.xyz[2] < minZ) minZ = prim->verts[i]\&.xyz[2];
    if(prim->verts[i]\&.xyz[2] > maxZ) maxZ = prim->verts[i]\&.xyz[2];
  }
  for(i = 1; i < gl2psListNbr(gl2ps->primitives); i++){
    prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, i);
    for(j = 0; j < prim->numverts; j++){
      if(prim->verts[j]\&.xyz[2] < minZ) minZ = prim->verts[j]\&.xyz[2];
      if(prim->verts[j]\&.xyz[2] > maxZ) maxZ = prim->verts[j]\&.xyz[2];
    }
  }
  rangeZ = (maxZ - minZ);

  /* rescale z-buffer coordinate in [0,GL2PS_ZSCALE], to make it of
     the same order of magnitude as the x and y coordinates */
  scaleZ = GL2PS_ZERO(rangeZ) ? GL2PS_ZSCALE : (GL2PS_ZSCALE / rangeZ);
  /* avoid precision loss (we use floats!) */
  if(scaleZ > 100000\&.F) scaleZ = 100000\&.F;

  /* apply offsets */
  for(i = 0; i < gl2psListNbr(gl2ps->primitives); i++){
    prim = *(GL2PSprimitive**)gl2psListPointer(gl2ps->primitives, i);
    for(j = 0; j < prim->numverts; j++){
      prim->verts[j]\&.xyz[2] = (prim->verts[j]\&.xyz[2] - minZ) * scaleZ;
    }
    if((gl2ps->options & GL2PS_SIMPLE_LINE_OFFSET) &&
       (prim->type == GL2PS_LINE)){
      if(gl2ps->sort == GL2PS_SIMPLE_SORT){
        prim->verts[0]\&.xyz[2] -= GL2PS_ZOFFSET_LARGE;
        prim->verts[1]\&.xyz[2] -= GL2PS_ZOFFSET_LARGE;
      }
      else{
        prim->verts[0]\&.xyz[2] -= GL2PS_ZOFFSET;
        prim->verts[1]\&.xyz[2] -= GL2PS_ZOFFSET;
      }
    }
    else if(prim->offset && (prim->type == GL2PS_TRIANGLE)){
      factor = gl2ps->offset[0];
      units = gl2ps->offset[1];
      area = 
        (prim->verts[1]\&.xyz[0] - prim->verts[0]\&.xyz[0]) * 
        (prim->verts[2]\&.xyz[1] - prim->verts[1]\&.xyz[1]) - 
        (prim->verts[2]\&.xyz[0] - prim->verts[1]\&.xyz[0]) * 
        (prim->verts[1]\&.xyz[1] - prim->verts[0]\&.xyz[1]);
      dZdX = 
        ((prim->verts[2]\&.xyz[1] - prim->verts[1]\&.xyz[1]) *
         (prim->verts[1]\&.xyz[2] - prim->verts[0]\&.xyz[2]) -
         (prim->verts[1]\&.xyz[1] - prim->verts[0]\&.xyz[1]) *
         (prim->verts[2]\&.xyz[2] - prim->verts[1]\&.xyz[2])) / area;
      dZdY = 
        ((prim->verts[1]\&.xyz[0] - prim->verts[0]\&.xyz[0]) *
         (prim->verts[2]\&.xyz[2] - prim->verts[1]\&.xyz[2]) -
         (prim->verts[2]\&.xyz[0] - prim->verts[1]\&.xyz[0]) *
         (prim->verts[1]\&.xyz[2] - prim->verts[0]\&.xyz[2])) / area;
      maxdZ = (GLfloat)sqrt(dZdX * dZdX + dZdY * dZdY);
      dZ = factor * maxdZ + units;
      prim->verts[0]\&.xyz[2] += dZ;
      prim->verts[1]\&.xyz[2] += dZ;
      prim->verts[2]\&.xyz[2] += dZ;
    }
  }
}
.fi
.SS "static void \fBgl2psResetPostScriptColor\fP (void)\fC [static]\fP"
.PP
Definition at line 2988 of file gl2ps\&.c\&.
.PP
References GL2PScontext::lastrgba\&.
.PP
Referenced by gl2psPrintPostScriptPrimitive()\&.
.PP
.nf
{
  gl2ps->lastrgba[0] = gl2ps->lastrgba[1] = gl2ps->lastrgba[2] = -1\&.;
}
.fi
.SS "static GLboolean \fBgl2psSameColor\fP (\fBGL2PSrgba\fPrgba1, \fBGL2PSrgba\fPrgba2)\fC [static]\fP"
.PP
Definition at line 696 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO\&.
.PP
Referenced by gl2psPDFgroupListInit(), gl2psPrintPGFColor(), gl2psPrintPostScriptColor(), gl2psPrintPostScriptPrimitive(), gl2psPrintSVGPrimitive(), and gl2psVertsSameColor()\&.
.PP
.nf
{
  if(!GL2PS_ZERO(rgba1[0] - rgba2[0]) ||
     !GL2PS_ZERO(rgba1[1] - rgba2[1]) ||
     !GL2PS_ZERO(rgba1[2] - rgba2[2]))
    return GL_FALSE;
  return GL_TRUE;
}
.fi
.SS "static GLboolean \fBgl2psSameColorThreshold\fP (intn, \fBGL2PSrgba\fPrgba[], \fBGL2PSrgba\fPthreshold)\fC [static]\fP"
.PP
Definition at line 717 of file gl2ps\&.c\&.
.PP
References i, and n\&.
.PP
Referenced by gl2psPrintSVGSmoothTriangle()\&.
.PP
.nf
{
  int i;

  if(n < 2) return GL_TRUE;
  
  for(i = 1; i < n; i++){
    if(fabs(rgba[0][0] - rgba[i][0]) > threshold[0] ||
       fabs(rgba[0][1] - rgba[i][1]) > threshold[1] ||
       fabs(rgba[0][2] - rgba[i][2]) > threshold[2])
      return GL_FALSE;
  }
  
  return GL_TRUE;
}
.fi
.SS "static GLboolean \fBgl2psSamePosition\fP (\fBGL2PSxyz\fPp1, \fBGL2PSxyz\fPp2)\fC [static]\fP"
.PP
Definition at line 1106 of file gl2ps\&.c\&.
.PP
References GL2PS_ZERO\&.
.PP
Referenced by gl2psPDFgroupListWriteMainStream(), gl2psPrintPostScriptPrimitive(), and gl2psPrintSVGPrimitive()\&.
.PP
.nf
{
  if(!GL2PS_ZERO(p1[0] - p2[0]) ||
     !GL2PS_ZERO(p1[1] - p2[1]) ||
     !GL2PS_ZERO(p1[2] - p2[2]))
    return GL_FALSE;
  return GL_TRUE;
}
.fi
.SS "static void \fBgl2psSetLastColor\fP (\fBGL2PSrgba\fPrgba)\fC [static]\fP"
.PP
Definition at line 734 of file gl2ps\&.c\&.
.PP
References i, and GL2PScontext::lastrgba\&.
.PP
Referenced by gl2psPrintPDFStrokeColor(), gl2psPrintPGFColor(), gl2psPrintPostScriptColor(), and gl2psPrintSVGPrimitive()\&.
.PP
.nf
{
  int i;        
  for(i = 0; i < 3; ++i){
    gl2ps->lastrgba[i] = rgba[i];
  }
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psSetOptions\fP (GLintoptions)"
.PP
Definition at line 6101 of file gl2ps\&.c\&.
.PP
References GL2PS_SUCCESS, GL2PS_UNINITIALIZED, and GL2PScontext::options\&.
.PP
.nf
{
  if(!gl2ps) return GL2PS_UNINITIALIZED;

  gl2ps->options = options;

  return GL2PS_SUCCESS;
}
.fi
.SS "static void \fBgl2psSortOutTrianglePDFgroup\fP (\fBGL2PSpdfgroup\fP *gro)\fC [static]\fP"
.PP
Definition at line 3675 of file gl2ps\&.c\&.
.PP
References GL2PScontext::extgs_stack, GL2PS_TRIANGLE, gl2psFillTriangleFromPrimitive(), gl2psListNbr(), gl2psListPointer(), GL2PSpdfgroup::gsno, GL2PSpdfgroup::gsobjno, GL2PSpdfgroup::maskshno, GL2PSpdfgroup::maskshobjno, GL2PScontext::mshader_stack, GL2PScontext::objects_stack, GL2PStriangle::prop, GL2PSpdfgroup::ptrlist, GL2PScontext::shader_stack, GL2PSpdfgroup::shno, GL2PSpdfgroup::shobjno, t, T_ALPHA_1, T_ALPHA_LESS_1, T_CONST_COLOR, T_VAR_ALPHA, T_VAR_COLOR, GL2PSpdfgroup::trgroupno, GL2PScontext::trgroupobjects_stack, GL2PSpdfgroup::trgroupobjno, and GL2PSprimitive::type\&.
.PP
Referenced by gl2psPDFgroupListWriteMainStream()\&.
.PP
.nf
{
  GL2PStriangle t;
  GL2PSprimitive *prim = NULL;
  
  if(!gro)
    return;

  if(!gl2psListNbr(gro->ptrlist))
    return;

  prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);

  if(prim->type != GL2PS_TRIANGLE)
    return;

  gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
  
  if(t\&.prop & T_CONST_COLOR && t\&.prop & T_ALPHA_LESS_1){        
    gro->gsno = gl2ps->extgs_stack++; 
    gro->gsobjno = gl2ps->objects_stack ++;
  }
  else if(t\&.prop & T_CONST_COLOR && t\&.prop & T_VAR_ALPHA){              
    gro->gsno = gl2ps->extgs_stack++;
    gro->gsobjno = gl2ps->objects_stack++;
    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
    gro->trgroupobjno = gl2ps->objects_stack++;
    gro->maskshno = gl2ps->mshader_stack++;
    gro->maskshobjno = gl2ps->objects_stack++;
  }
  else if(t\&.prop & T_VAR_COLOR && t\&.prop & T_ALPHA_1){          
    gro->shno = gl2ps->shader_stack++;
    gro->shobjno = gl2ps->objects_stack++;
  }
  else if(t\&.prop & T_VAR_COLOR && t\&.prop & T_ALPHA_LESS_1){             
    gro->gsno = gl2ps->extgs_stack++;
    gro->gsobjno = gl2ps->objects_stack++;
    gro->shno = gl2ps->shader_stack++; 
    gro->shobjno = gl2ps->objects_stack++;
  }
  else if(t\&.prop & T_VAR_COLOR && t\&.prop & T_VAR_ALPHA){                
    gro->gsno = gl2ps->extgs_stack++;
    gro->gsobjno = gl2ps->objects_stack++;
    gro->shno = gl2ps->shader_stack++; 
    gro->shobjno = gl2ps->objects_stack++;
    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
    gro->trgroupobjno = gl2ps->objects_stack++;
    gro->maskshno = gl2ps->mshader_stack++;
    gro->maskshobjno = gl2ps->objects_stack++;
  }
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psSpecial\fP (GLintformat, const char *str, intmoveTo)"
.PP
Definition at line 5896 of file gl2ps\&.c\&.
.PP
References GL2PS_SPECIAL, and gl2psAddText()\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psSpecial()\&.
.PP
.nf
{
  return gl2psAddText(GL2PS_SPECIAL, str, '', (moveTo ? 1 : 0), format, 0\&.0F, 0\&.0F, GL_FALSE,
      0, NULL, 0, 0, NULL);
}
.fi
.SS "static GLint \fBgl2psSplitPrimitive\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fPplane, \fBGL2PSprimitive\fP **front, \fBGL2PSprimitive\fP **back)\fC [static]\fP"
.PP
Definition at line 1345 of file gl2ps\&.c\&.
.PP
References d, GL2PS_COINCIDENT, GL2PS_EPSILON, GL2PS_IN_BACK_OF, GL2PS_IN_FRONT_OF, GL2PS_POINT, GL2PS_SPANNING, gl2psAddIndex(), gl2psComparePointPlane(), gl2psCreateSplitPrimitive(), gl2psGetIndex(), gl2psMalloc(), i, GL2PSprimitive::numverts, type, GL2PSprimitive::type, GL2PSprimitive::verts, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psBuildBspTree()\&.
.PP
.nf
{
  GLshort i, j, in = 0, out = 0, in0[5], in1[5], out0[5], out1[5];
  GLint type;
  GLfloat d[5]; 

  type = GL2PS_COINCIDENT;

  for(i = 0; i < prim->numverts; i++){  
    d[i] = gl2psComparePointPlane(prim->verts[i]\&.xyz, plane);
  }

  switch(prim->type){
  case GL2PS_POINT :
    if(d[0] > GL2PS_EPSILON)       type = GL2PS_IN_BACK_OF;
    else if(d[0] < -GL2PS_EPSILON) type = GL2PS_IN_FRONT_OF;
    else                           type = GL2PS_COINCIDENT;
    break;
  default :
    for(i = 0; i < prim->numverts; i++){
      j = gl2psGetIndex(i, prim->numverts);
      if(d[j] > GL2PS_EPSILON){
        if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING; 
        if(d[i] < -GL2PS_EPSILON){
          gl2psAddIndex(in0, in1, &in, i, j);
          gl2psAddIndex(out0, out1, &out, i, j);
          type = GL2PS_SPANNING;
        }
        gl2psAddIndex(out0, out1, &out, j, -1);
      }
      else if(d[j] < -GL2PS_EPSILON){
        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
        else if(type != GL2PS_IN_FRONT_OF) type = GL2PS_SPANNING;
        if(d[i] > GL2PS_EPSILON){
          gl2psAddIndex(in0, in1, &in, i, j);
          gl2psAddIndex(out0, out1, &out, i, j);
          type = GL2PS_SPANNING;
        }
        gl2psAddIndex(in0, in1, &in, j, -1);
      }
      else{
        gl2psAddIndex(in0, in1, &in, j, -1);
        gl2psAddIndex(out0, out1, &out, j, -1);
      }
    }
    break;
  }

  if(type == GL2PS_SPANNING){
    *back = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
    *front = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
    gl2psCreateSplitPrimitive(prim, plane, *back, out, out0, out1);
    gl2psCreateSplitPrimitive(prim, plane, *front, in, in0, in1);
  }

  return type;
}
.fi
.SS "static void \fBgl2psSplitPrimitive2D\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fPplane, \fBGL2PSprimitive\fP **front, \fBGL2PSprimitive\fP **back)\fC [static]\fP"
.PP
Definition at line 1958 of file gl2ps\&.c\&.
.PP
References GL2PS_POINT_BACK, GL2PS_POINT_INFRONT, gl2psCheckPoint(), gl2psCreateSplitPrimitive2D(), gl2psCutEdge(), gl2psFree(), gl2psRealloc(), i, GL2PSprimitive::numverts, GL2PSprimitive::verts, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psAddInBspImageTree()\&.
.PP
.nf
{
  /* cur will hold the position of the current vertex
     prev will hold the position of the previous vertex
     prev0 will hold the position of the vertex number 0
     v1 and v2 represent the current and previous vertices, respectively
     flag is set if the current vertex should be checked against the plane */
  GLint cur = -1, prev = -1, i, v1 = 0, v2 = 0, flag = 1, prev0 = -1;
  
  /* list of vertices that will go in front and back primitive */
  GL2PSvertex *front_list = NULL, *back_list = NULL;
  
  /* number of vertices in front and back list */
  GLshort front_count = 0, back_count = 0;

  for(i = 0; i <= prim->numverts; i++){
    v1 = i;
    if(v1 == prim->numverts){
      if(prim->numverts < 3) break;
      v1 = 0;
      v2 = prim->numverts-1;
      cur = prev0;
    }
    else if(flag){
      cur = gl2psCheckPoint(prim->verts[v1]\&.xyz, plane);
      if(i == 0){
        prev0 = cur;
      }
    } 
    if(((prev == -1) || (prev == cur) || (prev == 0) || (cur == 0)) &&
       (i < prim->numverts)){
      if(cur == GL2PS_POINT_INFRONT){
        front_count++;
        front_list = (GL2PSvertex*)gl2psRealloc(front_list,
                                                sizeof(GL2PSvertex)*front_count);
        front_list[front_count-1] = prim->verts[v1];
      }
      else if(cur == GL2PS_POINT_BACK){
        back_count++;
        back_list = (GL2PSvertex*)gl2psRealloc(back_list,
                                               sizeof(GL2PSvertex)*back_count);
        back_list[back_count-1] = prim->verts[v1];
      }
      else{
        front_count++;
        front_list = (GL2PSvertex*)gl2psRealloc(front_list,
                                                sizeof(GL2PSvertex)*front_count);
        front_list[front_count-1] = prim->verts[v1];
        back_count++;
        back_list = (GL2PSvertex*)gl2psRealloc(back_list,
                                               sizeof(GL2PSvertex)*back_count);
        back_list[back_count-1] = prim->verts[v1];
      }
      flag = 1;
    }
    else if((prev != cur) && (cur != 0) && (prev != 0)){
      if(v1 != 0){
        v2 = v1-1;
        i--;
      }
      front_count++;
      front_list = (GL2PSvertex*)gl2psRealloc(front_list,
                                              sizeof(GL2PSvertex)*front_count);
      gl2psCutEdge(&prim->verts[v2],
                   &prim->verts[v1],
                   plane,
                   &front_list[front_count-1]);
      back_count++;
      back_list = (GL2PSvertex*)gl2psRealloc(back_list,
                                             sizeof(GL2PSvertex)*back_count);
      back_list[back_count-1] = front_list[front_count-1];
      flag = 0;
    }
    prev = cur;
  }
  *front = gl2psCreateSplitPrimitive2D(prim, front_count, front_list);
  *back = gl2psCreateSplitPrimitive2D(prim, back_count, back_list);
  gl2psFree(front_list);
  gl2psFree(back_list);
}
.fi
.SS "static GLboolean \fBgl2psSupportedBlendMode\fP (GLenumsfactor, GLenumdfactor)\fC [static]\fP"
.PP
Definition at line 980 of file gl2ps\&.c\&.
.PP
Referenced by gl2psBlendFunc()\&.
.PP
.nf
{
  /* returns TRUE if gl2ps supports the argument combination: only two
     blending modes have been implemented so far */

  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) || 
      (sfactor == GL_ONE && dfactor == GL_ZERO) )
    return GL_TRUE;
  return GL_FALSE;
}
.fi
.SS "static void \fBgl2psSVGGetColorString\fP (\fBGL2PSrgba\fPrgba, charstr[32])\fC [static]\fP"
.PP
Definition at line 4965 of file gl2ps\&.c\&.
.PP
Referenced by gl2psPrintSVGBeginViewport(), gl2psPrintSVGHeader(), gl2psPrintSVGPrimitive(), and gl2psPrintSVGSmoothTriangle()\&.
.PP
.nf
{
  int r = (int)(255\&. * rgba[0]);
  int g = (int)(255\&. * rgba[1]);
  int b = (int)(255\&. * rgba[2]);
  int rc = (r < 0) ? 0 : (r > 255) ? 255 : r;
  int gc = (g < 0) ? 0 : (g > 255) ? 255 : g;
  int bc = (b < 0) ? 0 : (b > 255) ? 255 : b;
  sprintf(str, '#%2\&.2x%2\&.2x%2\&.2x', rc, gc, bc);
}
.fi
.SS "static void \fBgl2psSVGGetCoordsAndColors\fP (intn, \fBGL2PSvertex\fP *verts, \fBGL2PSxyz\fP *xyz, \fBGL2PSrgba\fP *rgba)\fC [static]\fP"
.PP
Definition at line 4951 of file gl2ps\&.c\&.
.PP
References i, n, GL2PScontext::viewport, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psPrintSVGPrimitive()\&.
.PP
.nf
{
  int i, j;

  for(i = 0; i < n; i++){
    xyz[i][0] = verts[i]\&.xyz[0];
    xyz[i][1] = gl2ps->viewport[3] - verts[i]\&.xyz[1];
    xyz[i][2] = 0\&.0F;
    for(j = 0; j < 4; j++)
      rgba[i][j] = verts[i]\&.rgba[j];
  }
}
.fi
.SS "static GLint \fBgl2psTestSplitPrimitive\fP (\fBGL2PSprimitive\fP *prim, \fBGL2PSplane\fPplane)\fC [static]\fP"
.PP
Definition at line 1314 of file gl2ps\&.c\&.
.PP
References d, GL2PS_COINCIDENT, GL2PS_EPSILON, GL2PS_IN_BACK_OF, GL2PS_IN_FRONT_OF, gl2psComparePointPlane(), gl2psGetIndex(), i, GL2PSprimitive::numverts, type, GL2PSprimitive::verts, and GL2PSvertex::xyz\&.
.PP
Referenced by gl2psFindRoot()\&.
.PP
.nf
{
  GLint type = GL2PS_COINCIDENT;
  GLshort i, j;
  GLfloat d[5]; 

  for(i = 0; i < prim->numverts; i++){  
    d[i] = gl2psComparePointPlane(prim->verts[i]\&.xyz, plane);
  }

  if(prim->numverts < 2){
    return 0;
  }
  else{
    for(i = 0; i < prim->numverts; i++){
      j = gl2psGetIndex(i, prim->numverts);
      if(d[j] > GL2PS_EPSILON){
        if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
        else if(type != GL2PS_IN_BACK_OF) return 1; 
        if(d[i] < -GL2PS_EPSILON)         return 1;
      }
      else if(d[j] < -GL2PS_EPSILON){
        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
        else if(type != GL2PS_IN_FRONT_OF) return 1;
        if(d[i] > GL2PS_EPSILON)           return 1;
      }
    }
  }
  return 0;
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psText\fP (const char *str, const char *fontname, GLshortfontsize)"
.PP
Definition at line 5890 of file gl2ps\&.c\&.
.PP
References GL2PS_TEXT, GL2PS_TEXT_BL, and gl2psAddText()\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psText()\&.
.PP
.nf
{
  return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, GL2PS_TEXT_BL, 0\&.0F, 0\&.0F, GL_FALSE,
      0, NULL, 0, 0, NULL);
}
.fi
.SS "\fBGL2PSDLL_API\fP GLint \fBgl2psTextOpt\fP (const char *str, const char *fontname, GLshortfontsize, GLintalignment, GLfloatangle, GLfloatmargin, GLbooleanoffsetmargin, GLfloatlwidth, \fBGL2PSrgba\fPlc, GLushortlpattern, GLintlfactor, \fBGL2PSrgba\fPfc)"
.PP
Definition at line 5881 of file gl2ps\&.c\&.
.PP
References GL2PS_TEXT, and gl2psAddText()\&.
.PP
Referenced by Java_org_octave_graphics_GL2PS_gl2psTextOpt()\&.
.PP
.nf
{
  return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, alignment, angle, margin, offsetmargin,
      lwidth, lc, lpattern, lfactor, fc);
}
.fi
.SS "static void \fBgl2psTraverseBspTree\fP (\fBGL2PSbsptree\fP *tree, \fBGL2PSxyz\fPeye, GLfloatepsilon, GLboolean(*)(GLfloat f1, GLfloat f2)compare, void(*)(void *data)action, intinverse)\fC [static]\fP"
.PP
Definition at line 1649 of file gl2ps\&.c\&.
.PP
References _GL2PSbsptree::back, _GL2PSbsptree::front, gl2psComparePointPlane(), gl2psListAction(), gl2psListActionInverse(), _GL2PSbsptree::plane, and _GL2PSbsptree::primitives\&.
.PP
Referenced by gl2psPrintPrimitives()\&.
.PP
.nf
{
  GLfloat result;

  if(!tree) return;

  result = gl2psComparePointPlane(eye, tree->plane);

  if(GL_TRUE == compare(result, epsilon)){
    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
    if(inverse){
      gl2psListActionInverse(tree->primitives, action);
    }
    else{
      gl2psListAction(tree->primitives, action);
    }
    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
  }
  else if(GL_TRUE == compare(-epsilon, result)){ 
    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
    if(inverse){
      gl2psListActionInverse(tree->primitives, action);
    }
    else{
      gl2psListAction(tree->primitives, action);
    }
    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
  }
  else{
    gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
    gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
  }
}
.fi
.SS "static int \fBgl2psTrianglesFirst\fP (const void *a, const void *b)\fC [static]\fP"
.PP
Definition at line 1460 of file gl2ps\&.c\&.
.PP
References GL2PSprimitive::type, and w\&.
.PP
Referenced by gl2psBuildBspTree()\&.
.PP
.nf
{
  GL2PSprimitive *q, *w;

  q = *(GL2PSprimitive**)a;
  w = *(GL2PSprimitive**)b;
  return(q->type < w->type ? 1 : -1);
}
.fi
.SS "static GLboolean \fBgl2psVertsSameColor\fP (const \fBGL2PSprimitive\fP *prim)\fC [static]\fP"
.PP
Definition at line 705 of file gl2ps\&.c\&.
.PP
References gl2psSameColor(), i, GL2PSprimitive::numverts, GL2PSvertex::rgba, and GL2PSprimitive::verts\&.
.PP
Referenced by gl2psPrintPostScriptPrimitive()\&.
.PP
.nf
{
  int i;

  for(i = 1; i < prim->numverts; i++){
    if(!gl2psSameColor(prim->verts[0]\&.rgba, prim->verts[i]\&.rgba)){
      return GL_FALSE;
    }
  }
  return GL_TRUE;
}
.fi
.SS "static size_t \fBgl2psWriteBigEndian\fP (unsigned longdata, size_tbytes)\fC [static]\fP"
.PP
Definition at line 353 of file gl2ps\&.c\&.
.PP
References i, and GL2PScontext::stream\&.
.PP
Referenced by gl2psPrintPDFPixmap(), and gl2psPrintPDFShader()\&.
.PP
.nf
{
  size_t i;
  size_t size = sizeof(unsigned long);
  for(i = 1; i <= bytes; ++i){
    fputc(0xff & (data >> (size-i) * 8), gl2ps->stream);
  }
  return bytes;
}
.fi
.SS "static void \fBgl2psWriteByte\fP (unsigned charbyte)\fC [static]\fP"
.PP
Definition at line 2466 of file gl2ps\&.c\&.
.PP
References gl2psPrintf(), and h\&.
.PP
Referenced by gl2psPrintPostScriptImagemap(), and gl2psPrintPostScriptPixmap()\&.
.PP
.nf
{
  unsigned char h = byte / 16;
  unsigned char l = byte % 16;
  gl2psPrintf('%x%x', h, l);
}
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBGL2PScontext\fP* \fBgl2ps\fP = NULL\fC [static]\fP"
.PP
Definition at line 293 of file gl2ps\&.c\&.
.SS "\fBGL2PSbackend\fP* \fBgl2psbackends\fP[]\fC [static]\fP"\fBInitial value:\fP
.PP
.nf
 {
  &gl2psPS,  
  &gl2psEPS, 
  &gl2psTEX, 
  &gl2psPDF, 
  &gl2psSVG, 
  &gl2psPGF  
}
.fi
.PP
Definition at line 5556 of file gl2ps\&.c\&.
.PP
Referenced by gl2psBeginPage()\&.
.SS "\fBGL2PSbackend\fP \fBgl2psEPS\fP\fC [static]\fP"\fBInitial value:\fP
.PP
.nf
 {
  gl2psPrintPostScriptHeader,
  gl2psPrintPostScriptFooter,
  gl2psPrintPostScriptBeginViewport,
  gl2psPrintPostScriptEndViewport,
  gl2psPrintPostScriptPrimitive,
  gl2psPrintPostScriptFinalPrimitive,
  'eps',
  'Encapsulated Postscript'
}
.fi
.PP
Definition at line 3317 of file gl2ps\&.c\&.
.SS "\fBGL2PSbackend\fP \fBgl2psPDF\fP\fC [static]\fP"\fBInitial value:\fP
.PP
.nf
 {
  gl2psPrintPDFHeader,
  gl2psPrintPDFFooter,
  gl2psPrintPDFBeginViewport,
  gl2psPrintPDFEndViewport,
  gl2psPrintPDFPrimitive,
  gl2psPrintPDFFinalPrimitive,
  'pdf',
  'Portable Document Format'
}
.fi
.PP
Definition at line 4934 of file gl2ps\&.c\&.
.SS "\fBGL2PSbackend\fP \fBgl2psPGF\fP\fC [static]\fP"\fBInitial value:\fP
.PP
.nf
 {
  gl2psPrintPGFHeader,
  gl2psPrintPGFFooter,
  gl2psPrintPGFBeginViewport,
  gl2psPrintPGFEndViewport,
  gl2psPrintPGFPrimitive,
  gl2psPrintPGFFinalPrimitive,
  'tex',
  'PGF Latex Graphics'
}
.fi
.PP
Definition at line 5536 of file gl2ps\&.c\&.
.SS "\fBGL2PSbackend\fP \fBgl2psPS\fP\fC [static]\fP"\fBInitial value:\fP
.PP
.nf
 {
  gl2psPrintPostScriptHeader,
  gl2psPrintPostScriptFooter,
  gl2psPrintPostScriptBeginViewport,
  gl2psPrintPostScriptEndViewport,
  gl2psPrintPostScriptPrimitive,
  gl2psPrintPostScriptFinalPrimitive,
  'ps',
  'Postscript'
}
.fi
.PP
Definition at line 3306 of file gl2ps\&.c\&.
.SS "\fBGL2PSbackend\fP \fBgl2psSVG\fP\fC [static]\fP"\fBInitial value:\fP
.PP
.nf
 {
  gl2psPrintSVGHeader,
  gl2psPrintSVGFooter,
  gl2psPrintSVGBeginViewport,
  gl2psPrintSVGEndViewport,
  gl2psPrintSVGPrimitive,
  gl2psPrintSVGFinalPrimitive,
  'svg',
  'Scalable Vector Graphics'
}
.fi
.PP
Definition at line 5312 of file gl2ps\&.c\&.
.SS "\fBGL2PSbackend\fP \fBgl2psTEX\fP\fC [static]\fP"\fBInitial value:\fP
.PP
.nf
 {
  gl2psPrintTeXHeader,
  gl2psPrintTeXFooter,
  gl2psPrintTeXBeginViewport,
  gl2psPrintTeXEndViewport,
  gl2psPrintTeXPrimitive,
  gl2psPrintTeXFinalPrimitive,
  'tex',
  'LaTeX text'
}
.fi
.PP
Definition at line 3464 of file gl2ps\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Octave from the source code\&.
